;# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;# Cycle:     TC_BS.SPF
;# Task:      Tool Change
;# Version:   V06.00.07
;# Date:      07.11.2017 / Simons
;# Control:   840DSL Operate
;# TM:        Siemens
;# NBHSeries: 5-1000
;# Magazines: All
;# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;#
;------------------------------------
;
; Verlauf:
; --------
;
; V06.00.07 - 07.11.2017 / Simons
; - Anwahl "Stop bei Ersteinsatz" hinzu (207.2)
;
; V06.00.07 - 28.10.2017 / Simons
; - Fehlerreaktion beim Verlassen des Magazinraums geaendert (1600.0)
; - FestplatzWz setzen angepasst (1010.1)
;
; V06.00.07 - 09.09.2017 / Simons
; - gbSearchRelST hinzu (205.0,711.1,712.1)
; - SyncID_TC+9..12 werden erst durch Reset gecancelt,
;   damit die Ueberwachungen erhalten bleiben
;
; V06.00.07 - 04.09.2017 / Simons
; - Korrektur WzGewicht (60.0,610.0)
; - Korrektur $TC_DPCx (400.0,1650.0)
; - Anzeige WzWechsel fuer HHDTM
; - HG Klemmen nur wenn keine Miksch Kette (871.2)
; - Anwahlen Kuehlmittelfunktionen und SpDrehrichtung aus WzDaten aktivieren hinzu
; - grSyncPickUpDrop nur bei Scheibe zuruecksetzen
;
; V06.00.07 - 10.08.2017 / Simons
; - WP aktiviert
; - USER_DATA_HEX[12] -> giMachType
; - Programmfortsetzung bei DG>190Grad (mit M_WaitDGFinshed bei 255Grad)
; - Funktion von (ehemals 871.4) verlagert
; - WHENEVER (TRUE) DO -> DO
; - Abfrage Magazintyp entfernt (711.2)
; - LaufzeitOptimierung
;
; V06.00.07 - 16.07.2017 / Simons
; - TestStop bei Halt vor WzW (300.4)
;
; V06.00.07 - 04.07.2017 / Simons
; - Neuversionierung
; - Beruecksichtigung der geforderten Fahrlogik auch bei gbTCFirstZMove (130.0)
;
; V06.00.07 - 15.06.2017 / Simons
; - Neuversionierung
; - Einfuehrung von gbPrevToBrokenInt und bHoldBeforeTC_BBK, damit die Anzeige
;   des Bruchs des VorgaengerWz's nach dem TC noch moeglich ist
; - TOOL_BREAK_REACTION hinzu (1645.0)
; - CheckTlData(.,0,.) (1660.0)
; - keine Abfrage auf X-Achsposition bei bNoRealTC
; - MakeAlarmParam eingefuehrt
; - WORKSTEP ohne Argument + numerischer WzName -> WORKSTEP=WzName
; - APC nicht in GndSt und Funktion Z/B-Achse gefordert -> M91
; - Einfuehrung WAITAPC
; - Korrektur (201.1)
; - Neg. Vorbereitungsquittierung im ToPrep -> (200.6),(203.0)
; - Einschraenkung bei Variablennamen
; - formale Aenderungen
;
; V06.00.06 - 03.05.2017 / Simons
; - 900.1 und 920.1 mit "(NOT OUT_DGRotInBasePos)"
;
; V06.00.06 - 21.04.2017 / Simons
; - Neuversionierung
; - 900.7 / 920.7 POS[mcAxX]=... anstatt X=....
; - 5.2 Auswertung von iDuploNo
; - bSyncReleased entfernt
; - formale Aenderungen
;
; V06.00.05 - 31.03.2017 / Simons
; - bMagIsWM307 hinzu
; - keine flexible Kette -> immer <FestplatzWz> Setzen
; - Beim Entladen (182.2) - Fahren in die Vorposition, auch wenn Wz im HG/DG
; - Funktionsaenderung Vorbereitung (200.1, 201.1)
; - MOVE_APC hinzu
; - Vorlauferkennung geaendert
; - giSyncPickupDrop -> grSyncPickupDrop
;
; V06.00.05 - 13.02.2017 / Simons
; - Berechnung iErrTime... geaendert
; - Bereichskennzeichner SYG_RM[iSYGArea] eingefuehrt
; - Bereich 810.5 entfernt
; - WM286:Prepare bei leerer Sp angepasst (200.6)
; - Bei einigen Berechnungen rCloseDoorX anstatt rPrePosX
; - WM307: 811.7 verlagert
; - Freigabe Magazinbedienpult bei laufendem WzW
;
; V06.00.05 - 20.01.2017 / Simons
; - rColMaxRad entfernt
; - NCDG: Drehrichtungsaenderung nur bei ueberlangem SpWz
;
; V06.00.05 - 08.12.2016 / Simons
; - Korrektur - giSyncPickupDrop
;
; V06.00.05 - 30.11.2016 / Simons
; - WM286, rSafeCalc/DG
; - gbDG2MagSide verlagert (812/871)
; - Pruefungen vor Start des WzW's verlagert (80-81)
;
; V06.00.05 - 18.11.2016 / Simons
; - Entladen von DG2/HG bei leerer Sp und T0
; - rLimitPlusX, bMagIsMiksch
;
; V06.00.05 - 28.09.2016 / Simons
; - Neuversionierung
; - MTC: Auswertung grExit... wie bei NCDG
;
; V06.00.04 - 16.09.2016 / Simons
; - Neuversionierung
; - Plandrehkopf: Wartezeit vorm Zurueckziehen
;   -> Abbau Kuehlmitteldruck
; - bei T0 bleibt die Scheibe nicht mehr ausgehoben,
;   sondern wird zeitverzoegert zurueckgefahren,
;   wenn in der Wartezeit Kanal 2 die Freigabe
;   nicht zuruecknimmt
; - Hinzu:
;   - ID=SyncID_TCLoad ...
;   - Leer-/Altplatzbestimmung OR(iToDo==mcTaskLoad)
;   - grMaxTlDG
;   - Endgueltige Quittierung nur bei PickUp und Kette WM307
;   - voreilendes Spannen bei MTC
;   - $AC_CYCLE_TIME -> $A_DBR[480]
;   - gbDG2MagSide angepasst
;   - Warten auf DG/XT in Grundstellung hinzu
;   - Wz Messen entfernt
;   - ToAckn (5.5) entfernt
;   - 730.2 voreilendes Loesen MTC
;
; V06.00.03 05.07.2016 / Simons
;   NBH 500 (CIE D.1009265.00x)
; - 872.x Fehlerzaehler zuruecksetzen
; - Ueberwachungszeit erhoeht (5->10s)
; - 920.x Schrittzaehler erst beim Fahren
;   aus der Maschine weiterschalten,
;   sonst koennte er wieder durch SyncID_TC+4
;   ueberschrieben werden -> Sp bleibt gesperrt
;
; V06.00.03 - 22.05.2016 / Simons
; - Einfuehrung Prepare Optimierung
; - Einfuehrung MsgBox
; - Anpassungen HandWz
; - Ablaufaenderung WM307
; - Abbruchverhalten bei fehlendem Wz veraendert
; - Vorgabe Kippmoment
; - Einfuehrung TM HHD
; - Kuemi Anwahl, Vorwahl Sp Drehrichtung
;   bei Verlassen des Magazins, wenn nicht
;   schon im PrSearch
; - Vorgabe Spindeldrehzahl
; - Aufruf IPOTURN geaendert
; - DG Vorpositionieren geaendert
;   (verminderte Geschwindigkeit)
; - Ueberpruefung von WzDaten, die in
;   gsReqTlData definiert sind mit CheckTlData
;   bevor ein Neues Wz eingewechselt wird.
;   Kein verkuerzter WzW und Fehlermeldung
;   bei ungueltigen WzDaten
; - Absoluter WzAufruf (mit Name und DuploNr)
; - Wieder mit Prog_Reset
; - Vorpositionieren - DG - Geschwindigkeit
;   Mit verminderter Drehzahl, zusaetzlich
;   noch mit Sicherheitsfaktor bei der Rechnung
; - Simulation korrigiert
; - Erhoehung der Funktionssicherheit der
;   Abbruchkorrektur im TMReset - neue
;   Variablen giNextTlInSp, giTlInSp einge-
;   fuehrt
; - Einfuehrung Sonderwerkzeuge
; - Keine Fehlerueberwachung bei SYG_IM[iSYG+3]=0
;   (NC_INIT1)
; - Vorbereitung Wz Umspeichern im TMReset auch bei HandWz
;
; V06.00.01/03 - 19.09.2015 / Simons
; - NBH500 (CIE) D.1009207.001/2
;
; V06.00.01 - 03.09.2015 / Simons
; - NBH5S  (EMO) D.1009180.001
;
; V06.00.00 - 05.03.2015 / Simons
; - ProtoTyp
;
;-------------------------------------
;
; Beschreibung:
; -------------
;
; - $A_DBW[476] - Laufzeit der Werkzeugwechseltuer
; - $A_DBW[478] - mcDBW_WaitDiskRetract - Wartezeit Scheibe absenken
; - $A_DBR[480] - mcDBR_Time - Programmlaufzeit aus IDS211
; - $A_DBD[484] - Ortswechselauftrag 1 (ToAckn)
; - $A_DBD[488] - Ortswechselauftrag 2
; - $A_DBB[492-499] - Frei
;
; - Einsatz Synchronaktions-GUD als interne Register:
;   SYG_RM[iSYG+0..3], SYG_IM[iSYG+0..3]
; - CreateNCProg (angepasste Kompilierung)
;   -> Kommentare mit Kompilerschaltern
; - Minimale Vorbereitungszeit zur Vermeidung von
;   Geschwindigkeitseinbruechen beim Fahren in die TCPos
; - Annaeherung der Spindelhochlaufkennlinie in Abhaengigkeit
;   von der Wz Masse (Traegheitsmoment)
; - Ueberwachung auf max. WzKippmoment fuer voreilende Funktionen
; - mcDBB_StepTC als Statusanzeige fuer HOME
;   mcDBB_StepTC=0 -> kein WzW
;   sonst:
;   mcDBB_StepTC.0 = WzW laeuft
;   mcDBB_StepTC.1 = Drehrichtung negativ
;   Bei FestplatzWz oder HG
;   mcDBB_StepTC.2 = Wz in Magazin Entladen Sp -> MAG/HG
;   mcDBB_StepTC.3 = Wz in Sp Beladen   MAG/HG -> Sp
;   mcDBB_StepTC.4 = Wz Beladen nach Entladen eines FestplatzWz's
;
; - giTCMask = Anwahl von Einzelfunktionen im TC
; - Maschinenspezifischer Ruck fuer Rechenmodel
;
; - Einfuehrung programmspezifische Konfiguration - mcDBB_ProgConfig
;   mcDBB_ProgConfig.0 = kein Bedienerruf bei Erstbearbeitung
;                    Auswertung von gbTlFirstMach im Kundenprogr.
;   mcDBB_ProgConfig.1 = kein Bedienerruf bei Werkzeugbruch (WAITCHECK)
;                    Auswertung von gbLastToBroken im Kundenprogr.
;   mcDBB_ProgConfig.2 = kein Bedienerruf bei Werkzeugbruch (WAITPREVCHECK)
;                    Auswertung von gbPrevToBroken im Kundenprogr.
; - Verwendung schneller HiFu
; - Gewichtsabhaengige Geschwindigkeit des DG auch bei NC-DG
; - Bei dynamischen Abfragen $AA_IM gegen $VA_IM ersetzt
; - Vorbereitenden Loesen/Spannen
;   - 1. kein vorbereitendes Loesen bei Werkzeugen mit zu hohem Kippmoment
;   - 2. Der NC-DG wird zeitgesteuert gestartet
; - Geaendertes Anfahren TCPOS mit der X-Achse
;   - Beruecksichtigung der Spindel
; - Anstoss eines fehlenden PREPARE's schon im Vorlauf
; - bei Satzvorlauf immer M5 S0
; - Beruecksichtigung von ueberlangen Werkzeugen, die nur mit Hilfe der B-Achse
;   eingefaedelt werden koennen. Fehlermeldung, wenn keine explizite Freigabe vorm TC
;
;   NameOfAxis1 auf 128 Zeichen erweitert ->
;   Im Anwahlstring moeglich
;   - TCWP     - kein Fahren aus Magazin -> Aufruf von TCWP wird erforderlich
;   - WP       - kein Fahren aus Magazin, weiter im Kundenprogramm
;   - MOVE_... - anwaehlbare Fahrlogik von X,Z,B
;     Bewegungsprofile      X,Y   Z   B
;     ----------------------------------------------------------------------------
;     MOVE_X      :          1    -   -   :  B&Z bleiben stehen / kein B&Z erlaubt
;     MOVE_X_Z    :          1    2   -   :  B bleibt stehen    / kein B erlaubt
;     MOVE_X_B    :          1    -   2   :  Z bleibt stehen    / kein Z erlaubt
;     MOVE_XB     :          1    -   1   :  Z bleibt stehen    / kein Z erlaubt
;     MOVE_X_ZB   :          1    2   2   :  kein Zwang
;     MOVE_X_Z_B  :          1    2   3   :  kein Zwang
;     MOVE_XZ_B   :          1    1   2   :  B Zwang
;     MOVE_XZB    :          1    1   1   :  kein Zwang
;     MOVE_Z_X_B  :          2    1   3   :  kein Zwang
;     MOVE_Z_XB   :          2    1   2   :  kein Zwang / Standard
;     MOVE_APC    :          2    1   2   :  kein Zwang (Palettenwechselposition Z,B anfahren)
;
;   - Einfuehrung gbTCFirstZMove
;     Am Beginn des Kundenprogramms oder mit RESET wird mit
;     gbTCFirstZMove=TRUE die Funktion fuer den folgenden WZW abgewaehlt.
;     Somit ist die Z-Position beim Einstieg sicher auf grTCPosZ,
;     sonst in der Hand des Programmierers und abhaengig vom Programmablauf.
;   - WaitCool - Warten bis Spindel steht und Kuemi aus
;     vor Oeffnen der WzWTuer
;   - WaitAPC - Nach TC auf das Ende Palettenwechsels Warten
;   - WaitPrevCheck - Abfrage der laufenden BBK vor WzW
;   - WaitCheck - Abfrage der BBK fuer SpWz nach WzW
;   - WorkStep - Vorwahl im TC mit und ohne Angabe eines Arguments
;   - M11,M10,(M18)
;   - B, B=DC(...), B=IC(...), B=ACP/N(...)
;   - G54...G599 fuer die B-Achse (WKS)
;   - G153 Z... Zielposition (MKS)
;   - G91 Z... Inkrementell zur Istposition
;   - D-Nummer nur wenn nicht TCWP
;   - ENMaxTl - Freigabe von Werkzeugen mit maximaler Werkzeuglaenge
;   - S - Spindeldrehzahl
;
;   Einfuehrung neuer globaler Variablen
;   ------------------------------------
;   - grSpClmpTime, grSpUnClmpTime, grHGClmpTime, grHGUnClmpTime, grMidFeedDGRot, grRelMagDGRot
;   - grTCSPOS1_k1, grTCSPOS1_k2, grTCSPOS1_n1, grTCSPOS1_n2, grTCSPOS1_tb, grJSpG1
;   - grTCSPOS2_k1, grTCSPOS2_k2, grTCSPOS2_n1, grTCSPOS2_n2, grTCSPOS2_tb, grJSpG2
;   - grAccValLow, gbEnaTCMaxToolLen, grTcMaxToolLen, grTlTiltTorqueSp,grTlTiltTorqueDG, gbTCFirstZMove
;   - grTCRelSpDist, giDGType, grSpUnClmpTimeC, grSpClmpTimeC, grHGUnClmpTimeC, grHGClmpTimeC
;   - grTCJerkX, grTCJerkY, grTCJerkZ, grTCJerkDGRot, grExitStartX, grExitDoorHeight grExitRadXY
;   - SYG_BM[0..7],SYG_RM[0..19], SYG_IM[0..9], giTCMask, grTCPrepTimeMin
;   - mcDBB_StepTC, OUT_PrepActive
;   - gbOptToolPrep, giPrepMode, gsPrepProgName, gsPrepTName, gsPrepReq, gsPrepInfo, gbPutToTime, gbGetToTime
;   - giActPrepTime, giMaxPrepTime, gbPrepAfterTC, gbWaitPrepare, gbTCPrepTeachRun
;
;   SYG im Kanal 1:
;   ---------------
;   Belegung SYG_BM[iSYG + ..]
;   0 - T.. seit letztem WzW
;       (aus NC_INIT1 IDS 1)
;   1 - durch NC_INIT1 belegt
;   2 - durch NC_INIT1 belegt
;   3 - Ueberwachung WzWTuer Ein
;   4 - FehlerSpeicher zu 3
;   5 - Spindelfreigabe in TCWP
;   6 - DG Vorpositionieren Freigabe
;   7 - Planzugachse in WzWPosition
;
;   Belegung SYG_IM[iSYG + ..]
;   ---------------------------
;   0 - Schrittzaehler allgemein
;       0          = GndSt
;       icLastStep = letzter Schritt
;   1 - Positionierschritte X Achse
;       0 -> noch nicht gestartet
;       1 -> Start nach rPrePosX
;       2 -> ZwischenStart nach rSPOSX
;       4 -> Start rTCPOSX/rSPOSX
;   2 - Ablauffreigabe Scheibe
;   3 - TimeOut Zaehler Inkrement (IDS 10 NC_INIT1)
;   4 - frei
;   5 - Laufkontrolle X (in TCWP)
;   6..8 frei
;   9  - Workstep Prepare Optimierung
;   10 - Nummer des zuletzt vorbereiteten
;        Wz's (aus NC_INIT1 IDS 1)
;   11..19 durch NC_INIT1 belegt
;
;   Belegung SYG_RM[iSYG + ..]
;   ---------------------------
;   A) Bremsrampenerkennung (X,DG)
;   0 - Geschwindigkeit
;   1 - Geschwindigkeitsdifferenz (pro IPO)
;
;   B) Fahren mit spannender Sp
;   2 - Ueberwachungszeit Spannen
;   3 - Frei
;
;   C) Start NC DG Vorpositionieren
;   4 - Restzeit X Achse
;   5 - (WM307) Restzeit Sp Loesen
;       (WM286) Restzeit Sp Richten
;   6 - (WM307) Dekrement zu 5 Freigeben
;   7 - Restzeit HG Loesen
;   8 - Dekrement zu 7 Freigeben
;   9 - Restzeit Y Achse
;  10 - Override Y beim Verlassen des Magazinraums
;  11 - DG Vorpositionieren Geschwindigkeit X
;  12 .. 17
;  18 - Bereichsbezeichner (TC_BS)
;  19 - Startzeit Prepare Optimierung Lernen
;
;   -------------------------------------------------
;   Status der Synchronaktionen nach Verlassen des TC
;   (nicht aktuell)
;   --------------------------------------------------
;   Es waren aktiv:
;   SyncID_TC+0: X,Y,..-Achse fahren
;   SyncID_TC+1: Z-Achse fahren
;   SyncID_TC+2: B-Achse fahren
;   SyncID_TC+3: MTC/Scheibe - X Achse fahren auf TCPos
;   SyncID_TC+3: Scheibe - auf Position NeuWz
;   SyncID_TC+4: Spindel voreilend Loesen
;   SyncID_TC+5: Mit DG: HG/Kette Loesen
;   SyncID_TC+5: Scheibe: Hub Vor / Zurueck
;   SyncID_TC+6: Wzw-Tuer Oeffnen
;
;   SyncID_TC+7: Sonstiges
;
;   NC-DG: Vorstart DG
;   SyncID_TC+8: DG auf Vorposition Schwenken
;
;   MTC: Fahren auf rSpPosX
;   SyncID_TC+8:  Berechnung Geschwindigkeit X
;   SyncID_TC+9:  Berechnung Geschwindigkeit X
;   SyncID_TC+10: Berechnung Geschwindigkeit X
;   SyncID_TC+11: Fahren auf rSpPosX
;
;   Es sind aktiv:
;   SyncID_TC+3: NC-DG - In Grundstellung Fahren
;   SyncID_TC+4: Spindel Klemmen
;   SyncID_TC+5: NC-DG - HG Loesen / Klemmen
;   SyncID_TC+5: Scheibe: Hub Vor / Zurueck
;   SyncID_TC+6: Wzw-Tuer schliessen
;   SyncID_TC+7: Wzw Quittierung
;   SyncID_TC+8: SpWz Klemmen -> Ausgabe M70
;
;   Ueberwachung:
;   SyncID_TC+9: Sp nicht gespannt -> Sperre X
;                Nur bei WM307: Wz nicht gespannt -> auf rPrePosX Fahren
;   SyncID_TC+10: X > rPrePosX & Restweg Y -> Sperre Y
;   SyncID_TC+11: X > rSpPosX -> Sperre Sp
;   SyncID_TC+12: Ueberwachung WzW Tuer
;
;   SyncID_TC+0..2 werden durch TCWP benutzt
;
; ----------------------------------------------
; Werkzeugwechsel mit Siemens Werkzeugverwaltung
;-----------------------------------------------
;
; Unterdrueckung der Systemmeldungen fuer HandWz $MN_SUPPRESS_ALARM_MASK_2 Bit 16
;
; WzW-Abfolge:
;-------------
; NeuWz: HG->DG1->SP  -  AltWz: SP->DG2->HG
;
; Auftraege (iToDo):
; -----------------
; - mcTaskLoad       110=WzW in Verbindung mit <Beladen ueber Beladestelle_Hand>
; - mcTaskUnload     111=WzW in Verbindung mit <Entladen ueber Beladestelle_Hand>
; - mcTaskUnloadInSp 113=WzW in Verbindung mit <Umsetzen ueber Spindel>
;
; - mcTaskPrep    211=WzW klassisch
; -               212=reine Wz Vorbereitung (Kanal 2)
; - mcTaskAS_Displace  500=Wz (asynchron) im Magazin umsetzen
; - mcTaskAS_T0   501=Spindel leerfahren (asynchroner Auftrag)
;
; Aufruf:
; -------
; - direkt aus dem Bearbeitungsprogramm, z.B. TC_BS(211,"MeinWz")
; - indirekt aufgerufen, wenn im Bearbeitungsprogramm M6 programmiert ist (M-Funktions-Ersetzung)
; - Bediener stoesst <Beladen ueber Beladestelle_Hand> an
; - Bediener stoesst <Entladen ueber Beladestelle_Hand> an
; - Bediener stoesst <Wz messen/pruefen> an
;

PROC TC_BS(INT iTaskLocID, STRING[64] sToolName, INT iToolDuploNo, STRING[128] sNameOfAxis1, REAL rPosOfAxis1, STRING[1] sNameOfAxis2, REAL rPosOfAxis2) SAVE DISPLOF SBLOF

DEFINE mcbSpInTCPosCoarse AS (($AA_STAT[CS1]>1)AND(($A_DBB[83] B_AND 1)==1))
DEFINE mcbSpInTCPosFine AS (($AA_STAT[CS1]==4)AND(($A_DBB[83] B_AND 1)==1))

DEF STRING[32] sCycName="TC_BS V06.00.08", sTName="", sWPType="", sMissingTl="", sModeB="DC", scPunkte="...", sAlarmParam=""
;
DEF STRING[32] sTmp, sTmp1, sMove, sSelTName, sPrepTName, sOldTName, sAlarmParamBBK
DEF STRING[128] sCode, sNo, sArg
DEF STRING[255] sAux
; Konfiguration
DEF BOOL bWithHead, bMagIsMiksch, bMagIsWM307, bPrepBeforeTCPosX, bDGIsWM307, bDGIsWM286, bDGIsMTC, bDGIsNcAxis, bMagIsCas, bMagIsChain, bMagIsPickUpDisk, bMagIsDDisk, bMagXTIsNcAxis
; Betriebsarten
DEF BOOL bFast=TRUE, bExpectChange=FALSE, bNoRealTC=FALSE, bNewIsManTl=FALSE, bOldIsManTl=FALSE
DEF BOOL bSearchSim, bRelPrep_Clmp_UnClmp, bRelPreClmp, bRelPreUnClmp, bRelMoveUnClmp, bRelPrePosDGRot, bRelSpSw, bRelAuxSw, bRelPosAfterTC, bRelExitXY, bRelSpPosX, bRelSpByX, bRelMoveUnClmp_C, bRelMoveUnClmp_U, bMonTCMaxToolLen, bHoldBeforeTC, bHBTCTestStop, bRelCool, bRelSpDir
; Anforderungen
DEF BOOL bMoveInTCPrePos=TRUE, bBAxis=FALSE, bZAxis=FALSE, bTurnDgFast=FALSE, bCheckOldTl=FALSE, bWaitPrevCheck=FALSE, bInitPrePosDGRot=FALSE, bBAxReq=FALSE, bZAxReq=FALSE, bReqM11=FALSE, bPutM206=FALSE, bTurnNeg=FALSE, bM3=FALSE, bM4=FALSE, bCoolM1=FALSE, bCoolM2=FALSE, bHoldBeforeTC_BBK=FALSE
DEF BOOL bWaitZB=FALSE, bMove=FALSE, bMoveX=FALSE, bMoveZ=FALSE, bMoveX_Z=FALSE, bMoveX_B=FALSE, bMoveX_ZB=FALSE, bMoveX_Z_B=FALSE, bMoveXZ_B=FALSE, bMoveXZB=FALSE, bMoveXZ=FALSE, bMoveXB=FALSE, bMoveZ_XB=FALSE, bMoveZ_X_B=FALSE, bMoveAPC=FALSE, bMoveZinSafePos=FALSE, bWaitAPC=FALSE
DEF BOOL bPosAfterTC, bReqPosAfterTC, bReqLockSpTool, bNewTurnDgFast, bOldTurnDgFast, bEnMaxTlLen, bCheck, bTlCheckOn, bRelMoveZDefault, bTlReplace, bWaitDoorCoolant, bTestStopReq
; Status
DEF BOOL bNewTlFast=TRUE, bOldTlFast=TRUE, bIsT0=FALSE, bLubActive=FALSE, bSecLoop=FALSE, bFxPlUnLoad=FALSE, bFxPlLoad=FALSE, bRepeatPrep=FALSE, bOffsNotValid=FALSE, bInPrSearch=FALSE, bNegResultBBK=FALSE, bNewTlNotMeasured=FALSE, bCleanSp=FALSE, bG153Last=FALSE, bG91Last=FALSE
DEF BOOL bNewTlFxPl, bOldTlFxPl, bSpTlOverSize, bHgTlOverSize, bBAxUnclamped, bAxBInPos, bDGInBasePos, bTlClmp, bActMSG, bStatCha2, bArgIsString, bAllAxInFinePos, bTCNotFinished, bAPCInPos
; Sonstiges
DEF BOOL bTmp, bTmp1, bTmp2, bTmp3, bTmp4, bRetractDisk, bSelected, bEnabled, bSwitched, bSwitchedSp, bError, bSepArg, bSpIsClmp, bSpIsUnClmp, bAuxIsUnClmp, bAxSpInPos, bProgCall, bLubRequested
;
DEF REAL rcErrTimeDefault=10, rcWaitTimeCha2=20, rcPLCCycTime=0.018, rc0x001deg=0.001, rc0x5deg=0.5, rc1x0deg=1.0 ,rc2x0deg=2.0, rcPrepIPOCount=60, rcMinSpSpeed=10, rcRedVeloDG=0.35, rcOvrMultX=0.55, rcOvrMultY=6, rWRedSp=1.0, rSafeCalc=1.05, rFeedFactor=1.0, rNewTlACC=100, rWNewTl=0, rWOldTl=0, rOldTlColLen=0, rJOldTl=0, rSpeed=0, rAlarmAreaBBK=0, rActPosDiffHead=0
DEF REAL rTmp, rTmp1, rTmp2, rTmp3, rTmp4, rNo, rIPO, rWaitShort, rWaitPLC, rWaitLong, rVelo, rCalcTime, rCalcTime1, rMoveDistX, rMoveDistY, rPosWin, rPosTime, rActSpeed, rc0x1mm, rc0x2mm, rc0x5mm, rc1x0mm, rc2x0mm
DEF REAL rActPos, rTargetPos, rProgBPos, rProgZPos, rActXPos, rActYPos, rActZPos, rActBPos, rActDGPos, rTcSPosRes, rActJerkY
DEF REAL rSpPosX, rWaitPosX, rPrePosX, rCloseDoorX, rPrePosDGRot, rFirstPosDGRot, rNextPosDGRot, rEndPosDGRot, rBPosMin1, rBPosMin2, rBPosMax1, rBPosMax2, rRelSpExitX, rTcRelCoolX
DEF REAL rFeed, rFeedX, rFeedY, rFeedZ, rFeedB, rFeedV1, rFeedXPrePos, rFeedXRelSp, rFeedDGRot, rFeedEmptyDGRot, rNewFeedDGRot, rPrePosTimeDGRot
DEF REAL rColRadX, rColRadYZ, rDoorActTime, rWTl, rJTl, rWDiff, rDgVeloFact, rDiffFact, rDgVeloDiff, rRelXByY, rTCInPosFine, rTCInPosCoarse, rNewTlJ, rOldTlJ
DEF REAL rActVelo, rActVeloDiff, rActJerk, rActTj, rActVj, rMaxVeloX, rMaxJerkX, rMaxAccelX, rMaxTjX, rMaxVjX, rMaxVeloY, rMaxJerkY, rMaxAccelY, rMaxTjY, rMaxVjY, rMaxVeloDG, rMaxJerkDG, rMaxAccelDG, rMaxTjDG, rMaxVjDG
DEF REAL rSpUnClmpTime, rHGUnClmpTime, rSpClmpTime, rHGClmpTime, rSpVeloMin, rSpVelo, rHGVeloMin, rHGVelo, rSpVeloWindow, rRelMagDGRot, rPrepTimeMin, rMagPlDist, rMagPlLastPos, rMagPlCount, rLimitPlusX, rSafeCalcDG
;
DEF INT icMagNo=1, icClmpStep=5, icLastStep=7, icWaitDiskRetract=5, iResult=0, iAlarmNo=0, iHomeStatus=1, iClpB=-1, iDNo=-1, iWorkStep=-1, iZONo=0, iGG8=0, iSpUnLoadLoc=0, iSpUnLoadMag=0, iSpLoadLoc=0, iSpLoadMag=0, iNewTNo=0, iNewTlSpecType=0, iDuploNo=0
DEF INT iSYG, iSYGInc, iSYGArea, iTmp, iTmp1, iTmp2, iCount, iErrCount, iErrTimeShort, iErrTimeLong, iWaitCha2, iCodeLastPos, iNo, iCmdNo, iSpNo, iState, iNewTlMag, iNewTlLoc, iOldTNo, iOldTlMag, iOldTlLoc, iTlOpt, iPos, iToDo, iTaskId, iTaskIdNo, iProgConfig
DEF INT iMeasCutNo, iMeasMode, iMeasState, iFeedOVR, iActGearStep, iClampStatus, iMagPos, iSpMask, iSpResult, iAuxMask, iAuxAdr, iAuxResult, iAlarmNoBBK=0, iSelBBK_DBB, iSelBBK_Mask, iStatCha2, iH80, iSelTNo, iPrepTNo, iSTNo, iSelSTNo, iPrepSTNo, iOldSTNo, iSep1

;-[]-0.0--GndSt-
;---------------
gbTlFirstMach=FALSE rIPO=$MN_IPO_CYCLE_TIME iSpNo=$P_MSNUM rWaitShort=(2*rIPO) rWaitLong=(8*rIPO) rWaitPLC=(rcPLCCycTime*3) rc0x1mm=(0.1*grInchMetr) rc0x2mm=(0.2*grInchMetr) rc0x5mm=(0.5*grInchMetr) rc1x0mm=(1.0*grInchMetr) rc2x0mm=(2.0*grInchMetr) rProgZPos=grTcPosZ rPrepTimeMin=rcPrepIPOCount*rIPO rSpVeloWindow=(6*$MN_POSCTRL_CYCLE_TIME)
iSYG=mcSYG_TC iSYGInc=mcSYG_ErrIncCha1 iSYGArea=(iSYG+18) iWaitCha2=RTOI(rcWaitTimeCha2/rWaitShort) iErrTimeShort=RTOI(rcErrTimeDefault/rWaitShort) iErrTimeLong=RTOI(rcErrTimeDefault/rWaitLong) rLimitPlusX=$MA_POS_LIMIT_PLUS[mcAxX]
;
;-1.0--TC Konfig-
; Doppelgreifer
;----------------
bDGIsMTC=((giDGType B_AND 'B1')<>0) bDGIsWM286=((giDGType B_AND 'B10')<>0) bDGIsWM307=((giDGType B_AND 'B100')<>0) bDGIsNcAxis=((bDGIsWM286)OR(bDGIsWM307))
;
;-1.1--TC Konfig-
; Magazin
;----------------
bMagIsCas=((giMagType B_AND 'B1000000')<>0) bMagIsChain=((giMagType B_AND 'B100')<>0) bMagIsPickUpDisk=((giMagType B_AND 'B1')<>0) bMagIsDDisk=((giMagType B_AND 'B10110000')<>0) bMagIsWM307=((bMagIsChain)AND(bDGIsWM307)) bMagIsMiksch=((bMagIsChain)AND(NOT bMagIsWM307)) bMagXTIsNcAxis=((giMagType B_AND 'B11100010')<>0) bPrepBeforeTCPosX=((bMagIsMiksch)OR(bMagIsPickUpDisk))
;
;BBK Angewaehlt und eingeschaltet (Anwahl in $A_DBB[iSelBBK_DBB])
IF (bMagIsCas)
  iSelBBK_DBB=30 iSelBBK_Mask=1
ELSE
  iSelBBK_DBB=3 iSelBBK_Mask=32
ENDIF

;-1.3--TC Konfig-
;----------------
;
;Freigabe aus giTCMask
; .0 = voreilendes Spannen
; .1 = voreilendes Loesen
; .2 = Freigaben durch Sp Gespannt/Geloest Endschalter
; .3 = Freigaben durch Mag/HG Gespannt oder ScheibenHub Vorn/Hinten Endschalter
; .4 = Fahren mit geloester Sp
; .5 = DG Vorpositionieren
; .6 = Fruehzeitiges Verlassen TC
; .7 = Freigabe der Spindelvorposition (SpPosX)
; .8 = Fahren der Y Achse im Magazinraum (rExit..)
; .9 = Ergaenzung zu .4 - Kritische Wz werden gespannt uebergeben
; .10 = Freigabe der Spindelvorposition fuer die Drehzahlfreigabe
; .11 =
; .12 = Defaulteinstellung ist MOVE_XZB sonst MOVE_Z_XB
; .13 = Teststop bei Halt vor WzW
; .14 = Kuehlmittel schon im WzW an Hand der WzDaten aktivieren
; .15 = SpDrehrichtung im WzW an Hand der WzDaten aktivieren
;
bRelPreClmp=((giTCMask B_AND 'B1')<>0) bRelPreUnClmp=((giTCMask B_AND 'B10')<>0) bRelSpSw=((giTCMask B_AND 'B100')<>0) bRelAuxSw=((giTCMask B_AND 'B1000')<>0) bRelPrePosDGRot=((giTCMask B_AND 'H20')<>0) bRelPosAfterTC=((giTCMask B_AND 'H40')<>0) bRelSpPosX=((giTCMask B_AND 'H80')<>0) bRelExitXY=((giTCMask B_AND 'H100')<>0)
bRelMoveUnClmp=((giTCMask B_AND 'H10')<>0) bRelMoveUnClmp_C=((giTCMask B_AND 'H210')=='H210') bRelMoveUnClmp_U=((giTCMask B_AND 'H210')=='H10') bRelMoveZDefault=((giTCMask B_AND 'H1000')==0) bRelSpByX=((giTCMask B_AND 'H400')==0) bHBTCTestStop=((giTCMask B_AND 'H2000')<>0) bRelCool=((giTCMask B_AND 'H4000')<>0) bRelSpDir=((giTCMask B_AND 'H8000')<>0)
;Fruehzeitiges Verlassen TC
bReqPosAfterTC=(bRelPosAfterTC)AND(gbPosAfterTC) gbPosAfterTC=FALSE
IF (bReqPosAfterTC)
  ;
  ;auf Z,B Warten
  ;--------------
  sWPType="WP"
ENDIF
;Tuer oeffnen, wenn Spindel steht
bWaitDoorCoolant=gbWaitCoolantEnd gbWaitCoolantEnd=FALSE
;Ueberpruefung max. Werkzeuglaenge (MTC)
bMonTcMaxToolLen=bDGIsMTC bEnMaxTlLen=gbEnaTCMaxToolLen gbEnaTCMaxToolLen=FALSE
;Mit Kopf
bWithHead=(gbSwivHeadExist)OR(gbTiltHeadExist)
;Simulation
bSearchSim=($P_SEARCH)OR($P_ISTEST)OR($P_SIM)
;
;-2.0--Auftrag-
; SUBPAR 1
;--------------
;
IF (NOT $P_SUBPAR[1])
  ;
  ;TC ohne WzName -> WzW
  ;
  iTaskLocID=mcTaskPrep
ENDIF
;
IF (iTaskLocID==mcTaskUnLoadInSp)
  ;
  ;Wz aus Magazin in Sp
  iToDo=mcTaskUnLoad bTlReplace=TRUE
ELSE
  iToDo=iTaskLocID bTlReplace=FALSE
ENDIF
;
IF (iToDo==mcTaskLoad)OR(iToDo==mcTaskUnLoad)
  ;
  ;synchron Entladen/Beladen
  ;
  iTaskId=1 iTaskIdNo=1
ELSE
  IF (iToDo==mcTaskPrep)
    ;
    ;ist WzW
    ;
    iTaskId=2 iTaskIdNo=1
  ELSE
    ;
    iTaskId=5 iTaskIdNo=2
    ;
    ;Ueberpruefung der Auftragsnummer
    ;
    IF (iToDo<>mcTaskAS_T0)
      iAlarmNo=AL_InvalidMissingInput sAlarmParam=<<sCycName<<" iTaskLocID="<<iTaskLocID SYG_RM[iSYGArea]=2.0
    ENDIF
  ENDIF
ENDIF

;-[]-5.0--Werkzeuge-
; SUBPAR 2
;-------------------
;
;-5.1--Werkzeuge-
; SpWz
;----------------
iOldTNo=$TC_MPP6[9998,mcLocSP] bPutM206=TRUE iSTNo=0 sOldTName="0" iOldSTNo=0
;
IF (iToDo==mcTaskPrep)
  ;
  IF (iOldTNo>0)
    bOldIsManTl=($A_MYMN[iOldTNo]==0)AND($A_MYMLN[iOldTNo]==0) sOldTName=$TC_TP2[iOldTNo] iOldSTNo=$TC_TP1[iOldTNo]
  ENDIF
  ;
  ;-5.2--Werkzeuge-
  ; NeuWz ermitteln
  ;----------------
  IF ($P_SUBPAR[2])
    ;
    IF ($P_SUBPAR[3])
      sTName=sToolName iSTNo=iToolDuploNo
    ELSE
      ;
      iTmp1=INDEX(sToolName,"/")
      IF (iTmp1>-1)AND(iTmp1<STRLEN(sToolName))
        sTmp=SUBSTR(sToolName,iTmp1+1)
        IF ISNUMBER(sTmp)
          ;
          ;WzW mit Angabe der SchwesterWzNummer
          ;Beispiel: TC("WZ1/2") - das Wz "WZ1" mit der DuploNummer 2 soll eingewechselt werden
          ;
          iSTNo=NUMBER(sTmp) sToolName=SUBSTR(sToolName,0,iTmp1)
        ELSE
          SETAL(AL_SyntaxError,sTmp)
        ENDIF
      ENDIF
      sTName=sToolName
    ENDIF
  ELSE
    ;
    ;Hauptlauf Synchronisierung danach erst $C.. gueltig
    ;
    STOPRE
    ;
    gbPrepAfterTC=FALSE gsPrepTName="" giPrepSTNo=0
    ;
    ;Aufrufparameter "M6" Zyklus
    IF ($C_T_PROG)OR($C_TS_PROG)
      ;
      ;a) TC im NC-Programm ohne (!) Parameter
      ;b) M6 im NC-Programm: M6 wird durch TC ersetzt (-> keine Parameter)
      ;
      IF ($C_T_PROG)
        ;
        ;T-Nummer, d.h. numerisch
        ;Bsp.: T4711 M6 in 1 (!!) NC-Satz
        ;Konvertierung INT->STRING !
        ;
        sTName= << $C_T
      ELSE
        ; Bsp.: T="4711" M6 in 1 (!!) NC-Satz
        sTName=$C_TS
      ENDIF
    ELSE
      ;
      ;-5.3--Neues Wz---------------
      ; Name noch nicht bekannt ->
      ; im Hauptlauf vorgewaehltes
      ; Wz wird als NeuWz betrachtet
      ;-----------------------------
      REPEAT
        ;
        ;Wz unbekannt
        ;
        ;wenn moeglich vorbereitetes Wz Einwechseln
        GETSELT(iNewTNo)
        ;
        IF (iNewTNo>0)
          ;
          ;entspricht: Tx (oder: T="x") M6 in 2 Saetzen, wobei x<>0 und Wz x verfuegbar
          ;
          sTName=$TC_TP2[iNewTNo]
        ELSE
          IF (iNewTNo==0)
            ;
            ;a) keine Vorbereitung programmiert (z.B. M6 ohne vorausgehendes T=xx) oder
            ;b) T0 M6 in 2 Saetzen programmiert
            ;
            sTName="0"
          ELSE
            ;
            ;Vorbereitung programmiert, aber Wz nicht verfuegbar/nicht vorhanden
            ;entspricht: Tx (oder: T="x") M6 in 2 Saetzen, wobei Wz x nicht (!) verfuegbar
            ;
            sTName=""
            IF (bPutM206)
              ;
              ;damit - falls Wz x nicht existiert - die NC einen Alarm absetzt
              ;Sofern vorheriges T=x gescheitert, wird lt. Masch.-Datum NC-Alarm erst mit M206/M6 ausgegeben
              ;
              M206
              ;bPutM206 wird spaeter noch gebraucht
            ENDIF
            ;
            ;Abbruch an WzV
            ToAckn(FALSE,iTaskId,iTaskIdNo,0,0,0,0,0,0,3)
            ;
            ;Wz nicht verfuegbar/nicht bekannt
            SETAL(AL_PleasePrepTool67, "T=?")
            M0
            ;
            STOPRE
            ;
          ENDIF
        ENDIF
      UNTIL (sTName<>"")
      ;
    ENDIF
  ENDIF
  ;
  IF (sTName=="")
    sTName="0"
  ENDIF
  ;
  bIsT0=(sTName=="0") sSelTName="0" iSelSTNo=0 sPrepTName="0" iPrepSTNo=0 iPrepTNo=giJobTNo
  ;
  ;-5.4--Werkzeuge-
  ; SatzSuchlauf...
  ; Vorwahl NeuWz
  ;----------------
  IF (bSearchSim)
    ;
    ;Hauptlauf Synchronisierung, Istwert fuer Richtungslogik
    ;
    rActZPos=$AA_IM[mcAxZ] SYG_BM[iSYG]=FALSE gsPrepTName=""
    ;
    IF (bIsT0)
      ;
      ;T0 aktivieren (T="0" wird nicht weitergegeben)
      ;
      T0
      GOTOF SEARCH_SIM_NEXT
    ENDIF
    ;
    LOOP
      ;
      ;Im SatzVorlauf... warten bis Abbruch oder gueltiges Wz
      ;
      iNewTNo=GETT(sTName)
      IF (iNewTNo>0)
        ;
        ;Vorbereitung ausloesen
        ;
        T=sTName
        ;
        STOPRE
        ;
        GETSELT(iNewTNo)
        ;
        ;Wz verfuegbar -> Weiter
        ;
        IF (iNewTNo>0) GOTOF SEARCH_SIM_NEXT
        ;
      ENDIF
      ;
      ;Wz nicht verfuegbar/nicht gefunden obwohl neues Wz spezifiziert wurde
      SETAL(AL_PleasePrepTool67, sTName)
      M0
      STOPRE
      ;
    ENDLOOP
    ;
  ENDIF
  ;
  ;-5.5--Werkzeuge-----------
  ; Momentan vorgewaehltes Wz
  ; >0 -> gueltig
  ; =0 -> T0 / nicht gefunden
  ; <0 -> ungueltig
  ;--------------------------
  ;
  IF (iPrepTNo>0)
    sPrepTName=$TC_TP2[iPrepTNo] iPrepSTNo=$TC_TP1[iPrepTNo]
  ENDIF
  ;
  GETSELT(iSelTNo)
  IF (iSelTNo>0)
    sSelTName=$TC_TP2[iSelTNo] iSelSTNo=$TC_TP1[iSelTNo]
  ENDIF
  ;
  ;benoetigtes NeuWz
  ;
  IF (bIsT0)
    ;
    iNewTNo=0 bNoRealTC=(iOldTNo==0)
    IF (bNoRealTC)AND(iSelTNo==0)AND(((bMagIsMiksch)AND(((giTNoDg2>0)AND(gbDG2MagSide))OR((giTNoDg1>0)AND(NOT gbDG2MagSide))))OR((gbWithHG)AND(giTNoHg>0)))
      ;
      ;T0, Sp ist leer, das alte SpWz befindet sich noch im DG/HG
      ;
      ;T0 liefert keinen Aenderungsstrobe mehr -> gezielt DG/HG leerfahren (im Rahmen eines Vorbereitungsauftrages)
      iToDo=mcTask_Displace
    ENDIF
  ELSE
    ;
    IF (iSTNo>0)
      iNewTNo=GETT(sTName,iSTNo)
    ELSE
      iNewTNo=GETT(sTName) iOldSTNo=0 iSelSTNo=0 iPrepSTNo=0
    ENDIF
    ;
    IF (iNewTNo>0)
      ;
      ;Das gesuchte oder ein Wz aus der gesuchten Familie wurde gefunden
      ;
      ;Es wurde nur ein Wz ohne Magazinplatzzuordnung gefunden -> HandWz
      bNewIsManTl=($A_MYMN[iNewTNo]==0)AND($A_MYMLN[iNewTNo]==0)
      ;
      IF (iOldTNo>0)
        ;
        ;Das SpWz ist das geforderte Wz, freigegeben, nicht gesperrt -> kein WzW notwendig
        bNoRealTC=(sTName==sOldTName)AND(iSTNo==iOldSTNo)AND(($TC_TP8[iOldTNo] B_AND 'B110')=='B010')
        ;
        ;Es wird ein WzW erwartet -> Vorstart der Achsen
        bExpectChange=(NOT bNoRealTC)AND(NOT bOldIsManTl)AND(NOT bNewIsManTl)
      ENDIF
    ENDIF
  ENDIF
  ;
  ;Erkennung NeuWz ist SonderWz
  IF (iNewTNo>0)AND((gbWithMillHead)OR(gbWithRecHead)OR(gbWithFacingHead))
    ;
    IF (gbTMIsHHD)
      iNewTlSpecType=RTOI($TC_TPC21[iNewTNo])
    ELSE
      iNewTlSpecType=RTOI($TC_TPC11[iNewTNo])
    ENDIF
    ;
    ;Im Vorbeifahren werden das SpWzoder die Spannkonen eines Fraeskopfes gereinigt.
    ;Die Reinigungseinrichtung befindet sich hinter der WzWTuer.
    ;
    bCleanSp=(iNewTlSpecType==mcSpecTypeBENZMillHead)AND(gbWithMillHead)AND(grCleanTlFeed>0)
    ;
    IF (iNewTlSpecType==mcSpecTypeWhRecessingHead)AND(gbWithRecHead)
      ;
      ;Kein verkuerzter WzW
      bReqPosAfterTC=FALSE bPosAfterTC=FALSE
    ENDIF
  ENDIF
  ;
  IF (NOT bNoRealTC)AND((sTName<>sSelTName)OR(iSTNo<>iSelSTNo))
    ;
    ;Gefordertes Wz noch nicht in Spindel und eventuell noch keine, eine laufende oder eine falsche Vorbereitung
    ;
    bEnabled=TRUE
    ;
    IF (gbPrepAfterTC)
      ;
      IF (sTName==gsPrepTName)AND(iSTNo==giPrepSTNo)
        ;
        ;bei der letzten Vorbereitung wurde im PREPARE oder TCWP das richtige Wz angefordert
        ; -> keine neue Vorbereitung mehr aber Verlaengerung der min. Vorbereitungszeit
        ;Die Reaktion auf eine falsche Vorbereitung erfolgt eventuell spaeter.
        bEnabled=FALSE gbGetToTime=FALSE gbWaitPrepare=FALSE giActPrepTime=-1 rPrepTimeMin=-1
      ENDIF
    ENDIF
    ;
    IF (gbPrepActiv)AND(bEnabled)
      ;
      ;Vorbereitung laeuft
      ;
      IF (sPrepTName<>sTName)OR(iPrepSTNo<>iSTNo)
        ;
        ;Falsche Vorbereitung
        ;
        ;Verlaengerung der min. Vorbereitungszeit
        iErrCount=0 rPrepTimeMin=-1
        WHILE (NOT gbPrepDone)
          G4 F=rWaitShort
          iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=5.5
          IF (iErrCount>=iErrTimeShort)
            iAlarmNo=AL_WaitFor sAlarmParam="gbPrepDone"
            GOTOF HandleAlarm
          ENDIF
        ENDWHILE
        ;
        gbPrepReset=TRUE iErrCount=0 bEnabled=TRUE
        ;
        WHILE (gbPrepActiv)
          G4 F=rWaitShort
          iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=5.5
          IF (iErrCount>=iErrTimeShort)
            iAlarmNo=AL_WaitFor sAlarmParam="gbPrepActiv"
            GOTOF HandleAlarm
          ENDIF
        ENDWHILE
        ;
        ;falsche Vorbereitung beendet -> neue Vorbereitung freigeben
      ELSE
        ;
        ;Richtige Vorbereitung
        ;
        IF (NOT gbPrepDone)
          ;
          ;Vorbereitung noch nicht beendet -> Verlaengerung der min. Vorbereitungszeit
          rPrepTimeMin=-1
        ENDIF
        ;
        ;keine neue Vorbereitung mehr
        bEnabled=FALSE
      ENDIF
    ENDIF
    ;
    IF (bEnabled)
      ;
      ;Warten auf Hauptlauf, damit IDS=1 vor dem naechstem Hauptsatz bearbeitet wird und die SYG's gueltig sind
      STOPRE
      ;
      ;Seit dem letzten TC wurde kein T.. erkannt oder es wurde eine falsches T.. erkannt -> neue Vorbereitung
      bTmp1=OUT_PrepareActive iPrepTNo=SYG_IM[iSYG+10] bEnabled=(NOT SYG_BM[iSYG])
      IF (iPrepTNo>0)
        sPrepTName=$TC_TP2[iPrepTNo] iPrepSTNo=$TC_TP1[iPrepTNo] bEnabled=(bEnabled)OR(sPrepTName<>sTName)OR((giPrepSTNo<>iSTNo)AND(iSTNo>0))
      ENDIF
      ;
      IF ((bIsT0)OR(bTmp1))AND(bEnabled)AND(bPrepBeforeTCPosX)
        ;
        ;Neue Vorbereitung oder Vorbereitung laeuft -> Verlaengerung der min. Vorbereitungszeit
        rPrepTimeMin=-1
      ENDIF
      ;
      IF (bEnabled)
        ;
        SYG_BM[iSYG]=FALSE SYG_BM[iSYG+1]=FALSE gbWaitPrepare=FALSE
        ;
        ;Neue Vorbereitung anfordern
        IF (bIsT0)
          T0
        ELSE
          IF (iSTNo>0)
            TCA(sTName,iSTNo)
          ELSE
            T=sTName
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  ;
  gsPrepTName="" giPrepSTNo=0
ELSE
  ;
  ;-6.0--Werkzeuge------
  ; Asynchrone Auftraege
  ; keine Auswertung
  ; im Satzvorlauf
  ;---------------------
  ;
  IF (bSearchSim) GOTOF SEARCH_SIM_NEXT
  ;
  IF ($P_SUBPAR[2])AND($P_SUBPAR[3])
    ;
    ;-6.1--Werkzeuge----------------------------
    ; Auftraege: SUBPAR 2..3
    ; - BELADEN/ENTLADEN ueber Beladestelle Hand
    ; - Spindel asynchron leerfahren
    ;-------------------------------------------
    IF (iToDo==mcTaskUnload)
      ;
      ;Wz aus(ueber) SP -> Beladestelle_Hand
      sTName=sToolName iDuploNo=iToolDuploNo
      ;
      IF (sTName=="")OR(sTName=="0")
        ;Falsche Parametrierung
        iAlarmNo=AL_InvalidMissingInput sAlarmParam="sTName="<<sTName SYG_RM[iSYGArea]=6.1
        GOTOF HandleAlarm
      ENDIF
      ;
      IF (iDuploNo<=0)
        ;Falsche Parametrierung
        iAlarmNo=AL_InvalidMissingInput sAlarmParam="iDuploNo="<<iDuploNo SYG_RM[iSYGArea]=6.1
        GOTOF HandleAlarm
      ENDIF
    ENDIF
    ;
    IF (iToDo==mcTaskLoad)OR(iToDo==mcTaskAS_T0)
      ;BELADEN (SpindelWz ins Magazin) oder Async. Spindel-Leerfahren
      sTName="0" iDuploNo=0 bIsT0=TRUE
    ENDIF
  ELSE
    iAlarmNo=AL_InvalidMissingInput sAlarmParam=""
    GOTOF HandleAlarm
  ENDIF
ENDIF

;-[MTC,WM286]-8.0--Werkzeuge-
; Ziel-/Quellplatz
;----------------------------
IF (bMagIsMiksch)
  ; SP->DG->MAG (Miksch Kette)
  iSpUnLoadMag=9998 iSpUnLoadLoc=mcLocDG2 iSpLoadMag=9998 iSpLoadLoc=mcLocDG1
ELSE
  IF (gbWithHG)
    ; SP->DG->HG->MAG (mit HG)
    iSpUnLoadMag=9998 iSpUnLoadLoc=mcLocHG iSpLoadMag=9998 iSpLoadLoc=mcLocHG
  ENDIF
ENDIF
;-[]-

;===============
SEARCH_SIM_NEXT:
;===============
;
;-[]-10.0--CMD-
; SUBPAR 4..7
;--------------
;
;Decoderauswertung nur bei Werkzeugwechsel
;
IF (iToDo<>mcTaskPrep) GOTOF PARA_END
;
IF ($P_SUBPAR[4])
  ;
  sCode=TOUPPER(sNameOfAxis1)
  ;
  ;-10.2--CMD---
  ; Einzeln 4..5
  ;-------------
  IF ($P_SUBPAR[5])
    ;
    IF (sCode=="Z")
      bZAxis=TRUE rProgZPos=rPOSOfAxis1
      GOTOF SUBPAR_6_TO_7
    ENDIF
    ;
    IF (sCode=="B")
      bBAxis=TRUE rProgBPOS=rPOSOfAxis1
      GOTOF SUBPAR_6_TO_7
    ENDIF
    ;
  ENDIF
  ;
  ;-10.2--CMD-------
  ; Kommandostring 4
  ;-----------------
  iCount=0 iCodeLastPos=(STRLEN(sCode)-1)
  WHILE (iCount<=iCodeLastPos)

    iPos=iCount iCmdNo=0 rNo=0 bArgIsString=FALSE sAux=SUBSTR(sCode,iCount,1)

    IF sAux==" "
      iCount=iCount+1
      GOTOF NextCodeCheck
    ENDIF

    IF (sAux[0]<65)OR(sAux[0]>90) GOTOF Error
    GOTOF "_Cx"<<sAux

    ;====
    _CxB:
    ;====
    iCmDNo=5
    IF SUBSTR(sCode,iCount+1,1)=="="
      iCount=iCount+1 sTmp=SUBSTR(sCode,iCount,4)
      IF (iCodeLastPos>=iCount+3)
        IF sTmp=="=DC("
          iCount=iCount+3
          GOTOF ContCxB
        ENDIF
        IF sTmp=="=IC("
          sModeB="IC" iCount=iCount+3
          GOTOF ContCxB
        ENDIF
        IF sTmp=="=AC("
          sModeB="AC" iCount=iCount+3
          GOTOF ContCxB
        ENDIF
      ENDIF
      IF (iCodeLastPos>=iCount+4)
        sTmp=SUBSTR(sCode,iCount,5)
        IF sTmp=="=ACP("
          sModeB="ACP" iCount=iCount+4
          GOTOF ContCxB
        ENDIF
        IF sTmp=="=ACN("
          sModeB="ACN" iCount=iCount+4
          GOTOF ContCxB
        ENDIF
      ENDIF
      iCount=iCount-1
    ENDIF
    ;
    ;=======
    ContCxB:
    ;=======
    ;
    IF (bZAxis)AND(NOT bG153Last)AND(iGG8>0)
      iAlarmNo=AL_CombNotAllowed sAlarmParam="G54ff"<<scPunkte<<" + Z... (G153)" SYG_RM[iSYGArea]=10.2
      GOTOF HandleAlarm
    ENDIF
    ;
    IF ($P_SUBPAR[5])
      ;
      IF (iCount==iCodeLastPos)
        bBAxis=TRUE rProgBPos=rPosOfAxis1 iCmdNo=0
      ELSE
        iAlarmNo=AL_SyntaxError sAlarmParam=sCode<<","<<rPosOfAxis1 SYG_RM[iSYGArea]=10.2
        GOTOF HandleAlarm
      ENDIF
    ENDIF
    GOTOF NextCode

    ;====
    _CxD:
    ;====
    iCmDNo=3
    GOTOF NextCode

    ;====
    _CxE:
    ;====
    IF (iCodeLastPos>=iCount+6)
      IF SUBSTR(sCode,iCount,7)=="ENMAXTL"
        bEnMaxTlLen=TRUE iCount=iCount+6
        GOTOF NextCode
      ENDIF
    ENDIF
    GOTOF Error

    ;====
    _CxM:
    ;====
    IF (iCodeLastPos>=iCount+5)
      IF SUBSTR(sCode,iCount,4)=="MOVE"
        ;
        IF (bMove) GOTOF MoveError
        ;
        bMove=TRUE iCount=iCount+4
        ;
        IF SUBSTR(sCode,iCount,1)=="_"
          iCount=iCount+1
        ENDIF
        ;
        IF (iCodeLastPos>=iCount+4)
          sTmp=SUBSTR(sCode,iCount,5)
          IF sTmp=="X_Z_B"
            ;erlaubt Z und/oder B
            bMoveX_Z_B=TRUE sMove="X_Z_B" iCount=iCount+4
            GOTOF NextCode
          ENDIF
          IF sTmp=="Z_X_B"
            ;erlaubt Z und/oder erlaubt B
            bMoveZ_X_B=TRUE sMove="Z_X_B" iCount=iCount+4
            GOTOF NextCode
          ENDIF
        ENDIF
        ;
        IF (iCodeLastPos>=iCount+3)
          sTmp=SUBSTR(sCode,iCount,4)
          IF sTmp=="X_ZB"
            ; erlaubt Z und/oder B
            bMoveX_ZB=TRUE sMove="X_ZB" iCount=iCount+3
            GOTOF NextCode
          ENDIF
          IF sTmp=="XZ_B"
            ; erlaubt Z und erwartet B
            bMoveXZ_B=TRUE sMove="XZ_B" iCount=iCount+3
            GOTOF NextCode
          ENDIF
          IF sTmp=="Z_XB"
            ; erlaubt Z und/oder erlaubt B
            bMoveZ_XB=TRUE sMove="Z_XB" iCount=iCount+3
            GOTOF NextCode
          ENDIF
        ENDIF
        ;
        IF (iCodeLastPos>=iCount+2)
          sTmp=SUBSTR(sCode,iCount,3)
          IF sTmp=="XZB"
            ; erlaubt Z und/oder B
            bMoveXZB=TRUE sMove="XZB" iCount=iCount+2
            GOTOF NextCode
          ENDIF
          IF sTmp=="X_B"
            ; kein Z, erwartet B
            bMoveX_B=TRUE sMove="X_B" iCount=iCount+2
            GOTOF NextCode
          ENDIF
          IF sTmp=="X_Z"
            ; erwartet Z, kein B
            bMoveX_Z=TRUE sMove="X_Z" iCount=iCount+2
            GOTOF NextCode
          ENDIF
          IF sTmp=="APC"
            ; wie Z_XB
            bMoveAPC=TRUE bMoveZ_XB=TRUE sMove="Z_XB" bZAxis=TRUE rProgZPos=grPalLoadPosZ bBAxis=TRUE rProgBPos=grPalLoadPosB iCount=iCount+2
            GOTOF NextCode
          ENDIF
        ENDIF
        ;
        IF (iCodeLastPos>=iCount+1)
          IF SUBSTR(sCode,iCount,2)=="XB"
            ; kein Z, erwartet B
            bMoveXB=TRUE sMove="XB" iCount=iCount+1
            GOTOF NextCode
          ENDIF
        ENDIF
        ;
        IF SUBSTR(sCode,iCount,1)=="X"
          ; kein Z u. B
          bMoveX=TRUE sMove="X"
          GOTOF NextCode
        ENDIF
        ;
        iAlarmNo=Al_NoSupport sAlarmParam=SUBSTR(sCode,iCount,10) SYG_RM[iSYGArea]=10.2
        GOTOF HandleAlarm
      ENDIF
    ENDIF
    iCmDNo=1
    GOTOF NextCode

    ;====
    _CxG:
    ;====
    iCmDNo=2
    GOTOF NextCode

    ;====
    _CxS:
    ;====
    iCmDNo=10
    GOTOF NextCode

    ;====
    _CxT:
    ;====
    IF (iCodeLastPos>=iCount+3)
      IF SUBSTR(sCode,iCount,4)=="TCWP"
        IF (sWPType<>"")
          iAlarmNo=AL_CombNotAllowed sAlarmParam=sWPType<<" + TCWP" SYG_RM[iSYGArea]=10.2
          GOTOF HandleAlarm
        ELSE
          IF (bRelPosAfterTC)
            sWPType="TCWP" bWaitZB=FALSE bReqPosAfterTC=TRUE iCount=iCount+3
            GOTOF NextCode
          ELSE
            iAlarmNo=Al_NoSupport sAlarmParam="TCWP" SYG_RM[iSYGArea]=10.2
            GOTOF HandleAlarm
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    GOTOF Error

    ;====
    _CxW:
    ;====
    IF (iCodeLastPos>=iCount+1)
      IF SUBSTR(sCode,iCount,2)=="WP"
        IF (sWPType<>"")
          iAlarmNo=AL_CombNotAllowed sAlarmParam=sWPType<<" + TCWP" SYG_RM[iSYGArea]=10.2
          GOTOF HandleAlarm
        ELSE
          IF (bRelPosAfterTC)
            sWPType="WP" bWaitZB=TRUE bReqPosAfterTC=TRUE iCount=iCount+1
            GOTOF NextCode
          ELSE
            iAlarmNo=Al_NoSupport sAlarmParam="WP" SYG_RM[iSYGArea]=10.2
            GOTOF HandleAlarm
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    ;
    IF (iCodeLastPos>=iCount+3)
      IF SUBSTR(sCode,iCount,4)=="WAIT"
        iCount=iCount+4
        ;
        IF SUBSTR(sCode,iCount,1)=="_"
          iCount=iCount+1
        ENDIF
        ;
        IF (iCodeLastPos>=iCount+2)
          IF SUBSTR(sCode,iCount,3)=="APC"
            bWaitAPC=TRUE iCount=iCount+2
            GOTOF NextCode
          ENDIF
          IF (iCodeLastPos>=iCount+3)
            IF SUBSTR(sCode,iCount,4)=="COOL"
              bWaitDoorCoolant=TRUE iCount=iCount+3
              GOTOF NextCode
            ENDIF
            IF (iCodeLastPos>=iCount+4)
              IF SUBSTR(sCode,iCount,5)=="CHECK"
                gbToCheckAtTC=TRUE iCount=iCount+4
                GOTOF NextCode
              ENDIF
            ENDIF
            IF (iCodeLastPos>=iCount+8)
              IF SUBSTR(sCode,iCount,9)=="PREVCHECK"
                bWaitPrevCheck=TRUE iCount=iCount+8
                GOTOF NextCode
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ELSE
        IF (iCodeLastPos>=iCount+7)
          IF SUBSTR(sCode,iCount,8)=="WORKSTEP"
            iCount=iCount+7 iTmp=iCount bTmp1=FALSE bTmp2=FALSE
            ;
            WHILE (iCodeLastPos>iTmp)AND(NOT bTmp1)
              iTmp=(iTmp+1) bTmp1=(SUBSTR(sCode,iTmp,1)<>" ") bTmp2=(SUBSTR(sCode,iTmp,1)=="=")
            ENDWHILE
            ;
            IF ((bTmp1)AND(NOT bTmp2))OR(iCount==iCodeLastPos)
              IF (ISNUMBER(sTName))
                iWorkStep=NUMBER(sTName)
                GOTOF NextCode
              ELSE
                iAlarmNo=Al_CombNotAllowed sAlarmParam="WORKSTEP="<<sTName
                GOTOF HandleAlarm
              ENDIF
            ENDIF
            iCmdNo=50
            GOTOF NextCode
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    GOTOF Error

    ;====
    _CxZ:
    ;====
    IF (NOT bG153Last) AND (iGG8>0)
      iAlarmNo=AL_CombNotAllowed sAlarmParam="G54ff + Z..." SYG_RM[iSYGArea]=10.2
      GOTOF HandleAlarm
    ENDIF
    IF ($P_SUBPAR[5])
      IF (iCount==iCodeLastPos)
        bZAxis=TRUE rProgZPos=rPosOfAxis1
        GOTOB NextCode
      ELSE
        iAlarmNo=AL_SyntaxError sAlarmParam=sCode<<","<<rPosOfAxis1 SYG_RM[iSYGArea]=10.2
        GOTOF HandleAlarm
      ENDIF
    ELSE
      iCmDNo=8
      GOTOF NextCode
    ENDIF

    ;====
    _CxA:
    ;B
    _CxC:
    ;D
    ;E
    _CxF:
    ;G
    _CxH:
    _CxI:
    _CxJ:
    _CxK:
    _CxL:
    ;M
    _CxN:
    _CxO:
    _CxP:
    _CxQ:
    _CxR:
    ;S
    ;T
    _CxU:
    _CxV:
    ;W
    _CxX:
    _CxY:
    ;Z
    ;====
    GOTOF Error

    ;========
    NextCode:
    ;========
    iCount=iCount+1
    IF (iCount>iCodeLastPos)OR(iCmdNo==0) GOTOF NextCodeCheck
    ;
    iPos=iCount iSep1=INDEX(SUBSTR(sCode,iCount)," ")
    ;
    IF (iSep1==-1)
      sArg=SUBSTR(sCode,iCount,iCodeLastPos-iCount+1) iCount=(iCodeLastPos+1)
    ELSE
      ;
      IF (iCount==iCodeLastPos)OR(iSep1==0) GOTOF Error
      ;
      sArg=SUBSTR(sCode,iCount,iSep1) iCount=(iCount+iSep1+1)
    ENDIF
    ;
    IF (SUBSTR(sArg,0,1)=="=")
      ;
      IF (STRLEN(sArg)<2) GOTOF Error
      ;
      sArg=SUBSTR(sArg,1) iTmp=STRLEN(sArg)-1
      ;
      IF (bArgIsString)
        ;
        IF (SUBSTR(sArg,0,1)=="<")AND(SUBSTR(sArg,iTmp,1)==">")
          IF (iTmp>1)
            sArg=SUBSTR(sArg,1,iTmp-1)
          ELSE
            sArg=""
          ENDIF
        ELSE
          ;
          IF ISVAR(sArg)
            IF (STRINGIS(sArg)==211) GOTOF VarError
            EXECSTRING("sArg=<<"<<sArg)
          ENDIF
        ENDIF
      ELSE
        ;
        IF (NOT ISNUMBER(sArg))
          ;
          IF (NOT ISVAR(sArg)) GOTOF Error
          IF (STRINGIS(sArg)==211) GOTOF VarError
          EXECSTRING("sArg=<<"<<sArg)
          IF (NOT ISNUMBER(sArg)) GOTOF Error
        ENDIF
        rNo=NUMBER(sArg) iNo=RTOI(rNo)
      ENDIF
    ELSE
      ;
      IF (NOT ISNUMBER(sArg))OR(bArgIsString) GOTOF Error
      rNo=NUMBER(sArg) iNo=RTOI(rNo)
    ENDIF

    ;aktuellen CMDCODE abschliessen
    GOTOF "_Cx"<<iCmdNo

    ;====
    _Cx1:
    ;====
    IF (iNo==10)OR(iNo==18)OR(iNo==11)
      iClpB=iNo bReqM11=(iClpB==11)
      GOTOF NextCodeCheck
    ENDIF
    iAlarmNo=Al_NoSupport sAlarmParam="M"<<iNo SYG_RM[iSYGArea]=10.2
    GOTOF HandleAlarm

    ;====
    _Cx2:
    ;====
    iZONo=iNo
    IF (iNo>=54)AND(iNo<=57)
      iGG8=iNo-52
      GOTOF NextCodeCheck
    ELSE
      IF (iNo>=505)AND(iNo<=599)
        iGG8=iNo-499
        GOTOF NextCodeCheck
      ELSE
        IF (iNo==500)
          iGG8=1
          GOTOF NextCodeCheck
        ENDIF
      ENDIF
    ENDIF
    IF (iNo==153)
      bG153Last=TRUE
      GOTOF NextCodeCheck
    ENDIF
    IF (iNo==91)
      bG91Last=TRUE
      GOTOF NextCodeCheck
    ENDIF
    iAlarmNo=Al_NoSupport sAlarmParam="G"<<iNo SYG_RM[iSYGArea]=10.2
    GOTOF HandleAlarm

    ;====
    _Cx3:
    ;====
    iDNo=iNo
    GOTOF NextCodeCheck

    ;====
    _Cx5:
    ;====
    bBAxis=TRUE rProgBPos=rNo
    GOTOF NextCodeCheck

    ;====
    _Cx8:
    ;====
    bZAxis=TRUE rProgZPos=rNo
    GOTOF NextCodeCheck

    ;====
    _Cx10:
    ;====
    IF (rSpeed>0)
      iAlarmNo=Al_CombNotAllowed sAlarmParam="S"<<rSpeed<<" + S"<<rNo
      GOTOF HandleAlarm
    ENDIF
    rSpeed=rNo
    GOTOF NextCodeCheck

    ;=====
    _Cx50:
    ;=====
    iWorkStep=iNo
    GOTOF NextCodeCheck

    ;=====
    Error:
    ;=====
    iAlarmNo=AL_SyntaxError sAlarmParam=scPunkte<<SUBSTR(sCode,MAXVAL(iPos-10,0),20)<<scPunkte SYG_RM[iSYGArea]=10.2
    GOTOF HandleAlarm

    ;=========
    MoveError:
    ;=========
    iAlarmNo=AL_CombNotAllowed sAlarmParam="2 * MOVE_..." SYG_RM[iSYGArea]=10.2
    GOTOF HandleAlarm

    ;========
    VarError:
    ;========
    iAlarmNo=Al_NotAvailable sAlarmParam="LUD "<<sArg SYG_RM[iSYGArea]=10.2
    GOTOF HandleAlarm

    ;=============
    NextCodeCheck:
    ;=============
  ENDWHILE
  ;
  IF (iGG8>0)AND(bBAxis)AND(NOT bMoveAPC)
    ;
    ;Zurueckrechnen auf MKS (mit Grob und Feinverschiebung)
    rProgBPos=rProgBPos+$P_UIFR[iGG8-1,mcAxB,TR]+$P_UIFR[iGG8-1,mcAxB,FI]
    IF (rProgBPos<0)
      rProgBPos=rProgBPos+360
    ELSE
      IF (rProgBPos>=360)
        rProgBPos=rProgBPos-360
      ENDIF
    ENDIF
  ENDIF
ENDIF
;
;-10.3--CMD--
; SUBPAR 6..7
;------------
;
;=============
SUBPAR_6_TO_7:
;=============
;
IF ($P_SUBPAR[6])
  sCode=TOUPPER(sNameOfAxis2)
  IF (sCode=="Z")
    IF (bZAxis)
      iAlarmNo=AL_NotAvailable sAlarmParam="2 * Z..." SYG_RM[iSYGArea]=10.3
      GOTOF HandleAlarm
    ENDIF
    IF ($P_SUBPAR[7])
      bZAxis=TRUE rProgZPos=rPOSOfAxis2
      GOTOF SUBPAR_4_TO_7_END
    ENDIF
  ENDIF
  IF (sCode=="B")
    IF (bBAxis)
      iAlarmNo=AL_NotAvailable sAlarmParam="2 * B..." SYG_RM[iSYGArea]=10.3
      GOTOF HandleAlarm
    ENDIF
    IF ($P_SUBPAR[7])
      bBAxis=TRUE rProgBPOS=rPOSOfAxis2
      GOTOF SUBPAR_4_TO_7_END
    ENDIF
  ENDIF
  ;Wegangabe der Achse fehlt
  iAlarmNo=AL_PosMissing sAlarmParam=sNameOfAxis<<"=???" SYG_RM[iSYGArea]=10.3
  GOTOF HandleAlarm
ENDIF

;=================
SUBPAR_4_TO_7_END:
;=================
;
;-11.0--CMD-------------------
; Pruefungen - Bewegungsprofil
;-----------------------------
sMove="MOVE_"<<sMove<<" ... "
IF ((bMoveXZ_B)OR(bMoveXB)OR(bMoveX_B))AND(NOT bBAxis)
  ;B-Achse nicht programmiert, unpassende Anfahrlogik
  iAlarmNo=Al_PosMissing sAlarmParam=sMove<<"B???" SYG_RM[iSYGArea]=11.0
  GOTOF HandleAlarm
ENDIF
IF ((bMoveX_Z)OR(bMoveX))AND(bBAxis)
  ;B-Achse programmiert, unpassende Anfahrlogik
  iAlarmNo=Al_CombNotAllowed sAlarmParam=sMove<<"B..." SYG_RM[iSYGArea]=11.0
  GOTOF HandleAlarm
ENDIF
IF (bMoveAPC)
  ;
  ;Palettenwechselposition Anfahren mit ...
  IF (iGG8>0)
    ;... NPV fuer B Achse
    iAlarmNo=Al_CombNotAllowed sAlarmParam=sMove<<"MOVE_APC + G54ff" SYG_RM[iSYGArea]=11.0
    GOTOF HandleAlarm
  ENDIF
  IF (bG91Last)
    ;... G91
    iAlarmNo=Al_CombNotAllowed sAlarmParam=sMove<<"MOVE_APC + G91" SYG_RM[iSYGArea]=11.0
    GOTOF HandleAlarm
  ENDIF
ENDIF
IF ((bMoveXB)OR(bMoveX_B)OR(bMoveX))AND(bZAxis)
  ;Z-Achse programmiert aber unpassende Anfahrlogik
  iAlarmNo=Al_CombNotAllowed sAlarmParam=sMove<<"Z..." SYG_RM[iSYGArea]=11.0
  GOTOF HandleAlarm
ENDIF
IF (NOT bZAxis)AND(bG91Last)
  ;G91 und kein Z Wert
  iAlarmNo=Al_PosMissing sAlarmParam="G91 Z??? " SYG_RM[iSYGArea]=11.0
  GOTOF HandleAlarm
ENDIF
IF (bG153Last)AND(bG91Last)
  ;G153/G91 gleichzeitig
  iAlarmNo=Al_CombNotAllowed sAlarmParam="G153 + G91" SYG_RM[iSYGArea]=11.0
  GOTOF HandleAlarm
ENDIF
;
;-11.1--CMD------------
; Verkuerzter WzW
; -> keine D-Nr erlaubt
;----------------------
IF (iDNo>-1)AND(bReqPosAfterTC)
  iAlarmNo=Al_CombNotAllowed sAlarmParam="TCWP + Dxyz" SYG_RM[iSYGArea]=11.1
  GOTOF HandleAlarm
ENDIF
;
;-11.2--CMD-------------
; - Normaler WzW
; - keine D programmiert
; -> D1 vorwaehlen
;-----------------------
IF (iDNo==-1)AND(NOT bReqPosAfterTC)
  iDNo=1
ENDIF
;
;========
PARA_END:
;========
;
;-[MTC]-12.0--WerkzeugLaenge-------
; Bei  ueberlangen Wz besteht eine
; Kollisionsgefahr mit der
; Vorrichtung. Freigabe nur mit
; - gbEnaMaxToolLen=TRUE (vor TC)
; - oder ENMAXTL
;--------------------------------
IF (bMonTcMaxToolLen)AND(iOldTNo>0)
  IF (rOldTlColLen>=grTcMaxToolLen)AND(NOT bEnMaxTlLen)
    ; Spindelwerkzeug hat Uebergroesse, keine Freigabe Werkzeugwechsel
    iAlarmNo=AL_SpTlOverSize sAlarmParam="" SYG_RM[iSYGArea]=12.0
    GOTOF HandleAlarm
  ENDIF
ENDIF

;-[]-13.0--SatzSuchlauf..-
;-------------------------
IF (bSearchSim) GOTOF SEARCH_SIM_END

;-[]-14.0--BBK-
; Kalibrieren
;--------------
IF ((bWaitPrevCheck)OR(gbToCheckAtTC))AND((grMeasOffset<grMinMeasOffset)OR(grMeasOffset>grMaxMeasOffset))AND(iOldTNo>0)
  ;Aufforderung zur Kalibrierung in Maske "Werkzeug vermessen"
  iAlarmNo=AL_TlMeasUnitNotCalibrated sAlarmParam="" SYG_RM[iSYGArea]=14.0
  GOTOF HandleAlarm
ENDIF

;-[]-20.0--Achsen-
;-----------------
; X --
rFeedX=$MA_MAX_AX_VELO[mcAxX] rMaxVeloX=rFeedX/60 rMaxAccelX=$MA_MAX_AX_ACCEL[mcAxX]*1000 rMaxJerkX=grTcJerkX*1000
rMaxTjX=rMaxAccelX/rMaxJerkX rMaxVjX=0.5*rMaxAccelX*rMaxAccelX/rMaxJerkX
; Y --
rFeedY=$MA_MAX_AX_VELO[mcAxY] rMaxVeloY=rFeedY/60 rMaxAccelY=$MA_MAX_AX_ACCEL[mcAxY]*1000 rMaxJerkY=grTCJerkY*1000
rMaxTjY=rMaxAccelY/rMaxJerkY rMaxVjY=0.5*rMaxAccelY*rMaxAccelY/rMaxJerkY rActJerkY=rMaxJerkY rPosWin=0
; Z --
rFeedZ=$MA_MAX_AX_VELO[mcAxZ]
; B --
IF (bBAxis)
  rFeedB=$MA_MAX_AX_VELO[mcAxB]*360
  ;
  ;Ueberwachungsfenster
  ;
  bBAxReq=TRUE rBPosMin1=rProgBPos-grBAxStopLimitFine rBPosMax1=rProgBPos
  rBPosMin2=rProgBPos rBPosMax2=rProgBPos+grBAxStopLimitFine
  IF (rBPosMin1<0)
    rBPosMin1=rBPosMin1+360.0 rBPosMax1=360.0 rBPosMin2=0
  ENDIF
  IF (rBPosMax2>360)
    rBPosMin2=0 rBPosMax2=rBPosMax2-360 rBPosMax1=360
  ENDIF
ENDIF
;
;-[DISK]-20.1--Achsen-
;---------------------
IF (bMagIsPickUpDisk)
  ; VT1
  rFeedV1=$MA_MAX_AX_VELO[mcAxV1]*360 rMagPlCount=$MA_INDEX_AX_DENOMINATOR[mcAxV1] rMagPlLastPos=$MA_MODULO_RANGE[mcAxV1]
  IF (rMagPlCount>0)
    rMagPlDist=rMagPlLastPos/rMagPlCount
  ELSE
    iAlarmNo=AL_NoSupport sAlarmParam="$MA_INDEX_AX_DENOMINATOR[mcAxV1]=0" SYG_RM[iSYGArea]=20.1
    GOTOF HandleAlarm
  ENDIF
  IF (rMagPlLastPos<=0)
    iAlarmNo=AL_NoSupport sAlarmParam="$MA_MODULO_RANGE[mcAxV1]=0" SYG_RM[iSYGArea]=20.1
    GOTOF HandleAlarm
  ENDIF
ENDIF
;
;-[WM286,WM307]-20.2--Achsen-
;----------------------------
; CT
IF (bDGIsNcAxis)
  rFeedDGRot=$MA_MAX_AX_VELO[mcAxDGRot]*360 rMaxVeloDG=rFeedDGRot/60 rMaxAccelDG=$MA_MAX_AX_ACCEL[mcAxDGRot]*360 rMaxJerkDG=grTCJerkDGRot*360
  rMaxTjDG=rMaxAccelDG/rMaxJerkDG rMaxVjDG=0.5*rMaxAccelDG*rMaxAccelDG/rMaxJerkDG rFeedEmptyDGRot=grFeedEmptyDGRot
ENDIF

;-[]-30.0--Spannen/Loesen-
;-------------------------
rSpUnClmpTime=grSpUnClmpTime rSpClmpTime=grSpClmpTime
;
;-[WM286,WM307]-30.1--Spannen/Loesen-
;------------------------------------
IF (bDGIsNcAxis)
  rHGClmpTime=grHGClmpTime rHGUnClmpTime=grHGUnClmpTime
ENDIF

;-[]-40.0--Positionen-
;---------------------
IF (gbSpecTlInSp)
  ;
  ;SpWz ist SonderWz-> Kein schnelles Wz -> nicht ins Magazin Fahren
  ;
  bOldTlFast=FALSE bRelSpPosX=FALSE
ENDIF

;-[MTC,DISK]-40.1--Positionen-
;-----------------------------
IF (bDGIsMTC)OR(bMagIsPickUpDisk)
  ;
  rPrePosX=grTCPrePosX rSpPosX=rPrePosX rCloseDoorX=grTCPrePosX rTCInPosFine=rc0x5mm rTCInPosCoarse=rc0x5mm rRelXByY=rc1x0mm
  ;
  IF (bMagIsPickUpDisk)AND(grHGClmpTimeC<=0)
    ;
    ;bei "vergessener" Angabe wuerde sonst zu frueh gespannt werden
    bRelPreClmp=FALSE
  ENDIF
ENDIF
;
;-[WM307]-40.2--Positionen-
;--------------------------
IF (bDGIsWM307)
  ;
  rPrePosX=grTCPrePosX rSpPosX=grTCPrePosX rCloseDoorX=grTCPrePosX rTCInPosFine=rc0x2mm rTCInPosCoarse=rc0x5mm rSafeCalcDG=1.2 rRelXByY=rc2x0mm
  ;
  ;Positionsfenster des DG, in dem das NeuWz angefordert werden darf
  rRelMagDGRot=grRelMagDGRot
ENDIF
;
;-[WM286]-40.3--Positionen-
;--------------------------
IF (bDGIsWM286)
  ;
  IF (iOldTNo==0)
    ;
    ;kein SpWz -> keine Kollision mit WzWTuer
    rPrePosX=grTcPosX
  ELSE
    ;
    ;mit SpWz -> Kollision mit WzWTuer
    rPrePosX=grTcPosX-grToMaxRad
  ENDIF
  rSpPosX=grTCPosX rCloseDoorX=grTcPosX-grToMaxRad rTCInPosFine=rc0x5mm rTCInPosCoarse=rc0x5mm rSafeCalcDG=1.05 rRelXByY=10*grInchMetr
ENDIF
;
;-[]-40.4--Positionen------
; Freigabeposition X-Achse,
; wenn Spindel gerichtet
;--------------------------
IF (bRelSpPosX)
  ;
  rSpPosX=grTCPosX-grTCRelSpDist
  IF (rSpPosX>=grTCPosX)OR(rSpPosX<rPrePosX)
    rSpPosX=rPrePosX bRelSpPosX=FALSE
  ENDIF
ENDIF
;
;-[]-40.5--Positionen--------
; Sp Freigabeposition X-Achse
; bei Verlassen des Magazins
;----------------------------
rRelSpExitX=rCloseDoorX
IF (bRelSpByX)
  ;
  rRelSpExitX=grTCPosX-grTCRelSpDist
  IF (rRelSpExitX>=grTCPosX)OR(rRelSpExitX<rCloseDoorX)
    rRelSpExitX=rCloseDoorX
  ENDIF
ENDIF

;-[]-41.0--Positionen-
;---------------------
rWaitPosX=rCloseDoorX
IF (bRelExitXY)
  ;
  ;grExitStartX = Y muss in Position sein
  ;grExitRadXY  = Radius der Kreisbahn auf der X,Y aus dem Magazin fahren koennen
  ;rRelXByY     = Freigabefenster Y fuer X im Bereich grExitStartX > X > rCloseDoorX
  ;
  bRelExitXY=(grExitRadXY>0)AND(grToMaxRad>0)AND(grExitDoorHeight>grToMaxRad)AND(grExitStartX>rCloseDoorX)
  ;
  IF (bRelExitXY)
    rRelXByY=grExitDoorHeight-grToMaxRad rWaitPosX=grExitStartX
  ENDIF
ENDIF
;
;-41.1--Positionen----
; Freigabe Kuehlmittel
;---------------------
IF (rMaxVeloX<2*rMaxVjX)
  rTmp=rMaxVeloX*SQRT(rMaxVeloX/rMaxJerkX)
ELSE
  rTmp=0.5*rMaxVeloX*(rMaxVeloX/rMaxAccelX+rMaxTjX)
ENDIF
rTcRelCoolX=rCloseDoorX+MINVAL(MINVAL(0.5*(grTcPosX-rCloseDoorX),rTmp),grTCCoolOn)

;-[]-50.0--Vorbereitung----------
; Vorbereitung intern angestossen
; -> Minimale Vorbereitungszeit
;--------------------------------
IF (rPrepTimeMin==-1)
  rPrepTimeMin=grTCPrepTimeMin+rcPrepIPOCount*rIPO
ENDIF

;-[]-60.0--SpWz-
; Gewicht
;---------------
bOldTurnDGFast=TRUE
IF (iOldTNo>0)AND(NOT bOldIsManTl)
  ;
  IF (gbTMIsHHD)
    ;
    rOldTlColLen=MAXVAL($TC_TPC11[iOldTNo],$TC_TPC16[iOldTNo]) rWOldTl=$TC_TPC3[iOldTNo] rOldTlJ=0
    IF (rWOldTl>1000)
      ;
      ;Kippmoment*1000 + Gewicht
      rOldTlJ=RTOI(rWOldTl/1000) rWOldTl=(rWOldTl MOD 1000)
    ENDIF
    rTmp1=$TC_TPC11[iOldTNo]*$TC_TPC12[iOldTNo]*$TC_TPC12[iOldTNo] 
    rTmp2=MAXVAL($TC_TPC16[iOldTNo]-$TC_TPC11[iOldTNo],0)*$TC_TPC17[iOldTNo]*$TC_TPC17[iOldTNo] rTmp3=rTmp1+rTmp2
    rJOldTl=0.5*rWOldTl*((rTmp1*$TC_TPC12[iOldTNo]*$TC_TPC12[iOldTNo])+(rTmp2*$TC_TPC17[iOldTNo]*$TC_TPC17[iOldTNo]))/(rTmp3*1000*1000)
    rTmp4=((0.5*$TC_TPC11[iOldTNo]*rTmp1)+((0.5*MAXVAL($TC_TPC16[iOldTNo]-$TC_TPC11[iOldTNo],0)+$TC_TPC11[iOldTNo])*rTmp2))/(1000*rTmp3)
  ELSE
    ;
    rOldTlColLen=$TC_TPC7[iOldTNo] rWOldTl=$TC_TPC4[iOldTNo] rOldTlJ=0
    IF (rWOldTl>1000)
      ;
      ;Kippmoment*1000 + Gewicht
      rOldTlJ=RTOI(rWOldTl/1000) rWOldTl=(rWOldTl MOD 1000)
    ENDIF
    rJOldTl=0.5*rWOldTl*$TC_TPC8[iOldTNo]*$TC_TPC8[iOldTNo]/(1000*1000) rTmp4=0.5*$TC_TPC7[iOldTNo]/1000
  ENDIF
  ;
  ;Fuer Span zu Span Zeitmessung
  IF (giSetHeavyTlDg==1)AND(rWOldTl<grMidTlDg)
    rWOldTl=grMidTlDg
  ELSE
    IF (giSetHeavyTlDg==2)AND(rWOldTl<grHeavyTlDg)
      rWOldTl=grHeavyTlDg
    ENDIF
  ENDIF
  ;
  IF (rWOldTl<=0.0)OR(rWOldTl>=grHeavyTlDg)OR(gbTCSlowMode)
    ;
    ;Gewicht unbekannt oder schweres Wz oder WzSchutz aktiv -> DG langsam Drehen
    bOldTurnDGFast=FALSE bOldTlFast=FALSE
  ENDIF
  ;
  IF (rWOldTl>grTlHolderWeight)
    ;
    ;Annahmen: Das Gewicht ist gleichverteilt ueber die WzLaenge
    ;Ueberlagerung von Gewicht und Traegheitskraft in X
    ;
    IF (rOldTlJ==0)
      ;
      IF (bRelMoveUnClmp)
        ;
        rOldTlJ=rTmp4*(rWOldTl-grTlHolderWeight)*SQRT((9810*9810)+(rMaxAccelX*rMaxAccelX))/1000
      ELSE
        rOldTlJ=rTmp4*(rWOldTl-grTlHolderWeight)*9.81
      ENDIF
    ENDIF
    ;
    IF (rOldTlJ>grTlTiltTorqueSp)
      bOldTlFast=FALSE
    ENDIF
  ENDIF
ENDIF

;-[]-80.0--Status-----------
; - Istwerte Lesen
; - Schrittzaehler
; - Loeszeit- und Spannzeit-
;   messung vorbesetzen
;---------------------------
rActZPos=$AA_IM[mcAxZ] rActYPos=$AA_IM[mcAxY] rActXPos=$AA_IM[mcAxX] rActBPos=$AA_IM[mcAxB] bDGInBasePos=(OUT_DGRotInBasePos) iClampStatus=$A_DBB[0] iFeedOVR=$A_DBB[76] bBAxUnclamped=(($A_DBB[71] B_AND 'H20')<>0) bAxBInPos=($AA_STAT[mcAxB]==4) iActGearStep=$AC_SGEAR[iSpNo] bReqLockSpTool=OUT_ReqLockSpTool bTlCheckOn=(($A_DBB[iSelBBK_DBB] B_AND iSelBBK_Mask)<>0) SYG_RM[iSYGArea]=80.0 iProgConfig=(mcDBB_ProgConfig)
bInPrSearch=((mcDBB_InProgEvent B_AND 'B100')<>0) bHoldBeforeTC=((IN_StopAtTc)OR(IN_ReqStopAtCycleEnd)OR(((IN_LoadFromMag)OR(IN_UnloadToMag)OR(OUT_LoadActiv))AND(NOT gbPrepActiv))) bRelPrep_Clmp_UnClmp=(SYG_IM[iSYG+3]==1) bTcNotFinished=((OUT_TcActive)OR(mcDBB_StepTC<>0)) bStatCha2=$A_DBB[47] SYG_IM[iSYG]=REP(0,2) SYG_RM[iSYG+2]=0 SYG_RM[iSYG+5]=REP(0,2) SYG_BM[iSYG+3]=REP(0,2) bProgCall=(OUT_SysPrgActive) bAPCInPos=(IN_APCInPos)
IF (gbSwivHeadExist)
  rActPosDiffHead=ABS($AA_IM[mcAxC]-grTCPosC)
ENDIF
IF (gbTiltHeadExist)
  rActPosDiffHead=ABS($AA_IM[mcAxA]-grTCPosA)
ENDIF
;
;-81.0--Pruefungen-----------------------
; Letzter WzW muss abgeschlossen sein
;------------------------------------
IF (bTCNotFinished)OR(rActXPos>rLimitPlusX)
  ;TC noch nicht abgeschlossen oder Achse steht unerlaubt im Magazinraum
  iAlarmNo=AL_TCNotFinished sAlarmParam="" SYG_RM[iSYGArea]=81.0
  GOTOF HandleAlarm
ENDIF
;
;-[]-81.1-Pruefungen-
; Klemmung SpWz
;--------------------
IF ((iClampStatus B_AND 'B11')==0)
  ;weder <gespannt mit Wz> noch <gespannt ohne Wz>
  iAlarmNo=AL_SpNotClamped sAlarmParam="" SYG_RM[iSYGArea]=81.1
  GOTOF HandleAlarm
ENDIF
IF (iOldTNo>0)
  IF ((iClampStatus B_AND 'B100')<>0)
    ;lt. WzV Wz in Spindel, aber <Spindel geloest>
    M_SpClampWithTool1
  ENDIF
  IF ((iClampStatus B_AND 'B10')<>0)
    ;lt. WzV Wz in Spindel, aber <Spindel gespannt ohne Werkzeug>
    iAlarmNo=AL_TInSpButSpClampedNoTool sAlarmParam="" SYG_RM[iSYGArea]=81.1
    GOTOF HandleAlarm
  ENDIF
  IF ((iClampStatus B_AND 'B1')==0)
    ;Sp nicht <gespannt mit Wz>
    iAlarmNo=AL_ClampSp sAlarmParam="" SYG_RM[iSYGArea]=81.1
    GOTOF HandleAlarm
  ENDIF
ENDIF
;
;-81.2-Pruefungen---------
; nur wenn WzW stattfindet
;-------------------------
IF (NOT bNoRealTC)
  ;
  IF (bWithHead)
    ;
    IF (MINVAL(rActPosDiffHead,ABS(360-rActPosDiffHead))>rc0x001Deg)
      ;Schwenkkopf nicht in WzWPosition
      iAlarmNo=AL_HeadNotTcPos sAlarmParam="" SYG_RM[iSYGArea]=81.2
      GOTOF HandleAlarm
    ENDIF
  ENDIF
  ;
  IF (gbWithDG)
    ;
    giTNoDG1=$TC_MPP6[9998,mcLocDG1] giTNoDG2=$TC_MPP6[9998,mcLocDG2]
    ;
    IF (bMagIsMiksch)
      ;
      IF (giTNoDG2<>0)AND(giTNoDG1<>0)
        ;DG1 und DG2 muessen leer sein
        iAlarmNo=AL_DGNotEmpty sAlarmParam="" SYG_RM[iSYGArea]=81.2
        GOTOF HandleAlarm
      ENDIF
    ELSE
      ;
      IF (NOT bDGInBasePos)
        ;DG nicht in WzWPosition
        iAlarmNo=AL_DGNotInBasePos sAlarmParam="" SYG_RM[iSYGArea]=81.2
        GOTOF HandleAlarm
      ENDIF
      ;
      IF (giTNoDG2<>0)OR(giTNoDG1<>0)
        ;DG1 und DG2 muessen leer sein
        iAlarmNo=AL_DGNotEmpty sAlarmParam="" SYG_RM[iSYGArea]=81.2
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  ENDIF
ENDIF

;-82.0--Status------
; Kanal 2
; - laeuft nicht
; - ist unterbrochen
;-------------------
IF (iStatCha2<>2)
  ;
  iErrCount=0 bActMsg=FALSE
  WHILE ($A_DBB[47]<>2)
    iErrCount=(iErrCount+1)
    IF (iErrCount>iErrTimeShort)
      MSG(MSG_WaitForSysProg2Run)
      bActMsg=TRUE
    ENDIF
    G4 F=rWaitShort
  ENDWHILE
  ;
  IF (bActMsg)
    MSG("")
  ENDIF
ENDIF

;-[]-90.0--BBK_1------
; Bohrerbruchkontrolle
;---------------------
;
IF (bTlCheckOn)AND(iToDo==mcTaskPrep)
  ;
  ;Pruefen ist angewaehlt
  ;
  IF (giToBreakCtrlState<>0)AND(bWaitPrevCheck)
    ;
    IF (giToNoProb>0)
      ;
      IF (NOT $P_TOOLEXIST[giToNoProb])
        ;
        ;-90.1--BBK_1------------
        ; Das zuletzt gepruefte Wz existiert nicht mehr -> Abbruch des Pruefens
        ;------------------------
        giToBreakCtrlState=0 grProbVal=0 gbPrevToBrokenInt=FALSE
      ELSE
        IF ($A_MYMN[giToNoProb]==0)OR($A_MYMLN[giToNoProb]==0)
          ;
          ;Wz zwar in Wz-Liste, aber (noch) keinem Magazin zugeordnet (= noch nicht beladen)
          giToBreakCtrlState=0 grProbVal=0 gbPrevToBrokenInt=FALSE
        ENDIF
      ENDIF
    ENDIF
    ;
    ;-90.2--BBK_1--------------
    ; Warten solange BBK laeuft
    ;--------------------------
    iErrCount=0 bEnabled=FALSE
    WHILE (giToBreakCtrlState<>0)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc])
      IF (iErrCount>iErrTimeShort)
        ;Meldung erst nach Wartezeit ausgeben
        MSG(MSG_ToBreakCtrlRunning)
        bEnabled=TRUE iErrCount=0
      ENDIF
    ENDWHILE
    ;
    IF (bEnabled)
      MSG("")
    ENDIF
  ENDIF
  ;
  IF (gbPrevToBrokenInt)AND(bWaitPrevCheck)AND(giToNoProb>0)
    ;
    IF ($TC_TP2[giToNoProb]<>sTName)OR(($TC_TP1[giToNoProb]<>iSTNo)AND(iSTNo>0))
      ;
      ;zu pruefendes Wz ist nicht neues Wz
      ;
      IF ((iProgConfig B_AND 'B100')==0)OR(gbErrMsgOnToCheck)
        ;
        ;-90.3--BBK_1-----
        ; Alarmausgabe bei Bohrerbruch -> Bedienerruf und Halt vor WzW
        ;-----------------
        SETAL(AL_PrevTlBrokenAsk67)
        bHoldBeforeTC=TRUE bHoldBeforeTC_BBK=TRUE
      ENDIF
    ELSE
      ;
      ;Neues Wz ist gebrochen (gesperrt), wird spaeter erkannt und ein SchwesterWz angefordert
      ;
    ENDIF
  ENDIF
ELSE
  ;
  ;-90.4--BBK_1-------------------
  ; Mech. Bohrerbrucheinrichtung
  ; im Magazinraum nicht vorhanden
  ; oder abgewaehlt -> GndSt
  ;-------------------------------
  giToBreakCtrlState=0 giToNoProb=0 gbPrevToBrokenInt=FALSE gbLastToBroken=FALSE
ENDIF
;Fuer Kundenprogramm bereitstellen
gbPrevToBroken=gbPrevToBrokenInt

;-[]-100.0--Vorbereitungen-
; Halt vor WzW
;--------------------------
IF (bHoldBeforeTC)
  bExpectChange=FALSE bRelSpPosX=FALSE bRelExitXY=FALSE rPrePosX=grTCPrePosX rCloseDoorX=rPrePosX rSpPosX=rPrePosX rWaitPosX=rPrePosX
ENDIF
;
giSyncTC=0 giTlInSp=-1 giNextTlInSp=-1
;
;-100.1--Vorbereitungen-
; Spindel
; - WzW Position
; - Einfluss Wz Gewicht
;   auf Bremszeit
;-----------------------
IF (iActGearStep==2)AND(gbIsGearSpindle)
  rTcSPosRes=grTcSPosG2 rTmp=grJSpG2
ELSE
  rTcSPosRes=grTcSPos rTmp=grJSpG1
ENDIF
;
IF (rTmp>0)
  ;
  ;Verlaengerung Bremszeit durch Wz Traegheitsmoment
  rWRedSp=(rTmp+rJOldTl)/rTmp
ENDIF
;
;-100.2--Vorbereitungen---
; WzW erforderlich  ->
; - Tuer Oeffen,
; - Spindel Richten,
; - Kuehlmittel Aus
; - GndSt Synchronisierung
;--------------------------------
IF (bExpectChange)
  ;
  IF (bWaitDoorCoolant)
    ; Tuer bleibt zu bis Spindel steht
    WHEN (TRUE) DO OUT_TcActive=TRUE mcDBB_StepTC=0 M=QU(MQ_ResetTCCount) M=QU($MCS_M_CODE_ALL_COOLANTS_OFF) SPOS=ACP(rTcSPosRes)
  ELSE
    WHEN (TRUE) DO OUT_TcActive=TRUE mcDBB_StepTC=0 M=QU(MQ_ResetTCCount) M=QU(MQ_TCDoorOpen) M=QU($MCS_M_CODE_ALL_COOLANTS_OFF) SPOS=ACP(rTcSPosRes)
  ENDIF
  WAITP
  bMoveInTCPrePos=FALSE
  ;
  IF (NOT bAPCInPos)AND((bBAxis)OR(iClpB>0))
    ;
    ;-100.3--Vorbereitungen-------------
    ;Pallettenwechsler nicht in Position
    ;aber B-Achsfunktion gefordert
    ;-----------------------------------
    M91
    bAPCInPos=(IN_APCInPos)
  ENDIF
ENDIF
;
;-100.4--Vorbereitungen-
; B-Achse Loesen/Klemmen
;-----------------------
IF (bBAxis)
  ;
  IF((bAxBInPos)AND(((rActBPos>=rBPosMin1)AND(rActBPos<=rBPosMax1))OR((rActBPos>=rBPosMin2)AND(rActBPos<=rBPosMax2))))
    bBAxis=FALSE bBAxReq=FALSE ;Steht schon auf Zielposition
  ELSE
    IF (bExpectChange)AND(NOT bReqM11)AND(NOT bBAxUnclamped)
      ;Tischklemmung loesen -> autom. klemmen nach Bewegung
      M=QU(18)
    ENDIF
  ENDIF
ENDIF
IF (iClpB==10)OR(iClpB==11)
  ;Tischklemmung
  M=QU(iClpB)
ENDIF
;
;-100.5--Vorbereitungen-
; VS Korrekturschalter
;-----------------------
IF (iFeedOVR>0)AND(iFeedOVR<=18)
  rFeedFactor=$MN_OVR_FACTOR_AX_SPEED[iFeedOVR] rFeedX=rFeedX*rFeedFactor rFeedY=rFeedY*rFeedFactor rFeedZ=rFeedZ*rFeedFactor rFeedB=rFeedB*rFeedFactor rFeedDGRot=rFeedDGRot*rFeedFactor rFeedEmptyDGRot=rFeedEmptyDGRot*rFeedFactor
ENDIF
;
;-100.6--Vorbereitungen-
; GndSt Synchronaktionen
;-----------------------
CANCEL(SyncID_TC+0,SyncID_TC+1,SyncID_TC+2,SyncID_TC+3,SyncID_TC+4,SyncID_TC+5,SyncID_TC+6)
CANCEL(SyncID_TC+7,SyncID_TC+8,SyncID_TC+9,SyncID_TC+10,SyncID_TC+11,SyncID_TC+12)

;-[]-120.0--PREPARE Optimierung-
;-------------------------------
IF (gbTcPrepTeachRun)AND(bExpectChange)AND(NOT bMagIsPickUpDisk)
  ;
  IF (iToDo==mcTaskPrep)AND(iOldTNo>0)AND(bRelPrep_Clmp_UnClmp)
    ;
    ;SpWz fertig
    ;
    rTmp1=mcDBR_Time rTmp2=SYG_RM[iSYG+19] rTmp3=SYG_IM[iSYG+9] SYG_RM[iSYG+19]=-1
    ;
    IF (rTmp2>0)AND(rTmp1>rTmp2)
      ;
      ;Wert = Prog.laufzeit - Startwert wird durch ToTime im Kanal 2 ausgewertet und gespeichert
      gsPrepInfo=sTName<<"*"<<$TC_TP2[iOldTNo]<<"*"<<rTmp3<<"="<<RTOI(rTmp1-rTmp2) gbPutToTime=TRUE
    ENDIF
  ENDIF
ENDIF

;==============
SEARCH_SIM_END:
;==============
;
;-[]-130.0--Fahrlogik-
;---------------------
;
IF (bZAxis)AND(bG91Last)
  ;
  ;Bei Programmierung von G91 Zxyz wird Z inkrementell zur Istposition verfahren
  rProgZPos=rActZPos+rProgZPos
  IF (rProgZPos>grTCPosZ)
    rProgZPos=grTCPosZ
  ENDIF
ENDIF
;
IF (rActZPos<grTcPosZMin)
  ;
  ;Kollision Y-Achse mit Palettenauflage
  bMoveZinSafePos=TRUE rActZPos=grTcPosZMin
ENDIF
;
IF (bZAxis)
  ;
  ;Z-Achse programmiert
  ;
  IF (NOT bMove)
    ;
    ;kein Bewegungsprofil gewaehlt
    ;
    IF (rActZPos>rProgZPos)
      ;bei Fahrten ins MINUS
      IF (rActZPos<grTcPosZ)
        ;+Z <----TcZ----ActZ-----------ProgZ sehr kritisch
        bMoveX_ZB=TRUE
      ELSE
        IF (rProgZPos<grTcPosZ)
          ;+Z <-----------ActZ----TcZ----ProgZ evtl. kritisch
          bMoveX_ZB=TRUE
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  ;
  bZAxReq=TRUE bMoveZ=TRUE
  ;
  IF (rProgZPos<=grTcPosZMin)
    ;Kollisionsgefahr Y-Achse mit Palettenauflage
    iAlarmNo=AL_ZPosInvalid sAlarmParam=" Z<"<< rProgZPos SYG_RM[iSYGArea]=130.0
    GOTOF HandleAlarm
  ENDIF
ELSE
  ;
  ;Kein Z-Achswert
  ;
  IF (gbTCFirstZMove)
    ;
    ;Bei Programmstart oder Einstieg, immer Anwahl der Z Position
    ;
    gbTCFirstZMove=FALSE
    ;
    IF (bMoveXB)OR(bMoveX)
      bMoveZ_XB=TRUE bMoveXB=FALSE bMoveX=FALSE
    ENDIF
    ;
    IF (bMoveX_B)
      bMoveZ_X_B=TRUE bMoveX_B=FALSE
    ENDIF
  ENDIF
  ;
  IF (rActZPos>=grTcPosZ)OR(bMoveXB)OR(bMoveX_B)OR(bMoveX)
    ;Achse bleibt auf Istposition oder in sicherer Position stehen
    rProgZPos=rActZPos
  ELSE
    ;Vorgabe der sicheren Position
    rProgZPos=grTcPosZ bZAxReq=TRUE bMoveZ=TRUE
  ENDIF
ENDIF
;
IF (NOT bMove)AND(bMoveZ)AND(NOT bMoveX_ZB)
  ;Anwahl Standard
  bMoveZ_XB=bRelMoveZDefault bMoveXZB=(NOT bRelMoveZDefault)
ENDIF
;
IF (iToDo<>mcTaskPrep)
  ;kein WzW Auftrag -> erst mit Z zurueck
  rProgZPos=grTcPosZ bMoveZ_XB=TRUE bZAxReq=TRUE bMoveZ=TRUE
ENDIF

;-[]-140.0--GndSt NC-
;--------------------
;
Prog_Reset(2)
;
;Metrisch oder Inch
IF (gbMetricScale)
  G71
ELSE
  G70
ENDIF
;
;-[]-150.0--Satzsuchlauf..-
; Fortsetzung
;--------------------------
;
IF (bSearchSim)
  ;
  IF (iToDo==mcTaskPrep)
    ;
    ;-150.1--Satzsuchlauf, Simulation-
    ; TC Positionen Anfahren
    ;---------------------------------
    IF (iClpB==10)OR(iClpB==11)
      ;
      ;Tischklemmung
      ;
      M=iClpB
    ENDIF
    ;
    IF (rActZPos<grTcPosZMin)
      ;
      ;vor dem WzW erst mit Z-Achse wegfahren (sonst Kollision Y-Achse mit Palettenauflage)
      Z=grTcPosZMin
    ENDIF
    ;
    IF (bReqPosAfterTC)
      rTmp=grTCPosX
    ELSE
      rTmp=grTCPrePosX
    ENDIF
    ;
    IF (bMoveXZB)AND(bBAxis)AND(bMoveZ)
      X=rTmp Y=grTCPosY Z=rProgZPos B=DC(rProgBPos)
    ELSE
      IF ((bMoveXZB)OR(bMoveXZ_B))AND(bMoveZ)
        X=rTmp Y=grTCPosY Z=rProgZPos
        B=DC(rProgBPos)
      ELSE
        IF (bMoveZ_XB)OR(bMoveZ_X_B)
          Z=rProgZPos
        ENDIF
        IF (bMoveZ_X_B)OR(NOT bBAxis)
          X=rTmp Y=grTCPosY
          IF (bBAxis)
            B=DC(rProgBPos)
          ENDIF
        ELSE
          X=rTmp Y=grTCPosY B=DC(rProgBPos)
        ENDIF
      ENDIF
      ;
    ENDIF
    ;
    IF (bPutM206)
      M206
    ENDIF
    ;
    ;M206 wird "anscheinend" bei Satzsuchlauf nicht an PLC-DB72 weitergereicht
    ;Deshalb auch keine FC8-Quittierung und damit kein Aufruf von ToAckn(..) noetig
    ;
    STOPRE
    ;
    IF (iNewTNo>0)AND(NOT bReqPosAfterTC)
      ;
      IF (iDNo>0)
        ;
        ;Gewaehlte Schneide aktivieren
        D=iDNo
      ENDIF
      ;
      IF (gbTMIsHHD)
        iTmp1=(RTOI($TC_TPC1[iNewTNo]) B_AND 'H3030') bM3=((iTmp1 B_AND 'H1000')<>0)AND(bRelSpDir) bM4=((iTmp1 B_AND 'H2000')<>0)AND(bRelSpDir) bCoolM1=((iTmp1 B_AND 'H10')<>0)AND(bRelCool) bCoolM2=((iTmp1 B_AND 'H20')<>0)AND(bRelCool)
      ELSE
        iTmp1=(RTOI($TC_DP25[iNewTNo,1]) B_AND 'HF00') bM3=((iTmp1 B_AND 'H100')<>0)AND(bRelSpDir) bM4=((iTmp1 B_AND 'H200')<>0)AND(bRelSpDir) bCoolM1=((iTmp1 B_AND 'H400')<>0)AND(bRelCool) bCoolM2=((iTmp1 B_AND 'H800')<>0)AND(bRelCool)
      ENDIF
      ;
      IF (bM3)
        S=rSpeed M3
      ELSE
        ;
        IF (bM4)
          S=rSpeed M4
        ELSE
          IF (rSpeed>0)
            iAlarmNo=Al_CombNotAllowed sAlarmParam="M5 + S"<<rSpeed SYG_RM[iSYGArea]=150.1
            GOTOF HandleAlarm
          ENDIF
          S0 M5
        ENDIF
      ENDIF
      ;
      IF (bCoolM1)AND(bCoolM2)
        M=$MCS_M_CODE_COOLANT_1_AND_2_ON
      ELSE
        ;
        IF (bCoolM1)
          M=$MCS_M_CODE_COOLANT_1_ON
        ELSE
          ;
          IF (bCoolM2)
            M=$MCS_M_CODE_COOLANT_2_ON
          ELSE
            M=$MCS_M_CODE_ALL_COOLANTS_OFF
          ENDIF
        ENDIF
      ENDIF
    ELSE
      IF (rSpeed>0)
        iAlarmNo=Al_CombNotAllowed sAlarmParam="M5 + S"<<rSpeed SYG_RM[iSYGArea]=150.1
        GOTOF HandleAlarm
      ENDIF
      S0 M5 M=$MCS_M_CODE_ALL_COOLANTS_OFF
    ENDIF
  ENDIF
  ;
  ;-----
  ; Ende
  ;-----
  ;
  RET
ENDIF

;-[]-160.0--WzW-------------
;
; Bisher gestartet:
; - Sp - Positionieren
; - WzW Tuer - Oeffnen
; - Kuemi - Aus
; - B - Entklemmen
;
; Es folgt:
; Starten X,Y,(Z) in PREPOS
; Geschwindigkeit X wird
; aus Erfahrungswerten fuer
; - Oeffnungszeit WzW Tuer
; - Laufzeit Y
; - Positionierzeit Sp
; - Vorbereitungszeit min.
; ermittelt
;--------------------------
IF (bExpectChange)
  ;
  IF (NOT bAPCInPos)AND(bZAxis)AND(NOT bMoveAPC)
    ;
    ;-160.1--WzW------------------------
    ;Pallettenwechsler nicht in Position
    ;aber Z Bewegung gefordert
    ;-----------------------------------
    M91
    bAPCInPos=(IN_APCInPos)
  ENDIF
  ;
  IF (bMoveZinSafePos)
    ;
    ;-160.2--WzW------------------------------------
    ; Kollision Y-Achse mit Palettenauflage moeglich
    ; -> vor dem WzW erst mit Z-Achse wegfahren
    ;-----------------------------------------------
    G0 G40 G60 G602 G17 G153 G90 G94 Z=grTcPosZMin
  ENDIF
  ;
  ;-160.3--WzW-------------
  ; Geschwindigkeit X-Achse
  ;------------------------
  rMoveDistX=MAXVAL(rPrePosX-rActXPos,0) rMoveDistY=ABS(grTCPosY-rActYPos) rCalcTime=0 rFeedXPrePos=rFeedX iCount=0
  ;
  If (rMoveDistX>0)AND(rMoveDistY>0)
    ;
    ;Laufzeit Y-Achse
    ;
    REPEAT
      iCount=iCount+1 rVelo=MINVAL(EXP(1/3*LN(rMoveDistY*rMoveDistY*rActJerkY/4)),rFeedY/60)
      IF (rVelo<2*rMaxVjY)
        rActJerkY=rMaxJerkY*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjY-rVelo)/(2*rMaxVjY)))) rPosTime=2*SQRT(rVelo/rActJerkY)
      ELSE
        rPosTime=rVelo/rMaxAccelY+rMaxTjY rActJerkY=rMaxJerkY
      ENDIF
    UNTIL (iCount==giItCount)OR(rActJerkY==rMaxJerkY)
    ;
    rPosWin=0.5*rVelo*rPosTime rTmp=EXP(1/3*LN(6*rRelXByY/rActJerkY))
    IF (2*rPosWin<rMoveDistY)
      rCalcTime=2*rPosTime+(rMoveDistY-2*rPosWin)/rVelo-rTmp
    ELSE
      rCalcTime=2*rPosTime-rTmp
    ENDIF
  ENDIF
  ;
  bSwitched=(($A_DBB[7] B_AND 'B1')<>0) bAllAxInFinePos=($AA_STAT[mcAxX]==4)AND($AA_STAT[mcAxY]==4)AND($AA_STAT[mcAxZ]==4)AND(($AA_STAT[mcAxB]==4)OR(NOT bBAxis))
  ;
  ;-160.4--WzW----------
  ; Umschaltung Endlagen
  ;---------------------
  IF (rPrePosX<=grTCPrePosX)AND(NOT bSwitched)
    ;
    iErrCount=0
    REPEAT
      bEnabled=(($A_DBB[7] B_AND 'B1')<>0) bAllAxInFinePos=($AA_STAT[mcAxX]==4)AND($AA_STAT[mcAxY]==4)AND($AA_STAT[mcAxZ]==4)AND(($AA_STAT[mcAxB]==4)OR(NOT bBAxis)) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=160.4
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam="LIMIT X"
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
  ENDIF
  ;
  ;-160.5--WzW--------------------------
  ; Solange nicht in Genauhalt-Fein
  ; - sonst Fehler bei Start Sync-Aktion
  ; - falsche Berechnungsgrundlagen
  ;-------------------------------------
  IF (NOT bAllAxInFinePos)OR(NOT bDGInBasePos)
    ;
    iErrCount=0
    REPEAT
      ;
      bTmp1=($AA_STAT[mcAxX]==4) bTmp2=($AA_STAT[mcAxY]==4) bTmp3=($AA_STAT[mcAxZ]==4) bTmp4=(($AA_STAT[mcAxB]==4)OR(NOT bBAxis)) bEnabled=(bTmp1)AND(bTmp2)AND(bTmp3)AND(bTmp4) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=160.5
      ;
      IF (NOT bEnabled)
        ;
        IF (iErrCount>10)
          G4 F=rWaitShort
        ELSE
          G4 F=rIPO
        ENDIF
        ;
        IF (iErrCount>=iErrTimeShort)
          sAlarmParam="" sTmp=""
          IF (NOT bTmp1)
            sAlarmParam="X" sTmp=", "
          ENDIF
          IF (NOT bTmp2)
            sAlarmParam=sAlarmParam<<sTmp<<"Y" sTmp=", "
          ENDIF
          IF (NOT bTmp3)
            sAlarmParam=sAlarmParam<<sTmp<<"Z" sTmp=", "
          ENDIF
          IF (NOT bDGInBasePos)
            ;
            IF (bDGIsNCAxis)
              sAlarmParam=sAlarmParam<<sTmp<<AXSTRING(mcAxDGRot)
            ELSE
              FileRead("DG_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
              sAlarmParam=sAlarmParam<<sTmp<<sAux
            ENDIF
          ENDIF
          IF (NOT bTmp4)
            sAlarmParam=sAlarmParam<<sTmp<<"B"
          ENDIF
          ;
          iAlarmNo=AL_WaitFor
          GOTOF HandleAlarm
        ENDIF
      ENDIF
      ;
    UNTIL (bEnabled)
    ;
  ENDIF
  ;
  ;Ausgangsstatus fuer die folgenden Rechnungen und STOPRE nach Genauhalterkennung
  rActSpeed=$AA_S[iSpNo] rDoorActTime=$A_DBW[476] bAxSpInPos=(mcbSpInTCPosCoarse)
  ;
  ;-160.6--WzW-----------
  ; Restlaufzeit WzW Tuer
  ;----------------------
  IF (NOT bWaitDoorCoolant)AND(rDoorActTime>0)
    rCalcTime=MAXVAL(MAXVAL(grDoorOpenTime-rSafeCalc*MAXVAL(rDoorActTime/1000,0),0),rCalcTime)
  ENDIF
  ;
  ;Beruecksichtigung der Minimale Vorbereitungszeit
  rCalcTime=MAXVAL(rCalcTime,rPrepTimeMin)
  ;
  IF (gbSpecTlInSp)
    ;
    ;-160.7--WzW-------
    ; Laufzeit SonderWz
    ;------------------
    SpecTlMan(0)
    ;
    rCalcTime=MAXVAL(rCalcTime,grSpecTlRunTime)
    ;
  ENDIF
  ;
  IF (rCalcTime>0)
    rFeedXPrePos=MINVAL(rMoveDistX*60/rCalcTime,rFeedX) rFeedXRelSp=rFeedXPrePos
  ENDIF
  ;
  ;-160.8--WzW--------------
  ; Wartezeit Spindelrichten
  ;-------------------------
  IF (NOT bWaitDoorCoolant)
    ;
    rMoveDistX=MAXVAL(rSpPosX-rActXPos,0) rCalcTime=0
    ;
    IF (NOT bAxSpInPos)
      ;
      ;Sp noch nicht gerichtet
      ;
      IF (gbIsGearSpindle)AND(iActGearStep==2)
        IF (grTCSPOS2_k1>0)
          IF (rActSpeed>grTCSPOS2_n2)
            rCalcTime=rWRedSp*(grTCSPOS2_k1*(grTCSPOS2_n2-grTCSPOS2_n1)/10000+grTCSPOS2_k2*(rActSpeed-grTCSPOS2_n2)/10000+grTCSPOS2_tb)
          ELSE
            rCalcTime=rWRedSp*(grTCSPOS2_k1*(rActSpeed-grTCSPOS2_n1)/10000+grTCSPOS2_tb)
          ENDIF
        ENDIF
      ELSE
        IF (grTCSPOS1_k1>0)
          IF (rActSpeed>grTCSPOS1_n2)
            rCalcTime=rWRedSp*(grTCSPOS1_k1*(grTCSPOS1_n2-grTCSPOS1_n1)/10000+grTCSPOS1_k2*(rActSpeed-grTCSPOS1_n2)/10000+grTCSPOS1_tb)
          ELSE
            rCalcTime=rWRedSp*(grTCSPOS1_k1*(rActSpeed-grTCSPOS1_n1)/10000+grTCSPOS1_tb)
          ENDIF
        ENDIF
      ENDIF
      ;
    ENDIF
    ;
    IF (bRelMoveUnClmp_U)AND(bOldTlFast)AND(NOT bDGIsNCAxis)
      ;
      ;Beruecksichtigung der Loeszeit
      rCalcTime=rCalcTime+rSafeCalc*grSpUnClmpTimeC
    ENDIF
    ;
    IF (rCalcTime>0)AND(rMoveDistX>0)
      ;
      IF (bDGIsNCAxis)
        ;
        ;aus dem Stand bis in TCPOS
        iCount=0 rCalcTime1=rCalcTime rVelo=0
        WHILE (iCount<giItCount)AND(rCalcTime>0)AND(rVelo<rFeedX/60)
          rVelo=rMoveDistX/rCalcTime iCount=iCount+1
          IF (rVelo<2*rMaxVjX)
            rActJerk=rMaxJerkX*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjX-rVelo)/(2*rMaxVjX)))) rCalcTime=rCalcTime1-2*SQRT(rVelo/rActJerk)
          ELSE
            rCalcTime=rCalcTime1-(rVelo/rMaxAccelX+rMaxTjX)
          ENDIF
        ENDWHILE
      ENDIF
      ;
      IF (rCalcTime>0)
        rFeedXRelSp=MINVAL(rMoveDistX*60/rCalcTime,rFeedX)
        rFeedXPrePos=MINVAL(rFeedXPrePos,rFeedXRelSp)
      ENDIF
    ENDIF
  ENDIF
  ;
  ;-160.9--WzW------------
  ; X auf Vorposition
  ; Y und (Z) auf Position
  ;-----------------------
  IF (bMoveXZB)AND(bBAxis)AND(bMoveZ)
    bBAxReq=FALSE bZAxReq=FALSE sAux="($AA_STAT[mcAxZ]==4)AND($AA_STAT[mcAxB]==4) DO POS[mcAxX]=rPrePosX POS[mcAxY]=grTCPosY POS[mcAxZ]=rProgZPos POS[mcAxB]="<<sModeB<<"(rProgBPos)"
  ELSE
    IF ((bMoveXZB)OR(bMoveXZ_B))AND(bMoveZ)
      bZAxReq=FALSE sAux="($AA_STAT[mcAxZ]==4) DO POS[mcAxX]=rPrePosX POS[mcAxY]=grTCPosY POS[mcAxZ]=rProgZPos"
    ELSE
      IF (bMoveZ_XB)OR(bMoveZ_X_B)
        sAux="(ABS(rProgZPos-$VA_IM[mcAxZ])<=rc0x5mm) DO POS[mcAxX]=rPrePosX POS[mcAxY]=grTCPosY"
        ID=SyncID_TC+1 WHEN ($AA_STAT[mcAxZ]==4) DO POS[mcAxZ]=rProgZPos
      ELSE
        sAux="(TRUE) DO POS[mcAxX]=rPrePosX POS[mcAxY]=grTCPosY"
      ENDIF
    ENDIF
  ENDIF
  EXECSTRING("ID=SyncID_TC+0 WHEN ($AA_STAT[mcAxX]==4)AND($AA_STAT[mcAxY]==4)AND"<<sAux<<" FA[mcAxX]=rFeedXPrePos FA[mcAxY]=rFeedY FA[mcAxZ]=rFeedZ FA[mcAxB]=rFeedB SYG_IM[iSYG+1]=1")
  ;
  ;-161.0--SonderWz_1----
  ; Planzugachse in TCPos
  ;----------------------
  IF (gbSpecTlInSp)
    ;
    SpecTlMan(1)
    ;
    IF (giResult==1)
      ;
      ;Kuehlmitteldruck abbauen
      G04 F1.0
      ;
      CANCEL(SyncID_TC+10)
      ID=SyncID_TC+10 DO FA[mcAxFH]=$MA_MAX_AX_VELO[mcAxFH] POS[mcAxFH]=grTCPosFH
      ;
    ELSE
      IF (giResult<>0)
        iAlarmNo=giResult sAlarmParam=gsResult SYG_RM[iSYGArea]=161.0
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  ENDIF

  ;-[MTC,DISK,WM307]-162.0-WzW--------------------
  ;
  ; Sonderspannzange
  ; ----------------
  ; SpWz Loesen, wenn
  ; - Sp gerichtet und "schnelles" Wz
  ;   oder
  ; - X in TCPOSX und geloeste Uebergabe gefordert
  ;-----------------------------------------------
  ;
  IF (bRelMoveUnClmp)AND(bOldTlFast)AND(NOT bDGIsWM286)
    ;
    ;Sp Loesen
    ID=SyncID_TC+4 WHEN (mcbSpInTCPosCoarse)AND(((grTCPosX-$VA_IM[mcAxX])<=rTCInPosCoarse)OR(bOldTlFast)) DO M=QU(MQ_SpUnClmpTl) SYG_RM[iSYG+5]=grSpUnClmpTimeC SYG_RM[iSYG+6]=1
    ;
    ;Messung der Loeszeit
    ID=SyncID_TC+7 WHENEVER (SYG_RM[iSYG+5]>0) DO SYG_RM[iSYG+5]=MAXVAL((SYG_RM[iSYG+5]-rIPO),0)
  ENDIF
  ;-[]-
  ;
ENDIF

;-[]-170.0--WzWTuer-------------
; - Ueberwachung aktiviert
; - WzW Tuer nicht offen
; -> "NotStopp"(RESET pflichtig)
;-------------------------------
IF (bDGIsNCAxis)
  ID=SyncID_TC+12 WHENEVER (SYG_BM[iSYG+4])OR(SYG_BM[iSYG+3])AND(NOT mcbDBB_TCDoorOpen) DO SYG_BM[iSYG+4]=TRUE $AA_OVR[mcAxX]=0 $AA_OVR[mcAxDGRot]=0
ELSE
  ID=SyncID_TC+12 WHENEVER (SYG_BM[iSYG+4])OR(SYG_BM[iSYG+3])AND(NOT mcbDBB_TCDoorOpen) DO SYG_BM[iSYG+4]=TRUE $AA_OVR[mcAxX]=0
ENDIF

;-[]-180.0--SpWz Be/Entladen-
; Bereitstellungsauftrag ohne
; Vorwahl mit "T" ausloesen
;----------------------------
;
IF (iToDo<>mcTaskPrep)
  ;
  STOPRE
  ;
  ;Aktuelles Werkzeug in Spindel
  iOldTNo=$TC_MPP6[9998,mcLocSP] bMoveInTCPrePos=FALSE
  ;
  IF (sTName<>"")AND(sTName<>"0")AND(iDuploNo>0)
    ;
    ;Beladen
    ;
    iNewTNo=GETT(sTName,iDuploNo)
  ELSE
    ;
    ;Entladen
    ;
    iNewTNo=0 sTName="0" iDuploNo=0
  ENDIF
  ;
  ;Das neue, geforderte Wz ist bereits in der Spindel z.B. beim ENTLADEN auf Beladestelle_Hand
  ;
  IF (iNewTNo>0)AND(iOldTNo==iNewTNo)
    ;kein WzW noetig
    GOTOF FINISH_TC
  ENDIF
  ;
  IF (gbPrepActiv)
    ;
    ;-181.0--SpWz Be/Entladen-
    ; Warten auf Ende der
    ; laufenden Vorbereitung
    ;-------------------------
    iErrCount=0
    WHILE (NOT gbPrepDone)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=181.0
      IF (iErrCount>=iWaitCha2)
        iAlarmNo=AL_WaitFor sAlarmParam="gbPrepDone"
        GOTOF HandleAlarm
      ENDIF
    ENDWHILE
    ;
    ;Auftrag an HG/DGPrep - Ausstieg aus Warteschleife
    ;
    gbPrepReset=TRUE
    ;
    ;-181.1--SpWz Be/Entladen------
    ; Warten auf erfolgten Ausstieg
    ;------------------------------
    iErrCount=0
    WHILE (gbPrepActiv)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=181.1
      IF (iErrCount>=iWaitCha2)
        iAlarmNo=AL_WaitFor sAlarmParam="gbPrepActiv"
        GOTOF HandleAlarm
      ENDIF
    ENDWHILE
  ENDIF
  ;
  ;-182.0--SpWz Be/Entladen----
  ; Freigabe eines neuen
  ; Bereitstellungsauftrages
  ; - Hauptlauf Synchronisieren
  ; - Bereitstellung ausloesen
  ;----------------------------
  SYG_BM[iSYG]=FALSE
  ;
  gbPrepDone=FALSE iNewTlMag=0 iNewTlLoc=0 iOldTlMag=0 iOldTlLoc=0
  ;
  ;-182.1--SpWz Be/Entladen-
  ;-------------------------
  IF (iToDo==mcTaskLoad)
    ;
    ;leeres HG/DG/Mag bereitstellen zur Aufnahme des zu beladenen Wz Neues Wz ins Magazin
    ;
    iTmp1=iJobPtrMove iTmp2=iToDo bMoveInTCPrePos=TRUE
    ;
    GOTOF PutJob
  ENDIF
  ;
  ;-182.2--SpWz Be/Entladen-
  ;-------------------------
  IF (iToDo==mcTaskUnload)
    ;
    ;zu entladendes Wz aus HG/DG/Mag
    ;
    iTmp1=iJobPtrMove iNewTlMag=9998 iNewTlLoc=mcLocSP iTmp2=iToDo
    IF (iNewTNo>0)
      ;
      ;Ort gewaehltes Wz
      iOldTlMag=$A_TOOLMN[iNewTNo] iOldTlLoc=$A_TOOLMLN[iNewTNo]
    ELSE
      MakeAlarmparam(sAlarmParam,sTName,<<iDuploNo)
      iAlarmNo=AL_TlNotFound SYG_RM[iSYGArea]=182.2
      GOTOF HandleAlarm
    ENDIF
    ;
    ;Zu entladendes Wz ist in HG/DG/Mag -> Vorposition Anfahren
    bMoveInTCPrePos=((iOldTlMag>0)AND(iOldTlMag<=giNumRealMag)AND(iOldTlLoc>0))OR((iOldTlMag==9998)AND(iOldTlLoc<>mcLocSp))
    ;
    GOTOF PutJob
  ENDIF
  ;
  IF (iToDo==mcTaskAS_T0)
    ;
    IF (iOldTNo>0)
      ;
      ;-182.3--SpWz Be/Entladen------------------
      ; HG/DG/Mag leerfahren (ToPrep)
      ;------------------------------------------
      iTmp1=iJobPtrASync iTmp2=mcTaskAS_T0 bMoveInTCPrePos=TRUE
    ELSE
      ;
      ;
      ;-183.0--SpWz Be/Entladen------------
      ; Warten bis laufender Auftrag fertig
      ;-182.4--SpWz Be/Entladen----------
      ; - HG/DG/Mag leerfahren (ToTrans)
      ; - Platz SpWz bereitstellen
      ;----------------------------------
      iTmp1=iJobPtrASync iTmp2=mcTaskAS_Displace iNewTlMag=9998 iNewTlLoc=mcLocSp
    ENDIF
  ENDIF
  ;
  IF (iToDo==mcTask_Displace)
    ;
    ;-182.5--SpWz Be/Entladen----------
    ; Kein Wz in Sp und TC("0")
    ; - HG/DG/Mag leerfahren (ToTrans)
    ; - Platz SpWz bereitstellen
    ;----------------------------------
    iTmp1=iJobPtrPrep iTmp2=mcTask_Displace iNewTlMag=9998 iNewTlLoc=mcLocSp
  ENDIF
  ;
  ;======
  PutJob:
  ;======
  ;------------------------------------
  WHILE ($A_DBW[iTmp1+2]==1)
    G4 F=rWaitShort
    STOPRE
  ENDWHILE
  ;
  ;-183.1--SpWz Be/Entladen----
  ; Auftragspuffer fuer Kanal 2
  ;----------------------------
  $A_DBW[iTmp1]=iTmp2 $A_DBW[iTmp1+4]=0 $A_DBW[iTmp1+6]=iNewTNo
  $A_DBW[iTmp1+8]=iOldTlMag $A_DBW[iTmp1+10]=iOldTlLoc $A_DBW[iTmp1+12]=iNewTlMag $A_DBW[iTmp1+14]=iNewTlLoc
  $A_DBW[iTmp1+16]=0 $A_DBW[iTmp1+18]=0 $A_DBW[iTmp1+20]=0 $A_DBW[iTmp1+22]=0 $A_DBW[iTmp1+24]=1
  ;
  ;Auftrag aktivieren
  $A_DBW[iTmp1+2]=1
  ;
  GOTOF PREP_REQUEST_END
ENDIF

;============
PREP_REQUEST:
;============

;-[]-200.0--PREPARE------------
; Wenn im Vorlauf noch keine
; Vorbereitung erkannt wurde
; - Warten bis das angeforderte
;   Wz vorbereitet ist
; - Eventuell fehlende
;   Bereitstellung Nachholen
;-------------------------------
LOOP
  ;
  ;
  ;-200.1--PREPARE-----------
  ; Hauptlauf Synchronisieren
  ;--------------------------
  STOPRE
  ;
  ;vorgewaehltes Werkzeug
  GETSELT(iNewTNo)
  ;
  ;-200.2--PREPARE--
  ; Wz vorgewaehlt ?
  ;-----------------
  IF (iNewTNo>0)
    ;
    ;Es ist ein WZ vorgewaehlt
    ;
    sSelTName=$TC_TP2[iNewTNo] iSelSTNo=$TC_TP1[iNewTNo]
    ;
    IF (sSelTName<>sTName)OR((iSelSTNo<>iSTNo)AND(iSTNo>0))
      ;
      ;einzuwechselndes Wz <> vorgewaehltes Wz
      ;
      ;neue Wz-Vorbereitung ausloesen
      iNewTNo=0
      GOTOF PREP_NEW
    ENDIF
    ;
    IF (iOldTNo==iNewTNo)
      ;
      ;gefordertes Wz bereits in der Spindel
      ;
      IF (($TC_TP8[iOldTNo] B_AND 'B110')=='B010')
        ;
        ;WZ ist freigegeben und nicht gesperrt, damit die Korrekturen des SpWz auch aktiviert werden
        ;
        IF (bPutM206)
          M206
          bPutM206=FALSE
          ;
          ;WzW-Endequittierung
          ToAckn(TRUE,iTaskId,iTaskIdNo,iNewTNo,iOldTNo,-1,-1,-1,-1,1)
        ENDIF
        ;
        ;kein WZW erforderlich
        bNoRealTC=TRUE
        GOTOF FINISH_TC
      ELSE
        ;
        ;SpWz nicht freigegeben oder SpWz gesperrt
        ;
        ;WZ-Vorbereitung ausloesen
        iNewTNo=0
      ENDIF
    ENDIF
  ENDIF
  ;
  ;-200.3-PREPARE---------
  ; Vorbereitung ausloesen
  ;-----------------------
  ;
  ;========
  PREP_NEW:
  ;========
  ;
  IF (iNewTNo>0)
    ;
    ;-200.4--PREPARE-------
    ; Vorgewaehltes Wz ist schon vorbereitet,
    ; aber noch nicht in Sp -> WzW
    ;----------------------
    GOTOF PREP_REQUEST_END
  ELSE
    ;
    IF (bIsT0)
      ;
      ;T0 gefordert und SpWz vorhanden
      ;
      ;Leerfahren der Sp
      IF (iNewTNo==0)AND(iOldTNo>0) GOTOF PREP_REQUEST_END
      ;
      ;T0 angefordern
      iNewTNo=0
    ELSE
      ;
      ;Vorgewaehltes Wz nicht verfuegbar
      ;
      IF (iNewTNo<0)
        ;
        ;-200.5--PREPARE---------
        ; Abwarten der laufenden
        ; Pruefung, damit Kanal 2
        ; den folgenden Alarm
        ; nicht ueberschreibt
        ;------------------------
        iErrCount=0 bEnabled=FALSE bActMsg=FALSE
        WHILE (giToBreakCtrlState<>0)AND(giToNoProb>0)AND(NOT bRepeatPrep)
          ;
          IF (NOT bActMsg)
            MSG(MSG_ToBreakCtrlRunning<<": T = "<<$TC_TP2[giToNoProb]<<"/"<<$TC_TP1[giToNoProb])
            bActMsg=TRUE
          ENDIF
          ;
          G4 F=rWaitLong
          iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=200.5
          IF (iErrCount>iErrTimeLong)
            bEnabled=TRUE iErrCount=0 bActMsg=FALSE
          ENDIF
        ENDWHILE
        ;
        IF (bActMsg)
          MSG("")
        ENDIF
        ;
        ;-200.6--PREPARE--------------
        ; Meldung: Vorzubereitendes WZ
        ; nicht verfuegbar/gefunden
        ;
        ; MsgBox(,...ID=2,...) gibt in
        ; der PLC das Be-/Entladen am
        ; Magazinbedienpult frei
        ;-----------------------------
        MsgBox(<<AL_PleasePrepTool67,"FIRST CLEAR ID=2",,sTName)
        ;
        SYG_RM[iSYGArea]=200.6
        ;
        ;Warten bis alle Achsen in Vorposition
        WAITP(X,Y,Z)
        ;
        IF ($AA_IM[mcAxX]<=rPrePosX)AND(NOT mcbDBB_TCDoorClosed)
          ;
          ;WzW-Tuere nicht geschlossen -> Schliessen
          M_TcDoorClose1
        ENDIF
        ;
        MsgBox(<<AL_PleasePrepTool67,"LAST BSTART BQUIT ID=2","TRUE",sTName)
        ;
        IF (gsMsgBoxResult=="BQUIT")
          ;
          ;Vorwahl T0
          sMissingTl=sTName sTName="0" iNewTNo=0 bIsT0=TRUE bExpectChange=FALSE
          ;
          IF (iOldTNo==0)
            ;
            ;kein SpWz
            ;
            IF (NOT mcbDBB_SpClampedNoTl)
              M_SpClampNoTool1
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    ;
    IF (gbPrepActiv)
      ;
      ;-201.0--PREPARE-------
      ; Warten auf Ende eines
      ; laufenden Auftrags
      ;----------------------
      iErrCount=0
      WHILE (NOT gbPrepDone)
        G4 F=rWaitShort
        iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=201.0
        IF (iErrCount>=iWaitCha2)
          iAlarmNo=AL_WaitFor sAlarmParam="gbPrepDone"
          GOTOF HandleAlarm
        ENDIF
      ENDWHILE
      ;
      ;-201.1--PREPARE-------------
      ; Wz Bereitstellung beendet
      ; bzw. Vorbereitung quittiert
      ;----------------------------
      ;
      IF (NOT bIsT0)
        ;
        ;vorgewaehltes Werkzeug
        GETSELT(iNewTNo)
        ;
        IF (iNewTNo>0)
          ;
          sSelTName=$TC_TP2[iNewTNo] iSelSTNo=$TC_TP1[iNewTNo]
          ;
          ;Bereitgestelltes Wz ist gefordertes Wz
          IF (sSelTName==sTName)AND((iSelSTNo==iSTNo)OR(iSTNo==0)) GOTOF PREP_REQUEST_END
        ENDIF
      ENDIF
      ;
      ;-201.2--PREPARE--------
      ; Auftrag an HG/DGPrep
      ; Ausstieg Warteschleife
      ;-----------------------
      gbPrepReset=TRUE iErrCount=0
      ;
      ;-201.3--PREPARE-----
      ; Warten auf Ausstieg
      ;--------------------
      WHILE (gbPrepActiv)
        G4 F=rWaitShort
        iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=201.3
        IF (iErrCount>=iWaitCha2)
          iAlarmNo=AL_WaitFor sAlarmParam="gbPrepActiv"
          GOTOF HandleAlarm
        ENDIF
      ENDWHILE
    ENDIF
    ;
    ;-202.0--PREPARE----------
    ; Freigabe eines neuen
    ; Bereitstellungsauftrages
    ;-------------------------
    ;
    gbPrepDone=FALSE SYG_BM[iSYG]=FALSE
    ;
    IF (sTName<>"0")
      ;
      ;Vorbereitung explizit ausloesen wg. GETSELT
      ;
      IF (iSTNo>0)
        TCA(sTName,iSTNo)
      ELSE
        T=sTName
      ENDIF
    ELSE
      ;
      ;-203.0--PREPARE-
      ; Bei TC("0")...
      ;----------------
      IF (iOldTNo>0)
        ;
        ;Wz in Spindel
        ;
        T0
      ELSE
        ;
        ;kein Wz in Spindel
        ;
        ;Gefordertes Wz ist nicht freigegeben -> Abbruch TC, Wz aber nicht zurueck ins Magazin
        IF (sMissingTl==sTName) GOTOF FINISH_TC
        ;
        IF (gbWithHG)OR(bMagIsMiksch)
          ;
          IF(gbDg2MagSide)OR($TC_MPP6[iSpLoadMag,iSpLoadLoc]>0)
            ;
            ;Wz in HG/DG -> ins Magazin
            ;
            T0
          ENDIF
        ENDIF
      ENDIF
      ;
      ;-203.1--PREPARE--
      ; Angestossen oder
      ; nicht notwendig
      ;-----------------
      GOTOF PREP_REQUEST_END
    ENDIF
  ENDIF
ENDLOOP
;
;================
PREP_REQUEST_END:
;================
;
;-[]-204.0--PREPARE----
; Abbruch der eventuell
; noch laufenden Warte-
; schleife im Kanal 2
;----------------------
gbWaitPrepare=FALSE
;
;-[]-205.0--PREPARE---------
; Kein WzW erforderlich
; z.B. TC("0") und kein SpWz
;---------------------------
IF (iNewTNo<=0)AND(iOldTNo<=0)
  bNoRealTC=TRUE
  GOTOF FINISH_TC
ENDIF
;
;-[]-206.0--PREPARE-----
; Erkennung Handwerkzeug
;-----------------------
bNewIsManTl=FALSE bOldIsManTl=FALSE
IF (iOldTNo>0)
  ;
  ;SpWz war noch nicht im Magazin und soll dort auch nicht abgelegt werden
  ;
  bOldIsManTl=($A_MYMN[iOldTNo]==0)AND($A_MYMLN[iOldTNo]==0)AND(iToDo<>mcTaskLoad)
ENDIF
;
IF (iNewTNo>0)
  ;
  IF ($A_MYMN[iNewTNo]==0)AND($A_MYMLN[iNewTNo]==0)AND(iToDo<>mcTaskUnload)
    ;
    ;NeuWz war noch nicht im Magazin bzw. wurde von dort in die Sp entladen.
    ;Ausserdem soll es nicht aus dem Magazin ueber die Sp entladen werden.
    ;
    bNewIsManTl=TRUE bFast=FALSE
  ENDIF
ENDIF
;
;-[]-207.0--PREPARE-
; NeuWz - Status
;-------------------
IF (iNewTNo>0)
  ;
  ;HMI
  ;
  giMMC_TNo=iNewTNo giToDuplo=$TC_TP1[iNewTNo]
  ;
  IF (iToDo==mcTaskPrep)
    ;
    ;-207.1--PREPARE-------
    ; Status SpWz Vermessen
    ;----------------------
    ;
    ;zu vermessende Schneide / Option Wz vermessen / Status: Wz ist vermessen
    iMeasCutNo=RTOI($TC_TPC2[iNewTNo]) iMeasMode=0 iMeasState=0
    ;
    IF (gbTMIsHHD)
      ;
      ;Ersteinsatz nicht bestaetigt
      bTmp=((RTOI($TC_TPC8[iNewTNo]) B_AND 'B1')==0)
      ;
      IF (iMeasCutNo>0)AND($P_TOOLND[iNewTNo]>=iMeasCutNo)
        iMeasMode=(RTOI($TC_DPC1[iNewTNo,iMeasCutNo]) B_AND 'B10') iMeasState=(RTOI($TC_DPC2[iNewTNo,iMeasCutNo]) B_AND 'H100')
      ENDIF
    ELSE
      bTmp=((RTOI($TC_TPC1[iNewTNo]) B_AND 'H200')==0) iMeasMode=(RTOI($TC_TPC1[iNewTNo]) B_AND 'B10') iMeasState=(RTOI($TC_TPC1[iNewTNo]) B_AND 'B1000')
    ENDIF
    ;
    ;SpWz sollte vermessen sein, ist es aber noch nicht
    ;
    bNewTlNotMeasured=(iMeasCutNo<>0)AND(iMeasMode<>0)AND(iMeasState==0)
    ;
    ;-207.2--PREPARE-------------------------
    ; Ersteinsatz erkannt und Stop angewaehlt
    ;----------------------------------------
    gbTlFirstMach=((bTmp)OR(($TC_TP8[iNewTNo] B_AND 'H80')==0))AND((giOptToolMgmt B_AND 'B1')<>0)AND((RTOI($TC_TPC1[iNewTNo]) B_AND 'H1000000')<>0)
    ;
    ;-207.3--PREPARE-----------
    ; Ueberpruefung der Daten
    ; des einzuwechselnden Wz's
    ;--------------------------
    ;
    REPEAT
      ;
      CheckTlData(gsReqTlData,1,iNewTNo)
      ;
      IF (giResult>0)
        ;
        ;Fehler bei der Ueberpruefung (Alarmnr in giResult)
        ;
        MsgBox(<<giResult,"CLEAR LAST BSTART BQUIT","TRUE",gsResult)
        ;
        IF (gsMsgBoxResult=="BQUIT")
          ;
          ;Abbruch WzW
          ToAckn(FALSE,iTaskId,iTaskIdNo,0,0,0,0,0,0,3)
          ;
          ;Vorwahl T0
          bOffsNotValid=TRUE sTName="0" iNewTNo=0 bIsT0=TRUE bExpectChange=FALSE
          ;
          IF (iOldTNo==0)
            ;
            ;kein SpWz -> kein Entladen noetig
            ;
            IF (($A_DBB[0] B_AND 'B10')==0)
              M_SpClampNoTool1
            ENDIF
            ;
            gsReqTlData=""
            ;
            GOTOF FINISH_TC
          ELSE
            ;
            T0
            STOPRE
            ;
            GOTOB PREP_REQUEST
          ENDIF
        ENDIF
      ENDIF
    UNTIL (giResult<=0)
    ;
    ;keine oder geforderte Pruefung ohne Fehler
    ;
    gsReqTlData=""
  ENDIF
ELSE
  ;
  ;HMI aktualisieren
  giMMC_TNo=0 giToDuplo=0
ENDIF
;
;-[]-208.0--PREPARE-
;-------------------
IF (bRepeatPrep)
  ;
  ;Vorbereitung wird wiederholt
  ;
  ;Sicherstellen, das WzwTuer offen ist
  M=QU(MQ_TCDoorOpen)
  GOTOF WAIT_PREP
ENDIF

;-[MTC]-210.0--Pruefungen-
;-------------------------
IF (bMonTCMaxToolLen)AND(iNewTNo>0)
  ;
  ;Ueberlanges Werkzeug in Sp/HG
  ;Ist nur mit Freigabe durch gbEnaMaxToolLen oder ENMAXTL erlaubt
  ;
  IF (rOldTlColLen>=grTcMaxToolLen)AND(NOT bEnMaxTlLen)
    ;Werkzeug aus HG hat Uebergroesse,keine Freigabe Werkzeugwechsel
    iAlarmNo=AL_HgTlOverSize sAlarmParam="" SYG_RM[iSYGArea]=210.0
    GOTOF HandleAlarm
  ENDIF
ENDIF
;
;-[WM286]-210.1--Pruefungen------
; Ueberlanges Werkzeug in Spindel
; und HG ist nicht moeglich
;--------------------------------
IF (bDGIsWM286)
  ;
  IF (iNewTNo>0)
    ;
    bHgTlOverSize=FALSE bSpTlOverSize=FALSE
    ;
    IF (gbTMIsHHD)
      rTmp=MAXVAL($TC_TPC11[iNewTNo],$TC_TPC16[iNewTNo])
    ELSE
      rTmp=$TC_TPC7[iNewTNo]
    ENDIF
    ;
    IF (rTmp>=grTCLenOverSize)
      ;
      ;ueberlanges Wz im Hg
      bHgTlOverSize=TRUE
    ENDIF
  ENDIF
  ;
  IF (iOldTNo>0)
    ;
    IF (rOldTlColLen>=grTCLenOverSize)
      ;
      ;ueberlanges Wz in Sp
      bSpTlOverSize=TRUE
    ENDIF
  ENDIF
  ;
  IF (bHgTlOverSize)AND(bSpTlOverSize)
    iAlarmNo=AL_SpHgTlOverSize sAlarmParam="" SYG_RM[iSYGArea]=210.1
    GOTOF HandleAlarm
  ENDIF
  ;
  IF (bHgTlOverSize)OR(bSpTlOverSize)
    ;
    ;bei langem Werkzeug -> negative Drehrichtung DG und niedrige Drehzahl
    bTurnNeg=(bSpTlOverSize) bOldTlFast=FALSE
  ENDIF
ENDIF

;-[WM286,WM307]--220.0--Positionen-
;---------------------------------
IF (bDGIsNcAxis)
  ;
  IF (bTurnNeg)
    ;
    ;Drehrichtung negativ
    rPrePosDGRot=360-grHomePosWindow rFirstPosDGRot=grHor2DGRot rNextPosDGRot=grHor1DGRot rEndPosDGRot=0.0 iHomeStatus='B11'
  ELSE
    ;
    rPrePosDGRot=grHomePosWindow rFirstPosDGRot=grHor1DGRot rNextPosDGRot=grHor2DGRot rEndPosDGRot=0.0
  ENDIF
ENDIF

;-[]-300.0--Halt vor WzW----
; Vor erster Achsbewegung
; ausgeloest durch Bediener:
; - Taste <Halt-vor-WzW>
; - Oeffnen der Magazintuere
;---------------------------
;
IF (bHoldBeforeTC)
  ;
  ;-300.1--Halt vor WzW------
  ; Warten bis X,Y,Z ihre
  ; Position angefahren haben
  ;--------------------------
  iErrCount=0
  REPEAT
    bTmp1=($AA_STAT[mcAxX]==4) bTmp2=($AA_STAT[mcAxY]==4) bTmp3=($AA_STAT[mcAxZ]==4) bEnabled=(bTmp1)AND(bTmp2)AND(bTmp3) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=300.1
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF (iErrCount>=iErrTimeShort)
        sAlarmParam="" sTmp=""
        IF (NOT bTmp1)
          sAlarmParam="X" sTmp=", "
        ENDIF
        IF (NOT bTmp2)
          sAlarmParam=sAlarmParam<<sTmp<<"Y" sTmp=", "
        ENDIF
        IF (NOT bTmp3)
          sAlarmParam=sAlarmParam<<sTmp<<"Z"
        ENDIF
        iAlarmNo=AL_WaitFor
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)
  ;
  REPEAT
    ;
    ;Wiederholen bis Halt bei WzW aufgeloest wird
    ;
    ;-300.2--Halt vor WzW---
    ; Warteposition Anfahren
    ;-----------------------
    ;
    M=$MCS_M_CODE_ALL_COOLANTS_OFF
    ;
    IF (iNewTNo>0)
      ;
      IF ($TC_MPP6[9998,mcLocSP]==iNewTNo)AND(($TC_TP8[iNewTNo] B_AND 'B110')=='B10')OR((ABS($AA_IM[mcAxX]-rPrePosX)<rc1x0mm)AND(ABS($AA_IM[mcAxY]-grTCposY)<rc1x0mm)AND(ABS($AA_IM[mcAxZ]-grTCposZ)<rc1x0mm))
        ;
        ;Keine Achsbewegung da:
        ;einzuwechselndes Wz bereits in der Spindel freigegeben und nicht gesperrt
        ;oder X,Y,Z stehen schon in (Vor)position
        ;
      ELSE
        ;
        ;Achsen in TC Vorposition Fahren
        IF ($AA_IM[mcAxZ]<grTcPosZMin)
          G153 Z=grTcPosZMin
        ENDIF
        IF ($AA_IM[mcAxZ]<grTcPosZ)
          G153  X=grTCPrePosX Y=grTcPosY Z=grTcPosZ
        ELSE
          G153  X=grTCPrePosX Y=grTcPosY
        ENDIF
        ;
        ;XYZS jetzt schon in TCPREPOS
        bMoveInTCPrePos=FALSE
      ENDIF
    ENDIF
    ;
    M5
    ;
    IF ($AA_IM[mcAxX]<=rCloseDoorX)AND(NOT mcbDBB_TCDoorClosed)
      ;
      ;-300.3--Halt vor WzW--------
      ; WzW-Tuere nicht geschlossen
      ; -> Schliessen
      ;----------------------------
      M_TcDoorClose1
    ENDIF
    ;
    ;-300.4-TestStop-
    ;----------------
    IF (bHBTCTestStop)AND(IN_TeststopReq)AND(giStepTestStop==0)
      ;Teststopp angefordert und noch nicht erfolgt
      Teststop(1)
    ENDIF
    ;
    ;Vollzugsmeldung an PLC -> ELSP aufheben mit Starttaste
    M_WaitDueStopAtTC1
    ;
    WHILE (bHoldBeforeTC)
      ;
      ;-300.5--Halt vor WzW-------
      ; Warten bis alle Aktionen,
      ; die Halt vor WzW anfordern
      ; abgeschlossen sind
      ;---------------------------
      G4 F=rWaitPLC
      bHoldBeforeTC=(bHoldBeforeTC_BBK)OR(IN_StopAtTc)OR(IN_ReqStopAtCycleEnd)OR(((IN_LoadFromMag)OR(IN_UnloadToMag)OR(OUT_LoadActiv))AND(NOT gbPrepActiv))
      ;
      IF ($AA_IM[mcAxX]<=rCloseDoorX)AND(NOT mcbDBB_TCDoorClosed)
        ;
        ;-300.6--Halt vor WzW--------
        ; WzW-Tuere nicht geschlossen
        ; -> Schliessen
        ;----------------------------
        M_TcDoorClose1
      ENDIF
      ;
      IF (bHoldBeforeTC_BBK)
        ;
        M0
        STOPRE
        ;
        ;Kein Reaktion mehr
        bHoldBeforeTC_BBK=FALSE gbPrevToBrokenInt=FALSE gbPrevToBroken=FALSE
      ENDIF
      ;
    ENDWHILE
    ;
    ;mind. 1 PLC-Zyklus, weil durch M_WaitDueStopAtTC1 IN_StopAtTc weggeht, aber
    ;kurz darauf z.B. sofort wieder kommt, weil Magazintuere (noch) offen
    ;
    G4 F=rWaitPLC
    ;
    bHoldBeforeTC=(IN_StopAtTc)OR(IN_ReqStopAtCycleEnd)OR(((IN_LoadFromMag)OR(IN_UnloadToMag)OR(OUT_LoadActiv))AND(NOT gbPrepActiv))
    ;
  UNTIL (NOT bHoldBeforeTC)
  ;
  ;-300.7--Halt vor WzW-
  ; Warten Ende
  ;---------------------
  IF (iNewTNo>0)
    ;
    IF (NOT $P_TOOLEXIST[iNewTNo])
      ;Wz wurde entladen oder aus Wz-Liste entfernt
      MakeAlarmparam(sAlarmParam,sTName,<<iDuploNo)
      iAlarmNo=AL_TlNotFound SYG_RM[iSYGArea]=300.7
      GOTOF HandleAlarm
    ENDIF
  ENDIF
  ;
  ;Status Aktualisierung
  rActZPos=$AA_IM[mcAxZ] rActYPos=$AA_IM[mcAxY] rActXPos=$AA_IM[mcAxX] iClampStatus=$A_DBB[0] bRelPrep_Clmp_UnClmp=(SYG_IM[iSYG+3]==1) bRelPrePosDGRot=FALSE
  ;
  ;-300.8--Halt vor WzW----------
  ; Ueberpruefung der WZ Klemmung
  ;------------------------------
  IF (iOldTNo>0)
    IF ((iClampStatus B_AND 'B100')<>0)
      ;lt. WzV Wz in Spindel, aber <Spindel geloest>
      M_SpClampWithTool1
    ENDIF
    IF ((iClampStatus B_AND 'B10')<>0)
      ;lt. WzV Wz in Spindel, aber <Spindel gespannt ohne Werkzeug>
      iAlarmNo=AL_TInSpButSpClampedNoTool sAlarmParam="" SYG_RM[iSYGArea]=300.8
      GOTOF HandleAlarm
    ENDIF
    IF ((iClampStatus B_AND 'B1')==0)
      ;Sp nicht <gespannt mit Wz>
      iAlarmNo=AL_ClampSp
      GOTOF HandleAlarm
    ENDIF
  ENDIF
  ;
  ;-300.9--Halt vor WzW------
  ; M5 -> Spindel neu richten
  ;--------------------------
  SPOSA=ACP(rTcSPosRes)
  ;
ENDIF

;-[]-400.0--BBK_2---------------------
; Beauftragung der Bohrerbruchpruefung
;-------------------------------------
;
IF (bTlCheckOn)AND(iOldTNo>0)
  ;
  iMeasCutNo=RTOI($TC_TPC2[iOldTNo]) bCheck=FALSE
  IF (iMeasCutNo>0)AND($P_TOOLND[iOldTNo]>=iMeasCutNo)
    ;
    ;Anwahl <Pruefen>
    IF (gbTMIsHHD)
      bCheck=((RTOI($TC_DPC1[iOldTNo,iMeasCutNo]) B_AND 'B1')<>0)
    ELSE
      bCheck=((RTOI($TC_TPC1[iOldTNo]) B_AND 'B1')<>0)
    ENDIF
  ENDIF
  ;
  IF (bCheck)
    ;
    ;<nur pruefen> oder <pruefen/vermessen>, wobei Wz bereits vermessen ist -> auf Bohrerbruch pruefen, Kenndaten dafuer in GUD's ablegen
    ;
    IF (NOT bOldIsManTl)
      ;
      ;-400.1--BBK_2------------
      ; Warten, bis laufende BBK
      ; im Kanal 2 beendet ist
      ;-------------------------
      iErrCount=0 bEnabled=TRUE
      WHILE (giToBreakCtrlState<>0)
        G4 F=rWaitShort
        iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=400.1
        IF (iErrCount>iErrTimeShort)AND(bEnabled)
          ;Meldung erst nach Wartezeit ausgeben
          MSG(MSG_ToBreakCtrlRunning)
          bEnabled=FALSE
        ENDIF
      ENDWHILE
      ;
      IF (NOT bEnabled)
        MSG("")
      ENDIF
      ;
      IF (NOT gbToCheckAtTC)AND(iToDo<>mcTaskLoad)
        ;
        ;-400.2--BBK_2-----------------
        ; - hauptzeitparallele Pruefung
        ; - Ausfuehrung Kanal 2
        ; - kein Warten im TC
        ;------------------------------
        gbPrevToBrokenInt=FALSE bCheckOldTl=FALSE giToBreakCtrlState=1 giToNoProb=iOldTNo
      ELSE
        ;
        ;Pruefen und Warten im TC
        ;
        gbLastToBroken=FALSE bCheckOldTl=TRUE
        ;
        IF (bMagIsPickUpDisk)
          ;
          ;-400.3--BBK_2-------
          ; Ausfuehrung Kanal 1
          ;--------------------
          giToBreakCtrlState=0 giToNoProb=0
        ELSE
          ;
          ;-400.4--BBK_2-------
          ; Ausfuehrung Kanal 2
          ; Abfrage im TCWP
          ;--------------------
          giToBreakCtrlState=1 giToNoProb=iOldTNo
        ENDIF
      ENDIF
    ELSE
      ;
      ;HandWz: wird nach Ausschleusen aus SP wieder an den Bediener
      ;zurueckgegeben, insofern ist es anschliessend nicht mehr im Magazin
      ;und kann auch nicht mehr (asynchron) geprueft werden
    ENDIF
  ENDIF
ENDIF

;-[]-490.0-WzW-
; WzW Start
;--------------
gbTcActive=TRUE

;-[]-500.0--SpWz ist HandWz-
;---------------------------
;
IF (bOldIsManTl)AND(iOldTNo>0)AND((iToDo==mcTaskPrep)OR(iToDo==mcTaskAS_T0))
  ;
  MsgBox(T_UnLoadTl<<": T = "<<$TC_TP2[iOldTNo]<<" - "<<T_Started,"CLEAR")
  ;
  G0 G17 G40 G60 G90 G94
  ;
  ;kein Oeffnen der WzW-Tuere notwendig,
  ;kein Warten auf Vollzug der Wz-Vorbereitung notwendig,
  ;keine Abfrage, ob HNT Kanal 2 angefordert, notwendig
  ;
  ;X in Vorposition, sonst positioniert Spindel nicht
  IF (($AA_IM[mcAxX]-grTCPrePosX)<rc0x5mm)
    ;
    IF (NOT mcbDBB_TCDoorOpen)
      M_TcDoorOpen1
    ENDIF
    ;
    WHENEVER (NOT mcbDBB_TCDoorOpen) DO $AC_OVR=0
    G153 G603 X=grTCPrePosX-rc0x5mm
  ENDIF
  ;
  ;Genauhalt fuer die folgenden Bewegungen
  G601
  ;
  ;Kuehlmittel aus, aber ohne <WzW-Tuere oeffnen>
  M=$MCS_M_CODE_ALL_COOLANTS_OFF
  ;
  ;Z-Achse wegfahren
  IF ($AA_IM[mcAxZ]<grTcPosZMin)
    ;
    ;vor dem WzW erst mit Z-Achse wegfahren (sonst Kollision Y-Achse mit Palettenauflage)
    G153 Z=grTcPosZMin
  ENDIF
  ;
  ;Z,X,Y in Hand-Beladeposition fahren simultan zur Achsbewegung WzW-Tuere schliessen
  WHEN (($VA_IM[mcAxX]-rCloseDoorX)<rc0x5mm) DO M_TcDoorClose0
  IF ((bMoveXZ_B)OR(bMoveXZB))AND(bZAxReq)
    G153 X=grToLoadPosX Y=grToLoadPosY Z=rProgZPos SPOS=ACP(rTcSPosRes)
    rActXPos=grToLoadPosX rActYPos=grToLoadPosY rActZPos=rProgZPos bZAxReq=FALSE
  ELSE
    IF (bMoveZ_XB)OR(bMoveZ_X_B)
      IF (bZAxReq)
        G153 Z=rProgZPos
        rActZPos=rProgZPos bZAxReq=FALSE
      ENDIF
      G153 X=grToLoadPosX Y=grToLoadPosY SPOS=ACP(rTcSPosRes)
    ELSE
      G153 X=grToLoadPosX Y=grToLoadPosY SPOS=ACP(rTcSPosRes)
      rActXPos=grToLoadPosX rActYPos=grToLoadPosY
      IF (bZAxReq)
        G153 Z=rProgZPos
        rActZPos=rProgZPos bZAxReq=FALSE
      ENDIF
    ENDIF
  ENDIF
  ;
  ;-500.1--SpWz ist HandWz-
  ; B auf rProgBPos, wenn
  ; Z auf rProgZPos
  ;------------------------
  IF (bBAxReq)
    iErrCount=0
    REPEAT
      bEnabled=($AA_STAT[mcAxB]==4) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=500.1
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam="B"
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    EXECSTRING("ID=SyncID_TC+2 WHEN ((rProgZPos-$VA_IM[mcAxZ])>=rc0x5mm) DO FA[mcAxB]=rFeedB POS[mcAxB]="<<sModeB<<"(rProgBPos)")
    bBAxReq=FALSE
  ENDIF
  ;
  ;-500.2--SpWz ist HandWz---
  ; Warten auf Sp in Position
  ;--------------------------
  WAITS(iSpNo)
  STOPRE
  ;
  ;Lageregelung aus
  SPCOF
  ;
  ;-500.3--SpWz ist HandWz-
  ; Teststop
  ;------------------------
  IF (IN_TeststopReq)
    Teststop(1)
  ENDIF
  ;
  ;-500.4--SpWz ist HandWz--
  ; Auforderung Wz Entnehmen
  ;-------------------------
  ;
  OUT_LoadUnloadActive=TRUE
  ;
  sAux="giNextTlInSp=iNewTNo giSyncTC="
  IF (iTaskId==2)
    sAux=sAux<<"21"
  ELSE
    sAux=sAux<<"22"
  ENDIF
  IF (bMagIsPickUpDisk)
    sAux=sAux<<" grSyncPickupDrop=0"
  ENDIF
  EXECSTRING(sAux)
  ;
  IF (gbPLCSimActive)
    ;
    ;Damit die PLC Simulation den passenden Spannstatus erzeugt
    CANCEL(SyncID_TCLoad)
    ID=SyncID_TCLoad EVERY (($A_DBB[0] B_AND 'B111')==0) DO OUT_ToolInSp=NOT OUT_ToolInSp
  ENDIF
  ;
  MsgBox(T_UnLoadTl<<": T = "<<$TC_TP2[iOldTNo]<<" - "<<T_GetTlOutOfSp,"ID=1 M288","(($A_DBB[0] B_AND 2)<>0)")
  ;
  CANCEL(SyncID_TCLoad)
  ;
  ;-500.5--SpWz ist HandWz--------------------
  ; verhindern, dass WzW-FC8-Quittierung
  ; die (noch) laufende Wz-Vorbereitung stoert
  ;-------------------------------------------
  MsgBox(MSG_WaitForPrepEnd,"RESET ErrTime="<<giMaxPrepTime,"(gbPrepActiv)AND((NOT gbPrepDone)OR(gbPrepEnd))")
  ;
  ;-500.6--SpWz ist HandWz---
  ; SpWz entnommen quittieren
  ;--------------------------
  IF (iToDo==mcTaskPrep)
    ;
    IF (iNewTNo>0)
      ;
      ;Neues Werkzeug folgt -> Vorab Quittiern
      iState=105
    ELSE
      ;
      ;Kein neues Werkzeug -> Fertig
      iState=1
    ENDIF
    ;
    IF (bPutM206)
      M206
      bPutM206=FALSE
    ENDIF
    ;
    ;WzW + Quittierung AltWz / SP->Beladestelle_Hand
    ToAckn(TRUE,iTaskId,iTaskIdNo,0,iOldTNo,-1,-1,9999,1,iState)
  ELSE
    ;
    ;Spindel asynchron leerfahren / SpWz SP->Beladestelle_Hand
    ToAckn(TRUE,iTaskId,iTaskIdNo,iOldTNo,0,9999,1,9998,mcLocSP,1)
  ENDIF
  iOldTNo=0 bOldIsManTl=FALSE giSyncTC=0
  ;
  ;-500.8--SpWz ist HandWz-
  ; Aktualisierung SpWZ
  ;------------------------
  SpTlData(1,0)
  ;
  ;nicht mehr Pruefen, da Wz entnommen
  bCheckOldTl=FALSE
  ;
  ;-501.0--SpWz ist HandWz----------------
  ; Neues Wz HandWz -> Wz Beladen beim WzW
  ;---------------------------------------
  ;
  IF (iNewTNo>0)AND(bNewIsManTl)
    ;
    ;-501.1--SpWz ist HandWz-
    ; Auforderung Sp Beladen
    ;------------------------
    ;
    OUT_LoadUnloadActive=TRUE
    ;
    IF (bMagIsPickUpDisk)
      giSyncTC=11 giNextTlInSp=iNewTNo grSyncPickupDrop=0
    ELSE
      giSyncTC=11 giNextTlInSp=iNewTNo
    ENDIF
    ;
    IF (gbPLCSimActive)
      ;
      ;Damit die PLC Simulation den passenden Spannstatus erzeugt
      CANCEL(SyncID_TCLoad)
      ID=SyncID_TCLoad EVERY (($A_DBB[0] B_AND 'B111')==0) DO OUT_ToolInSp=NOT OUT_ToolInSp
    ENDIF
    ;
    MsgBox(T_LoadTl<<": T = "<<$TC_TP2[iNewTNo]<<" - "<<T_PutTlIntoSp,"ID=1 M286","(($A_DBB[0] B_AND 7)==1)")
    ;
    CANCEL(SyncID_TCLoad)
    ;
    ;-501.2--SpWz ist HandWz-
    ; Sp Beladen quittieren
    ;------------------------
    IF (bPutM206)
      M206
      bPutM206=FALSE
    ENDIF
    ;
    ;WzW + Quittierung NeuWz Beladestelle_Hand->Sp
    ToAckn(TRUE,iTaskId,iTaskIdNo,iNewTNo,0,9998,mcLocSP,-1,-1,1)
    ;
    ;HandWz kann kein FestplatzWz sein
    $TC_TP8[iNewTNo]=($TC_TP8[iNewTNo] B_AND (B_NOT 'H40')) giSyncTC=0 giNextTlInSp=-1
    ;
    ;-501.4--SpWz ist HandWz-
    ; Aktualisierung SpWZ
    ;------------------------
    SpTlData(1,iNewTNo)
    ;
    ;bewusst hinter <OUT_ToolInSp=..>
    OUT_LoadUnloadActive=FALSE
    ;
    ;-501.5--SpWz ist HandWz--------
    ; altes und neues Wz sind HandWz
    ; -> kein WzW mehr erforderlich
    ; Sp steht im Arbeitsraum
    ;-------------------------------
    bNoRealTC=TRUE
    ;
    GOTOF FINISH_TC
    ;
  ELSE
    ;
    ;NeuWz ist kein HandWz
    ;
    IF (iNewTNo<=0)
      ;
      ;-502.0--SpWz ist HandWz-
      ; Kein neues Werkzeug
      ; -> kein WzW
      ;------------------------
      bNoRealTC=TRUE
      GOTOF FINISH_TC
    ENDIF
    ;
    ;-503.0--SpWz ist HandWz-
    ; zunaechst in PREPOS,
    ; dann NeuWZ einwechseln
    ;------------------------
    bMoveInTCPrePos=TRUE
    ;
  ENDIF
ENDIF

;-600.0--Vorbereitung WzW----
; Ueberpruefung der Moeglichkeit
; eines verkuerzten WzW
;-------------------------------
;
bLubRequested=(($A_DBB[77] B_AND 'H1')<>0) bTeststopReq=(IN_TeststopReq)
;
IF (iToDo<>mcTaskPrep)OR(bNewIsManTl)OR(bNoRealTC)OR(bTestStopReq)OR(bLubRequested)OR(gbTlFirstMach)OR(bNewTlNotMeasured)OR(sMissingTl<>"")OR(bOffsNotValid)OR(bWaitAPC)OR(bMoveAPC)
  bReqPosAfterTC=FALSE bPosAfterTC=FALSE
ELSE
  bPosAfterTC=bReqPosAfterTC
ENDIF
;
IF (iNewTNo>0)AND(bNewIsManTl)AND(iOldTNo<=0)
  ;
  ;-601.0--Vorbereitung WzW----------
  ; Ist das NeuWz ein HandWz und die
  ; Sp leer ist, direkt NeuWz Beladen
  ;----------------------------------
  GOTOF GET_MAN_TOOL
ENDIF
;
IF (bWaitDoorCoolant)
  ;
  ;-602.0--Vorbereitung WzW-
  ; wenn Spindel steht
  ; (Kuehlmittel ausblasen)
  ;------------------------
  ID=SyncID_TC+6 WHEN (ABS($AA_S[iSpNo])<rcMinSpSpeed) DO M=QU(MQ_TCDoorOpen)
ELSE
  ;
  ;-602.1--Vorbereitung WzW----------
  ; Wenn eventuell wieder geschlossen
  ;----------------------------------
  M=QU(MQ_TCDoorOpen)
ENDIF

;-[]-610.0--WzGewicht-
; NeuWz
;---------------------
OUT_TcActive=TRUE bNewTurnDGFast=TRUE
;
IF (iNewTNo>0)AND(NOT bNewIsManTl)
  ;
  ;Gewicht neues Werkzeug
  IF (gbTMIsHHD)
    ;
    rWNewTl=$TC_TPC3[iNewTNo] rNewTlJ=0
    rTmp1=$TC_TPC11[iNewTNo]*$TC_TPC12[iNewTNo]*$TC_TPC12[iNewTNo]
    rTmp2=MAXVAL($TC_TPC16[iNewTNo]-$TC_TPC11[iNewTNo],0)*$TC_TPC17[iNewTNo]*$TC_TPC17[iNewTNo] rTmp3=rTmp1+rTmp2
    rTmp4=((0.5*$TC_TPC11[iNewTNo]*rTmp1)+((0.5*MAXVAL($TC_TPC16[iNewTNo]-$TC_TPC11[iNewTNo],0)+$TC_TPC11[iNewTNo])*rTmp2))/(1000*rTmp3)
  ELSE
    rWNewTl=$TC_TPC4[iNewTNo] rNewTlJ=0 rTmp4=0.5*$TC_TPC7[iNewTNo]/1000
  ENDIF
  ;
  IF (rWNewTl>1000)
    rNewTlJ=RTOI(rWNewTl/1000) rWNewTl=(rWNewTl MOD 1000)
  ENDIF
  ;
  ;Fuer Span zu Span Zeitmessung
  IF (giSetHeavyTlDg==1)AND(rWNewTl<grMidTlDg)
    rWNewTl=grMidTlDg
  ELSE
    IF (giSetHeavyTlDg==2)AND(rWNewTl<grHeavyTlDg)
      rWNewTl=grHeavyTlDg
    ENDIF
  ENDIF
  ;
  IF (rWNewTl<=0.0)OR(rWNewTl>=grHeavyTlDg)
    ;
    ;Gewicht unbekannt -> DG langsam Drehen
    bNewTurnDGFast=FALSE bNewTlFast=FALSE
  ELSE
    ;
    IF ($P_TOOLND[iNewTNo]>0)
      ;
      ;Option WzSchutz
      bSelected=($TC_TP_MAX_ACC[iNewTNo]>0)
      IF (NOT gbTMIsHHD)
        iTlOpt=RTOI($TC_TPC1[iNewTNo]) bSelected=(bSelected)OR((iTlOpt B_AND 'H400')<>0)
      ENDIF
      ;
      ;Messtaster (WzTyp 7xx) oder Option WzSchutz -> - Aktivieren WzSchutz -> DG Langsam Drehen
      IF (bSelected)OR(($TC_DP1[iNewTNo,1] DIV 100)==7)
        rNewTlACC=grAccValLow bNewTurnDGFast=FALSE bNewTlFast=FALSE
      ENDIF
    ENDIF
  ENDIF
  ;
  IF (rWNewTl>grTlHolderWeight)
    ;
    ;Annahmen:Das Gewicht ist gleichverteilt auf der WzLaenge.
    ;Ueberlagerung von Gewichtund Traegheitskraft in X
    ;
    IF (rNewTlJ==0)
      ;
      IF (bRelMoveUnClmp)
        rNewTlJ=rTmp4*(rWNewTl-grTlHolderWeight)*SQRT((9810*9810)+(rMaxAccelX*rMaxAccelX))/1000
      ELSE
        rNewTlJ=rTmp4*(rWNewTl-grTlHolderWeight)*9.81
      ENDIF
    ENDIF
    ;
    IF (rNewTlJ>grTlTiltTorqueSp)
      bNewTlFast=FALSE
    ENDIF
  ENDIF
  ;
  IF (iNewTlSpecType>0)
    bNewTlFast=FALSE
  ENDIF
ENDIF
bTurnDgFast=(bOldTurnDgFast)AND(bNewTurnDgFast)

;-[MTC]-620.0--DG Feed-
; Drehgeschwindigkeit
; fuer Werkzeugwechsler
;----------------------
IF (bDGIsMTC)AND(gbDGWithEncoder)
  ;
  IF (bTurnDgFast)
    ;
    rWTl=MAXVAL(rWOldTl,rWNewTl) rTmp=1-grTlTiltFactorDG*MAXVAL(((MAXVAL(rOldTlJ,rNewTlJ)-grTlTiltTorqueDG)/grTlTiltTorqueDG),0)
    rWDiff=rWNewTl-rWOldTl
    IF (rWTl>grLightTlDg)
      IF (rWTl>grMidTlDg)
        rDgVeloFact=ROUND((MAXVAL(1-((rWTl-grMidTlDg)/(grMaxTlDg-grMidTlDg)),0)*0.25*1000))
      ELSE
        rDgVeloFact=ROUND((MAXVAL(1-0.75*((rWTl-grLightTlDg)/(grMidTlDg-grLightTlDg)),0)*1000))
      ENDIF
      rDgVeloDiff = 1.0
      IF ((ABS(rWDiff))>grMaxDiffTlDg)
        rDgVeloDiff=ROUND((MAXVAL(1-((ABS(rWDiff)-grMaxDiffTlDg)/(grMaxTlDg-grMaxDiffTlDg)),0)))
      ENDIF
      iH80=ROUND(rDgVeloFact*rDgVeloDiff*rTmp)
    ELSE
      iH80=(1*1000)
    ENDIF
  ELSE
    iH80=0
  ENDIF
  ;
  ;Zwischenkreis ein FU - DG
  M=QU(126)
ENDIF

;-[]-650.0--TCPREPOS-
;--------------------
;
;=============
FINISH_PREPOS:
;=============
;
;-[]-650.1--TCPREPOS-----
; Warten -> wenn Z faehrt
;------------------------
IF (bMoveZ_XB)OR(bMoveZ_X_B)
  ;
  iErrCount=0
  REPEAT
    bEnabled=($AA_STAT[mcAxZ]==4) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=650.1
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam="Z"
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)
ENDIF
;
;-650.2--TCPREPOS--------
; X,Y,Z auf (Vor)Position
;------------------------
IF (bMoveInTCPrePos)
  ;
  ;vor dem WzW erst mit Z-Achse wegfahren sonst Kollision Y-Achse mit Palettenauflage
  IF (bMoveZInSafePos)
    G603 Z=grTcPosZMin
    rActZPos=grTcPosZMin
  ENDIF
  ;
  ;-650.3--TCPREPOS-------
  ; Umschaltung Endlagen X
  ;-----------------------
  IF (rPrePosX>=rLimitPlusX)
    ;
    iErrCount=0
    REPEAT
      bEnabled=(($A_DBB[7] B_AND 'B1')<>0) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=650.3
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam="LIMIT X"
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
  ENDIF
  ;
  ;Alle Achsen auf notwendige Position Fahren
  IF ((bMoveXZ_B)OR(bMoveXZB))AND(bZAxReq)
    G601 X=rPrePosX Y=grTcPosY Z=rProgZPos
    bZAxReq=FALSE
  ELSE
    IF ((bMoveZ_XB)OR(bMoveZ_X_B))AND(bZAxReq)
      G602 Z=rProgZPos
      bZAxReq=FALSE
    ENDIF
    G601 X=rPrePosX Y=grTcPosY
  ENDIF
  ;
  SPOS=ACP(rTcSPosRes)
ENDIF
;
;-651.0--TCPREPOS--------------
; Nicht gestartete Positionier-
; anforderungen nachholen
;------------------------------
IF (bBAxReq)OR(bZAxReq)
  ;
  iErrCount=0
  REPEAT
    bTmp1=(($AA_STAT[mcAxZ]==4)OR(NOT bZAxReq)) bTmp2=(($AA_STAT[mcAxB]==4)OR(NOT bBAxReq)) bEnabled=(bTmp1)AND(bTmp2) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=651.0
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF iErrCount>=iErrTimeShort
        sAlarmParam="" sTmp=""
        IF (NOT bTmp1)
          sAlarmParam="Z" sTmp=", "
        ENDIF
        IF (NOT bTmp2)
          sAlarmParam=sAlarmParam<<sTmp<<AXSTRING(mcAxB)
        ENDIF
        iAlarmNo=AL_WaitFor
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)
  ;
  ;-651.1--TCPREPOS-
  ; Z,B In Position
  ;-----------------
  IF (bZAxReq)
    ID=SyncID_TC+1 WHEN ($AA_STAT[mcAxZ]==4)AND($VA_IM[mcAxX]>=grTCPrePosX) DO FA[mcAxZ]=rFeedZ POS[mcAxZ]=rProgZPos
    bZAxReq=FALSE
  ENDIF
  ;
  IF (bBAxReq)
    IF (bMoveXZ_B)OR(bMoveX_Z_B)OR(bMoveZ_X_B)
      sAux="($VA_IM[mcAxX]>=grTCPrePosX)AND($VA_IM[mcAxZ]>=(rProgZPos-rc0x5mm))"
    ELSE
      IF (bMoveZ_XB)
        sAux="($VA_IM[mcAxZ]>=(rProgZPos-rc0x5mm))"
      ELSE
        sAux="((bMoveXB)OR($VA_IM[mcAxX]>=grTCPrePosX))"
      ENDIF
    ENDIF
    EXECSTRING("ID=SyncID_TC+2 WHEN ($AA_STAT[mcAxB]==4)AND"<<sAux<<" DO FA[mcAxB]=rFeedB POS[mcAxB]="<<sModeB<<"(rProgBPos)")
    bBAxReq=FALSE
  ENDIF
ENDIF

;-[]--660.0--SonderWz_2-
;-----------------------
IF (gbSpecTlInSp)
  ;
  ;Einstechkopf Kalibrieren
  ;
  IF (bMoveZ_XB)OR(bMoveZ_X_B)
    ;
    ;Z in TCPos dann kalibrieren
    SpecTlMan(2,rProgZPos)
  ELSE
    ;
    ;keine Beachtung von Z
    SpecTlMan(2)
  ENDIF
  ;
  IF (giResult<>0)
    iAlarmNo=giResult sAlarmParam=gsResult SYG_RM[iSYGArea]=660.0
    GOTOF HandleAlarm
  ENDIF
ENDIF

;-670.0--TCPREPOS-
; Start Schmieren
;-----------------
IF (bLubRequested)AND(iToDo==mcTaskPrep)AND(NOT bLubActive)
  M=QU(157) ;ohne ELSP
  bLubActive=TRUE
ENDIF

;-[]-700.0--TCPOSX_1-
; Wenn zuerst auf
; Bereitstellung durch
; Kanal 2 gewartet wird
;----------------------
IF (bPrepBeforeTCPosX) GOTOF WAIT_PREP
;
;==============
MOVE_IN_TCPOSX:
;==============
;
;-[DISK]-701.0--TCPOSX_1-
;------------------------
;
IF (bMagIsPickUpDisk)
  ;
  SYG_IM[iSYG+2]=0 mcDBB_StepTC=iHomeStatus ; TC gestartet
  ;
  IF (iOldTNo>0)
    ;
    ;-701.1--TCPOSX_1---------
    ;
    ; SpWz Entladen:
    ;
    ; Sp gespannt mit Wz und
    ; Scheibe Vorn
    ; -> Hub zurueck, damit Wz
    ; in Scheibe fahren kann
    ;-------------------------
    ;
    ;Scheibe Hinten fuer Folgende
    IF (bRelAuxSw)
      iAuxAdr=68 iAuxMask='B1100' iAuxResult='B100'
    ELSE
      iAuxAdr=1 iAuxMask='B11' iAuxResult='B1'
    ENDIF
    ;
    CANCEL(SyncID_TC+5)
    ID=SyncID_TC+5 WHEN (($A_DBB[0] B_AND 'B101')=='B1')AND(($A_DBB[1] B_AND 'B10')<>0) DO M=QU(MQ_DiskRet)
    ;
  ELSE
    ;
    IF (iNewTNo>0)
      ;
      ;-701.2--TCPOSX_1-----------
      ;
      ; Leere Sp Beladen:
      ;
      ; Sp gespannt ohne Wz
      ; und Scheibe Hinten
      ; -> Hub Vor, damit Sp hinter
      ; neues Wz fahren kann
      ;----------------------------
      ;
      ;Scheibe Vorn fuer Folgendes
      IF (bRelAuxSw)
        iAuxAdr=68 iAuxMask='B1100' iAuxResult='B1000'
      ELSE
        iAuxAdr=1 iAuxMask='B11' iAuxResult='B10'
      ENDIF
      ;
      CANCEL(SyncID_TC+5)
      ID=SyncID_TC+5 WHEN (($A_DBB[0] B_AND 'B110')=='B10')AND(($A_DBB[1] B_AND 'B1')<>0) DO M=QU(MQ_DiskAdv)
      ;
    ENDIF
  ENDIF
ENDIF

;-702.0-[WM286,WM307,MTC]-TCPosX_1-------
; Warten bis
; - WzW Tuere(n) offen
; - Y innerhalb rRelXByY
; - zusaetzlich Planzugeinheit in TCPosFH
;----------------------------------------
;
IF (bDGIsNCAxis)OR((bDGIsMTC)AND(bRelExitXY))
  ;
  ;Einfahren in den Magazinraum, ohne dass Y in WzW Postion ist
  ;(Nicht bei Scheibe, da Kollision mit NachbarWz'en moeglich)
  ;
  iErrCount=0 rActYPos=$VA_IM[mcAxY] SYG_RM[iSYGArea]=702.0
  REPEAT
    ;
    ;Nur wenn X nicht in der Bremsrampe ist oder die Achse steht und die sonstigen Freigabebedingungen sind erfuellt,
    ;geht's weiter. Sonst wird im Folgenden gewartet, bis X die Vorposition erreicht hat.
    ;Wird hier nicht gewartet, so passen die Zeitschaetzungen nicht (NCDG), da sie von falschen Restwegen ausgehen.
    ;
    ;Wenn die Achse "laengere Zeit" bremst, uebernimmt sie den Fahrbefehl aus der folgenden SyncAkt erst, wenn sie im Positionsfenster ist.
    WHEN (TRUE) DO SYG_RM[iSYG+11]=ABS($AA_VACTM[mcAxX]) SYG_BM[iSYG+6]=((SYG_RM[iSYG+11]/MAXVAL(rFeedXPrepos,0.0001)>0.8)OR(SYG_RM[iSYG+11]<rFeedX*0.1))
    ;
    IF (bRelExitXY)
      rTmp=ABS(rActYPos-$VA_IM[mcAxY])*3*rIPO/(rWaitShort+rIpo) rActYPos=$VA_IM[mcAxY] bTmp1=(mcbDBB_TCDoorOpen) bTmp2=(ABS(grTCPosY-rActYPos)<=(rRelXByY+rTmp)) bEnabled=(bTmp1)AND(bTmp2)AND(SYG_BM[iSYG+6])AND(SYG_BM[iSYG+7]) iErrCount=(iErrCount+SYG_IM[iSYGInc])
    ELSE
      bTmp1=(mcbDBB_TCDoorOpen) bTmp2=(ABS(grTCPosY-$VA_IM[mcAxY])<=rRelXByY) bEnabled=(bTmp1)AND(bTmp2)AND(SYG_BM[iSYG+6])AND(SYG_BM[iSYG+7])
    ENDIF
    ;
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF (iErrCount>=iErrTimeShort)
        sAlarmParam="" sTmp=""
        IF (NOT bTmp1)
          FileRead("TCDOOR_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
          sAlarmParam=sAux sTmp=", "
        ENDIF
        IF (NOT bTmp2)
          sAlarmParam=sAlarmParam<<sTmp<<"Y" sTmp=", "
        ENDIF
        IF (NOT SYG_BM[iSYG+7])
          sAlarmParam=sAlarmParam<<sTmp<<AXSTRING(mcAxFH)
        ENDIF
        iAlarmNo=AL_WaitFor
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)
ENDIF

;-[MTC,DISK]-703.0--TCPOSX_1-
;
; - WzW Tuer auf
; - Y-Achse in (...)Pos
; - Sp gerichtet
;
; - Scheibe
;   - in Teilungsposition
;   - Scheibenhub Vorn/Hinten
; - Sonderspannzange
;   - Sp geloest, wenn gefordert
; - PlanzugEinheit in TCPosFH
;
; -> X in WzW-Position
;---------------------------
;
IF (bDGIsMTC)OR(bMagIsPickUpDisk)
  ;
  CANCEL(SyncID_TC+3,SyncID_TC+7,SyncID_TC+8,SyncID_TC+9,SyncID_TC+10,SyncID_TC+11)
  ;
  ;-703.1--TCPOSX_1-
  ; X -> TCPOSX
  ;-----------------
  ;
  IF(bMagIsPickUpDisk)
    ID=SyncID_TC+3 WHEN ($AA_STAT[mcAxV1]==4)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult)AND(mcbDBB_TCDoorOpen)AND(ABS($VA_IM[mcAxY]-grTcPosY)<=rTCInPosCoarse)AND(mcbSpInTCPosCoarse)AND(SYG_BM[iSYG+7]) DO FA[mcAxX]=rFeedX POS[mcAxX]=grTcPosX SYG_IM[iSYG+1]=4 SYG_RM[iSYG]=$VA_VACTM[mcAxX] SYG_BM[iSYG+3]=TRUE
  ELSE
    ID=SyncID_TC+3 WHEN (mcbDBB_TCDoorOpen)AND(ABS($VA_IM[mcAxY]-grTcPosY)<=rTCInPosCoarse)AND(mcbSpInTCPosCoarse)AND(OUT_DGRotInBasePos)AND(SYG_BM[iSYG+7]) DO FA[mcAxX]=rFeedX POS[mcAxX]=grTcPosX SYG_IM[iSYG+1]=4 SYG_RM[iSYG]=$VA_VACTM[mcAxX] SYG_BM[iSYG+3]=TRUE
  ENDIF
  ;
  ;aktuelle Geschwindigkeitsaenderung / Loeszeit aktualisieren
  CANCEL(SyncID_TC+7)
  ID=SyncID_TC+7 DO SYG_RM[iSYG+1]=$VA_VACTM[mcAxX]-SYG_RM[iSYG] SYG_RM[iSYG]=$VA_VACTM[mcAxX] SYG_RM[iSYG+5]=MAXVAL((SYG_RM[iSYG+5]-rIPO),rIPO)
  ;
  IF (NOT bCleanSp)AND(NOT bWaitDoorCoolant)
    ;
    IF (bRelSpPosX)
      ;
      ;-703.2--TCPOSX_1------------------
      ; Sp darf noch hinter Vorposition X
      ; gerichtet werden (rSpPosX)
      ; -> Vorstart der X-Achse
      ;----------------------------------
      ;
      ;Vorschub aus aktueller Drehzahl [und Loeszeit] ermitteln
      IF (bRelMoveUnClmp_U)AND(bOldTlFast)
        ;Beruecksichtigung der Loeszeit
        rTmp=grSpUnClmpTimeC rTmp1=1
      ELSE
        ;Keine Beachtung der SpWz Klemmung
        rTmp=0 rTmp1=0
      ENDIF
      ;
      IF (bMagIsPickUpDisk)
        ID=SyncID_TC+8 WHEN ($AA_STAT[mcAxV1]==4)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult)AND(mcbDBB_TCDoorOpen)AND(SYG_IM[iSYG+1]==1)AND(ABS($VA_IM[mcAxY]-grTcPosY)<=rRelXByY) DO SYG_IM[iSYG+1]=2 SYG_RM[iSYG]=60*ABS($VA_IM[mcAxX]-rSpPosX)/MAXVAL(SYG_RM[iSYG+5]-rIPO,rIPO)*rTmp1
      ELSE
        ID=SyncID_TC+8 WHEN (mcbDBB_TCDoorOpen)AND(SYG_IM[iSYG+1]==1)AND(ABS($VA_IM[mcAxY]-grTcPosY)<=rRelXByY)AND(OUT_DGRotInBasePos) DO SYG_IM[iSYG+1]=2 SYG_RM[iSYG]=60*ABS($VA_IM[mcAxX]-rSpPosX)/MAXVAL(SYG_RM[iSYG+5]-rIPO,rIPO)*rTmp1
      ENDIF
      ;
      IF (gbIsGearSpindle)AND(iActGearStep==2)
        ;
        IF (grTCSPOS2_k1>0)
          ID=SyncID_TC+9 WHEN($AA_STAT[mcAxSp1]<3)AND($AA_S[iSpNo]>grTCSPOS2_n2)AND(SYG_IM[iSYG+1]==2) DO SYG_RM[iSYG]=60*(ABS($VA_IM[mcAxX]-rSpPosX)/(rTmp+rWRedSp*(grTCSPOS2_k1*(grTCSPOS2_n2-grTCSPOS2_n1)/10000 + grTCSPOS2_k2*($AA_S[iSpNo]-grTCSPOS2_n2)/10000 + grTCSPOS2_tb)))
          ID=SyncID_TC+10 WHEN($AA_STAT[mcAxSp1]<3)AND($AA_S[iSpNo]<=grTCSPOS2_n2)AND(SYG_IM[iSYG+1]==2) DO SYG_RM[iSYG]=60*(ABS($VA_IM[mcAxX]-rSpPosX)/(rTmp+rWRedSp*(grTCSPOS2_k1*($AA_S[iSpNo]-grTCSPOS2_n1)/10000 + grTCSPOS2_tb)))
        ENDIF
      ELSE
        ;
        IF (grTCSPOS2_k1>0)
          ID=SyncID_TC+9 WHEN($AA_STAT[mcAxSp1]<3)AND($AA_S[iSpNo]>grTCSPOS1_n1)AND(SYG_IM[iSYG+1]==2) DO SYG_RM[iSYG]=60*(ABS($VA_IM[mcAxX]-rSpPosX)/(rTmp+rWRedSp*(grTCSPOS1_k1*(grTCSPOS1_n2-grTCSPOS1_n1)/10000 + grTCSPOS1_k2*($AA_S[iSpNo]-grTCSPOS1_n2)/10000 + grTCSPOS1_tb)))
          ID=SyncID_TC+10 WHEN($AA_STAT[mcAxSp1]<3)AND($AA_S[iSpNo]<=grTCSPOS1_n1)AND(SYG_IM[iSYG+1]==2) DO SYG_RM[iSYG]=60*(ABS($VA_IM[mcAxX]-rSpPosX)/(rTmp+rWRedSp*(grTCSPOS1_k1*($AA_S[iSpNo]-grTCSPOS1_n1)/10000 + grTCSPOS1_tb)))
        ENDIF
      ENDIF
      ;
      ;X faehrt in Spindelfreigabeposition
      ID=SyncID_TC+11 WHEN (SYG_IM[iSYG+1]==2)AND(SYG_RM[iSYG]>0) DO FA[mcAxX]=MINVAL(SYG_RM[iSYG],rFeedX) POS[mcAxX]=rSpPosX SYG_IM[iSYG+1]=4 SYG_BM[iSYG+3]=TRUE
    ELSE
      ;
      IF (bDGIsMTC)AND(bRelExitXY)
        ;
        ;-703.2--TCPOSX_1------------------------------
        ; DG und Sp in Position -> Vorstart der X-Achse
        ;----------------------------------------------
        ID=SyncID_TC+11 WHEN (SYG_IM[iSYG+1]==1)AND(OUT_DGRotInBasePos)AND(mcbSpInTCPosCoarse) DO FA[mcAxX]=rFeedX POS[mcAxX]=rWaitPosX SYG_IM[iSYG+1]=3 SYG_RM[iSYG]=$VA_VACTM[mcAxX] SYG_BM[iSYG+3]=TRUE
      ENDIF
    ENDIF
  ELSE
    ;
    IF (bCleanSp)
      ;
      ;-703.4--TCPOSX_1-
      ; Reinigungslauf
      ;-----------------
      ;
      M=QU(MQ_CleanTlOn)
      ;
      rTmp4=100*MINVAL(grCleanTlFeed/rFeedX,1)
      ;
      ID=SyncID_TC+11 WHENEVER (SYG_BM[iSYG+3])AND($AA_OVR[mcAxX]>rTmp4)AND($AA_IM[mcAxX]>=grCleanTlStart)AND($AA_IM[mcAxX]<=grCleanTlStart+grCleanTlWidth) DO $AA_OVR[mcAxX]=rTmp4
    ENDIF
  ENDIF
  ;
  IF ((NOT bRelMoveUnClmp)OR(NOT bOldTlFast)OR(NOT bExpectChange))AND((NOT bCheckOldTl)OR(bDGIsMTC))
    ;
    ;-704.0--TCPOSX_1------
    ; SpWz voreilend Loesen
    ;----------------------
    iErrCount=0 rPosWin=0 rPosTime=0 bEnabled=FALSE rTargetPos=grTCPosX
    IF (bRelPrep_Clmp_UnClmp)AND(bOldTlFast)AND(bRelPreUnCLmp)AND(rSpUnClmpTime>0)
      ;
      ;-704.1--TCPOSX_1-----------
      ; Warten bis X in Bremsrampe
      ; oder grob in TCPOSX
      ;---------------------------
      REPEAT
        bEnabled=(SYG_IM[iSYG+1]==4) rActVelo=ABS(SYG_RM[iSYG]) rActVeloDiff=SYG_RM[iSYG+1] rActPos=$VA_IM[mcAxX] rVelo=(rActVelo+ABS(rActVeloDiff))/60 iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=704.1
        IF (bEnabled)AND(rVelo>0)
          ;
          ;Abbremszeit X
          IF (rVelo<2*rMaxVjX)
            rActJerk=rMaxJerkX*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjX-rVelo)/(2*rMaxVjX))))rPosTime=2*SQRT(rVelo/rActJerk) rActTj=rPosTime*0.5
          ELSE
            rPosTime=rVelo/rMaxAccelX+rMaxTjX rActTj=rMaxTjX rActJerk=rMaxJerkX
          ENDIF
          ;
          ;Bremsrampe
          rPosWin=0.5*rVelo*rPosTime bEnabled=(rActVeloDiff<0)AND(ABS(rActPos-rTargetPos)<=rPosWin)
        ELSE
          bEnabled=FALSE
        ENDIF
        IF (NOT bEnabled)
          G4 F=rWaitShort
          IF (iErrCount>=iErrTimeShort)
            iAlarmNo=AL_WaitFor sAlarmParam="X"
            GOTOF HandleAlarm
          ENDIF
        ENDIF
      UNTIL (bEnabled)OR(ABS(rActPos-rTargetPos)<=rc1x0mm)
      ;
      CANCEL(SyncID_TC+7,SyncID_TC+8,SyncID_TC+9,SyncID_TC+10,SyncID_TC+11)
      ;
      ;Geschwindigkeitsfenster in dem geloest werden darf
      ;
      IF (bEnabled)
        ;
        ;Begrenzung auf Bremsrampe
        rTmp2=EXP(1/3*LN(6*rTCInPosCoarse/rActJerk))
        rSpUnClmpTime=MINVAL(rPosTime,rSpUnClmpTime+rTmp2)
        ;
        ;obere Grenze
        IF (rSpUnClmpTime<=rActTj)
          rSpVelo=0.5*rActJerk*rSpUnClmpTime*rSpUnClmpTime*60
        ELSE
          IF (rSpUnClmpTime<rPosTime-rActTj)AND(rActTj==rMaxTjX)
            rSpVelo=(rMaxAccelX*(rSpUnClmpTime-rMaxTjX)+rMaxVjX)*60
          ELSE
            rTmp=rPosTime-rSpUnClmpTime
            rSpVelo=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
          ENDIF
        ENDIF
        ;
        ;untere Grenze
        rTmp=rSpUnClmpTime-rSpVeloWindow
        IF (rTmp<=rActTj)
          rSpVeloMin=0.5*rActJerk*rTmp*rTmp*60
        ELSE
          IF (rTmp<rPosTime-rActTj)AND(rActTj==rMaxTjX)
            rSpVeloMin=(rMaxAccelX*(rTmp-rMaxTjX)+rMaxVjX)*60
          ELSE
            rTmp=rPosTime-rTmp
            rSpVeloMin=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
          ENDIF
        ENDIF
        ;
        ;Achse ist schon zu langsam
        IF (rActVelo<=rSpVeloMin)
          rSpVeloMin=0
        ENDIF
      ENDIF
    ENDIF
    ;
    ;-704.2--TCPOSX_1--------------
    ; (Voreilendes) Loesen
    ; - Sp gerichtet
    ; - keine Pruefung erforderlich
    ;   und
    ; - Ist in TCPOSX
    ;   oder
    ; - Wz ist "schnelles" Wz
    ; - befindet sich in Bremsrampe
    ; - Geschwindigkeit ist
    ;   im Bereich der
    ;   Schaltgeschwindigkeit
    ; - keine Vorschubbeeinflussung
    ;------------------------------
    CANCEL(SyncID_TC+4)
    ID=SyncID_TC+4 WHEN ((ABS($VA_IM[mcAxX]-rTargetPos)<=rTCInPosCoarse)OR((bOldTlFast)AND(bRelPreUnClmp)AND(ABS($VA_IM[mcAxX]-rTargetPos)<=rPosWin)AND(ABS($VA_VACTM[mcAxX])<=rSpVelo)AND(ABS($VA_VACTM[mcAxX])>=rSpVeloMin)AND(SYG_IM[iSYG+3]==1))) DO M=QU(MQ_SpUnClmpTl) SYG_RM[iSYG+5]=grSpUnClmpTimeC SYG_RM[iSYG+6]=1
    ;
  ELSE
    ;siehe bei Start X in Vorposition
  ENDIF
ENDIF

;-[WM286,WM307]-705.0--TCPosX_2-
;-------------------------------
IF (bDGIsNcAxis)
  ;
  ;Sp Geloest
  IF (bRelSpSw)
    iSpMask='B100100'
  ELSE
    iSpMask='B100'
  ENDIF
  ;
  ;HG/Kette Geloest
  IF (bRelAuxSw)
    iAuxAdr=68 iAuxMask='B11' iAuxResult='B10'
  ELSE
    iAuxAdr=1 iAuxMask='B1100' iAuxResult='B100'
  ENDIF
  ;
  rActVelo=SYG_RM[iSYG+11]/60 rMoveDistX=MAXVAL(grTCPosX-$VA_IM[mcAxX],0) rMoveDistY=ABS(grTCPosY-$VA_IM[mcAxY]) rActSpeed=$AA_S[iSpNo] bAxSpInPos=mcbSpInTCPosCoarse bAuxIsUnClmp=(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) bSpIsUnClmp=(($A_DBB[0] B_AND iSpMask)<>0)
  rCalcTime=0 rCalcTime1=0 rPosTime=0 rNewFeedDGRot=rFeedEmptyDGRot rTmp=1 rTmp2=0 rTmp3=0 rTmp4=0 iCount=0 rActJerk=rMaxJerkX
  ;
  ;-705.1--TCPosX_2-----
  ; Restlaufzeit X-Achse
  ;---------------------
  IF (rMoveDistX>0)
    ;
    REPEAT
      iCount=iCount+1 rVelo=MINVAL(EXP(1/3*LN(rMoveDistX*rMoveDistX*rActJerk/4)),rFeedX/60)
      IF (rVelo<2*rMaxVjX)
        rActJerk=rMaxJerkX*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjX-rVelo)/(2*rMaxVjX)))) rPosTime=2*SQRT(rVelo/rActJerk)
      ELSE
        rPosTime=rVelo/rMaxAccelX+rMaxTjX rActJerk=rMaxJerkX
      ENDIF
    UNTIL (iCount==giItCount)OR(rActJerk==rMaxJerkX)
    ;
    IF (rActVelo<rVelo)AND(rVelo>0)
      ;
      ;X muss noch beschleunigen -> die Beschleunigungszeit wird nur anteilig gerechnet
      rTmp=1+(rVelo-rActVelo)/rVelo
    ENDIF
    ;
    rTmp1=rMoveDistX-rTmp*0.5*rVelo*rPosTime
    IF (rTmp1>0)
      rCalcTime=rTmp*rPosTime+rTmp1/rVelo
    ELSE
      rCalcTime=rTmp*rPosTime
    ENDIF
  ENDIF
  ;
  rFeedXRelSp=rFeedX rTmp1=rCalcTime
  ;
  ;Restlaufzeit Spindel
  IF (rActSpeed>0)AND(NOT bSpIsUnClmp)AND(NOT bAxSpInPos)
    ;
    IF (gbIsGearSpindle)AND(iActGearStep==2)
      IF (grTCSPOS2_k1>0)
        IF (rActSpeed>grTCSPOS2_n2)
          rCalcTime1=rWRedSp*(grTCSPOS2_k1*(grTCSPOS2_n2-grTCSPOS2_n1)/10000+grTCSPOS2_k2*(rActSpeed-grTCSPOS2_n2)/10000+grTCSPOS2_tb)
        ELSE
          rCalcTime1=rWRedSp*(grTCSPOS2_k1*(rActSpeed-grTCSPOS2_n1)/10000+grTCSPOS2_tb)
        ENDIF
      ENDIF
    ELSE
      IF (grTCSPOS1_k1>0)
        IF (rActSpeed>grTCSPOS1_n2)
          rCalcTime1=rWRedSp*(grTCSPOS1_k1*(grTCSPOS1_n2-grTCSPOS1_n1)/10000+grTCSPOS1_k2*(rActSpeed-grTCSPOS1_n2)/10000+grTCSPOS1_tb)
        ELSE
          rCalcTime1=rWRedSp*(grTCSPOS1_k1*(rActSpeed-grTCSPOS1_n1)/10000+grTCSPOS1_tb)
        ENDIF
      ENDIF
    ENDIF
    ;
    IF (rCalcTime1>rCalcTime)
      ;
      ;Wenn Sp laenger als X brauchen wuerde -> Achse nach TCPOSX
      IF (bRelMoveUnclmp_U)AND(bOldTlFast)
        ;
        ;SpWz Klemmung bestimmt Ablauf
        rTmp1=rCalcTime1
      ELSE
        ;
        ;Sp soll Ablauf bestimmen -> X schneller (*0.8)
        rTmp1=rCalcTime1*0.8
      ENDIF
      ;
      iCount=0 rTmp=rMoveDistX rVelo=0
      REPEAT
        iCount=iCount+1 rVelo=rMoveDistX/rTmp1
        IF (rVelo<2*rMaxVjX)
          rActJerk=rMaxJerkX*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjX-rVelo)/(2*rMaxVjX)))) rMoveDistX=rTmp+0.5*2*SQRT(rVelo/rActJerk)*rVelo
        ELSE
          rMoveDistX=rTmp+0.5*(rVelo/rMaxAccelX+rMaxTjX)*rVelo
        ENDIF
      UNTIL (iCount==giItCount)OR(rVelo>=rFeedX/60)
      ;
      rFeedXRelSp=MINVAL(rMoveDistX*60/rTmp1,rFeedX)
      ;
    ENDIF
  ELSE
    ;Eilgang X
  ENDIF
  ;
  ;-705.2--TCPosX_2--------------
  ; Sicherstellen, dass Y in
  ; grTCPosY faehrt
  ; WM307 -> X in Pruefposition Y
  ; WM286 -> X in TCPOSX
  ;
  ; Laufzeit vorbesetzen
  ; X in TCPOSX  / SYG_RM[iSYG+4]
  ;------------------------------
  ;
  CANCEL(SyncID_TC+0,SyncID_TC+8)
  ID=SyncID_TC+0 WHEN (TRUE) DO FA[mcAxX]=rFeedXRelSp POS[mcAxX]=rWaitPosX FA[mcAxY]=rFeedY POS[mcAxY]=grTCPosY SYG_BM[iSYG+3]=TRUE SYG_RM[iSYG+4]=rTmp1
  ;
  IF (rWaitPosX<grTCPosX)
    ;
    ;X endgueltig in WzWPosition
    ;
    ID=SyncID_TC+8 WHEN (SYG_BM[iSYG+3])AND(ABS(grTcPosY-$VA_IM[mcAxY])<=rc2x0mm) DO FA[mcAxX]=rFeedXRelSp POS[mcAxX]=grTCPosX
  ENDIF
  ;
  IF (bCleanSp)
    ;
    ;-705.3--TCPosX_2-
    ; Reinigungsablauf
    ;-----------------
    M=QU(MQ_CleanTlOn)
    ;
    rTmp4=100*MINVAL(grCleanTlFeed/rFeedXRelSp,1)
    ;
    ID=SyncID_TC+11 WHENEVER (SYG_BM[iSYG+3])AND($AA_OVR[mcAxX]>rTmp4)AND($AA_IM[mcAxX]>=grCleanTlStart)AND($AA_IM[mcAxX]<=grCleanTlStart+grCleanTlWidth) DO $AA_OVR[mcAxX]=rTmp4
  ENDIF
ENDIF

;-[WM307]-706.0--Wz Loesen-
; Spindel
;--------------------------
IF (bDGIsWM307)
  ;
  IF ((NOT bOldTlFast)AND(bRelMoveUnClmp_U))OR((NOT bExpectChange)AND(bRelMoveUnClmp)AND(bOldTlFast))
    ;
    ;Loesen laeuft noch nicht, das Wz soll aber geloest uebergeben werden wenn
    ;
    ;kein schnelles Wz: kein WzW Ablauf, Sp gerichtet, X grob in Position
    ;oder
    ;schnelles Wz: voreilend Loesen gewaehlt, Restlaufzeit X < Sp Loesen Sollzeit
    ;
    ;SpWz Loesen, Sp Loeszeit freigeben
    ID=SyncID_TC+4 WHEN (mcbSpInTCPosCoarse)AND(((grTcPosX-$VA_IM[mcAxX])<=rTCInPosCoarse)OR((bOldTlFast)AND(bRelPreUnClmp)AND(bRelMoveUnClmp_U)AND(SYG_RM[iSYG+4]<MINVAL(rSpUnClmpTime,rPosTime)))) DO M=QU(MQ_SpUnClmpTl) SYG_RM[iSYG+6]=1 SYG_RM[iSYG+5]=grSpUnClmpTimeC
  ENDIF
ENDIF

;-[]-710.0--WAIT_PREP-----------------
; Bereitstellung wurde schon abgefragt
;-------------------------------------
IF (bPrepBeforeTCPosX) GOTOF WAIT_PREP_END

;=========
WAIT_PREP:
;=========
;
;-[]-711.0--WAIT_PREP-------------------
; Warten auf Bereitstellung durch Kanal2
;---------------------------------------
;
bRepeatPrep=FALSE bNewTlFxPl=FALSE bOldTlFxPl=FALSE gbPrepAfterTC=FALSE bActMSG=FALSE iTmp1=RTOI(giMaxPrepTime/(rWaitShort+rIpo)) iErrCount=0
;
IF (bNewIsManTl)
  ;
  ;HandWz kommt nicht aus Magazin, Wz Platz im Magazin noch unbekannt -> DG muss leer sein
  iSelTNo=0
ELSE
  ;
  ;neues Wz
  iSelTNo=iNewTNo
ENDIF
;
IF (gbWithHG)OR(bMagIsMiksch)
  ;
  ;-711.1--WAIT_PREP------------
  ; - Neues Wz im HG vorbereitet
  ; - HG/DG in Position
  ;
  ; Erkennung Wz Vorbereitung
  ; zuruecksetzen
  ;-----------------------------
  REPEAT
    bEnabled=(gbPrepDone)AND(NOT gbPrepEnd)AND(iSelTNo==$TC_MPP6[iSpLoadMag,iSpLoadLoc])AND(OUT_DGRotInBasePos)AND(((bMagXTIsNcAxis)AND(OUT_HgInTcPos))OR((bMagIsMiksch)AND(mcbDBB_DGLinInTCPos)AND(giTNoDG2==0))) SYG_BM[iSYG]=FALSE iErrCount=(iErrCount+SYG_IM[iSYGInc])
    IF (NOT bEnabled)
      ;
      IF (iErrCount==iTmp1)
        ;
        ;max. Bereitstellungszeit erreicht -> Meldung
        MSG(MSG_WaitForPrepEnd)
        iErrCount=0 bActMSG=TRUE
      ENDIF
      G04 F=rWaitShort
    ENDIF
  UNTIL (bEnabled OR gbSearchRelST)
  ;
ELSE
  ;
  ;-711.2--WAIT_PREP--------------------------------
  ; Zweischrittiger WzW (PickUpDisk und WM307):
  ; Erst SpWz auf Altplatz, dann neue Bereitstellung
  ;-------------------------------------------------
  ;
  IF (iSelTNo>0)
    ;
    ;vorgewaehltes Wz ist vorhanden, ist FestplatzWz und kein HandWz
    ;
    IF (($TC_TP8[iNewTNo] B_AND 'H40')<>0)OR(bMagIsPickUpDisk)
      ;
      ;Platz auf dem sich das Wz befindet
      iSpLoadLoc=$A_MYMLN[iNewTNo] iSpLoadMag=$A_MYMN[iNewTNo] bNewTlFxPl=TRUE
    ENDIF
  ENDIF
  ;
  IF (iOldTNo>0)
    ;
    ;SpWz vorhanden, ist FestplatzWz (HandWz ist schon Entladen)
    ;
    IF (($TC_TP8[iOldTNo] B_AND 'H40')<>0)OR(bMagIsPickUpDisk)OR(iToDo==mcTaskLoad)
      ;
      ;Passenden LeerPlatz / Altplatz fuer das SpWz suchen
      IF (iToDo==mcTaskLoad)
        ;
        ;Beim <Beladen ueber Beladestelle_Hand> kein GetFreeLoc, da beim Beladen die WzV
        ;den Zielplatz markiert und GetFreeLoc diesen als "bereits verwendet" erkennen wuerde
        ;
        GetTlLoc(3,iOldTNo, iSpUnLoadMag, iSpUnLoadLoc)
      ELSE
        GETFREELOC(iSpUnLoadMag,iSpUnLoadLoc,iOldTNo,"S",1)
      ENDIF
      bOldTlFxPl=TRUE
    ENDIF
  ENDIF
  ;
  ;Magazin muss in Position sein, Erkennung Wz Vorbereitung zuruecksetzen
  ;
  bFxPlUnLoad=FALSE bFxPlLoad=FALSE bEnabled=FALSE
  REPEAT
    ;
    iMagPos=OUTA_ActPosV1 bEnabled=(((mcbDBB_ChInPos AND bMagIsWM307)OR(mcbDBB_DiskInPos AND bMagIsPickUpDisk))AND(iMagPos>0)) SYG_BM[iSYG]=FALSE iErrCount=(iErrCount+SYG_IM[iSYGInc])
    ;
    IF (bEnabled)
      ;
      IF (NOT bNewTlFxPl)
        ;
        ;Aktueller Uebergabeplatz
        iSpLoadLoc=iMagPos iSpLoadMag=icMagNo
      ENDIF
      ;
      IF (iOldTNo>0)
        ;
        IF (bOldTlFxPl)
          ;
          bEnabled=(iMagPos==iSpUnLoadLoc)AND($TC_MPP6[iSpUnLoadMag,iSpUnLoadLoc]==0) bFxPlUnLoad=TRUE
        ELSE
          ;
          ;Aktueller Uebergabeplatz
          iSpUnLoadLoc=iMagPos iSpUnLoadMag=icMagNo
          IF (bNewTlFxPl)
            ;
            ;Uebergabeplatz leer
            bEnabled=($TC_MPP6[iSpUnLoadMag,iSpUnLoadLoc]==0) bFxPlUnLoad=TRUE
          ELSE
            ;
            ;Uebergabeplatz mit neuem Wz
            bEnabled=($TC_MPP6[iSpUnLoadMag,iSpUnLoadLoc]==iSelTNo)
          ENDIF
        ENDIF
      ELSE
        ;
        ;Uebergabeplatz mit NeuWz oder leer
        bEnabled=($TC_MPP6[icMagNo,iMagPos]==iSelTNo) bFxPlLoad=(bNewTlFxPl)
      ENDIF
    ELSE
      ;
      IF (iErrCount==iTmp1)
        ;max. Bereitstellungszeit erreicht -> Meldung
        MSG(MSG_WaitForPrepEnd)
        iErrCount=0 bActMSG=TRUE
      ENDIF
      G04 F=rWaitShort
    ENDIF
  UNTIL (bEnabled)AND(gbPrepDone)AND(NOT gbPrepEnd)AND(gbPrepActiv)
  ;
ENDIF
;
bTlClmp=(bFxPlLoad)OR((bFxPlUnLoad)AND(iNewTNo==0))OR(((NOT bNewTlFxPl)AND(NOT bOldTlFxPl))AND(NOT bMagIsPickUpDisk))
;
IF (bActMSG)
  MSG("")
ENDIF
;
;-712.0--WAIT_PREP-------
; Vorbereitetes WZ wurde
; nach Quittierung der
; Bereitstellung gesperrt
;------------------------
IF (iSelTNo>0)
  ;
  IF ((($TC_TP8[iSelTNo] B_AND 'B100')<>0)AND(iToDo<>mcTaskUnload))OR(gbSearchRelST)
    ;
    ;Neue Vorbereitung anstossen
    ;
    bRepeatPrep=TRUE gbSearchRelST=FALSE
    ;
    IF (iSTNo>0)
      ;
      ;Wiederholung der Anforderung
      TCA($TC_TP2[iSelTNo],iSTNo)
    ELSE
      ;
      ;Suche nach einem freigegebenen Wz
      T=$TC_TP2[iSelTNo]
    ENDIF
    ;
    GOTOB PREP_REQUEST
  ENDIF
ENDIF
;
gbSearchRelST=FALSE
;
IF ((bFxPlUnLoad)AND(iNewTNo>0))OR((iOldTNo>0)AND(NOT bMagIsPickUpDisk))
  ;
  ;SpWz Entladen gestartet
  iHomeStatus=(iHomeStatus B_OR 'B100')
ENDIF

;-[]-713.0--WAIT_PREP--------
; Jetzt erst in TCPosX Fahren
;----------------------------
IF (bPrepBeforeTCPosX) GOTOB MOVE_IN_TCPOSX
;
;=============
WAIT_PREP_END:
;=============

;-[WM307]-720.0--Wz Loesen-
; Kette
;--------------------------
IF (bDGIsWM307)
  ;
  ;Kette Loesen sobald in Position (Wird auch von Kanal 2 gemacht)
  CANCEL(SyncID_TC+5)
  ID=SyncID_TC+5 WHEN (mcbDBB_ChInPos) DO M=QU(MQ_HGUnClmpTl) SYG_RM[iSYG+8]=1
ENDIF

;-[WM286,WM307]-730.0--Vorposition DG-
; HG/Mag muss vorbereitet sein,
; sonst Kollision DG mit HG/Mag
;
; Nur bei WM286 und WM307, wenn geloest
; uebergeben werden soll oder schnelles
; Wz
;--------------------------------------
IF (bDGIsNCAxis)
  ;
  IF (gbPrepDone)AND(NOT gbPrepEnd)AND(bRelPrePosDGRot)AND(NOT bWaitDoorCoolant)AND((bDGIsWM286)OR(bRelMoveUnClmp_U)OR(bOldTlFast))
    ;
    ;Auf HG/Mag Warten: Abfrage nur, wenn Bedingung noch nicht erfuellt war und X ist schon durch Y freigegeben
    ;
    iErrCount=0
    REPEAT
      ;
      WHEN (TRUE) DO SYG_RM[iSYG+11]=$AA_VACTM[mcAxX]
      ;
      bEnabled=((gbWithHG)AND(OUT_HgInTcPos))OR((NOT gbWithHG)AND(mcbDBB_ChInPos)) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=730.0
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          IF (gbWithHG)
            FileRead("HD_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
            sAlarmParam=sAux
          ELSE
            sAlarmParam=AXSTRING(mcAxDGRot)
          ENDIF
          iAlarmNo=AL_WaitFor
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    rActVelo=SYG_RM[iSYG+11]/60 rMoveDistX=MAXVAL(grTCPosX-$VA_IM[mcAxX],0) rMoveDistY=MAXVAL(grTCPosY-$VA_IM[mcAxY],0) rActSpeed=$AA_S[iSpNo] bAxSpInPos=mcbSpInTCPosCoarse rActDGPos=mcActPosDGRot bAuxIsUnClmp=(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) bSpIsUnClmp=(($A_DBB[0] B_AND iSpMask)<>0)
    rCalcTime=0 rCalcTime1=0 rTmp=1 iCount=0 rActJerk=rMaxJerkX
    ;
    ;-730.1--Vorpositionieren DG-
    ; Restlaufzeit X
    ;----------------------------
    IF (rMoveDistX>0)
      ;
      REPEAT
        iCount=iCount+1 rVelo=MINVAL(EXP(1/3*LN(rMoveDistX*rMoveDistX*rActJerk/4)),rFeedX/60)
        IF (rVelo<2*rMaxVjX)
          rActJerk=rMaxJerkX*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjX-rVelo)/(2*rMaxVjX)))) rPosTime=2*SQRT(rVelo/rActJerk)
        ELSE
          rPosTime=rVelo/rMaxAccelX+rMaxTjX rActJerk=rMaxJerkX
        ENDIF
      UNTIL (iCount==giItCount)OR(rActJerk==rMaxJerkX)
      ;
      IF (rActVelo<rVelo)AND(rVelo>0)
        rTmp=1+(rVelo-rActVelo)/rVelo
      ENDIF
      ;
      ;Weg mit konst. Geschwindigkeit
      rTmp1=rMoveDistX-rTmp*0.5*rVelo*rPosTime
      IF (rTmp1>0)
        rCalcTime=rTmp*rPosTime+rTmp1/rVelo
      ELSE
        rCalcTime=rTmp*rPosTime
      ENDIF
    ENDIF
    ;
    ;Restlaufzeit Spindel
    ;
    IF (rActSpeed>0)AND(NOT bSpIsUnClmp)AND(NOT bAxSpInPos)
      ;
      IF (gbIsGearSpindle)AND(iActGearStep==2)
        IF (grTCSPOS2_k1>0)
          IF (rActSpeed>grTCSPOS2_n2)
            rCalcTime1=rWRedSp*(grTCSPOS2_k1*(grTCSPOS2_n2-grTCSPOS2_n1)/10000+grTCSPOS2_k2*(rActSpeed-grTCSPOS2_n2)/10000+grTCSPOS2_tb)
          ELSE
            rCalcTime1=rWRedSp*(grTCSPOS2_k1*(rActSpeed-grTCSPOS2_n1)/10000+grTCSPOS2_tb)
          ENDIF
        ENDIF
      ELSE
        IF (grTCSPOS1_k1>0)
          IF (rActSpeed>grTCSPOS1_n2)
            rCalcTime1=rWRedSp*(grTCSPOS1_k1*(grTCSPOS1_n2-grTCSPOS1_n1)/10000+grTCSPOS1_k2*(rActSpeed-grTCSPOS1_n2)/10000+grTCSPOS1_tb)
          ELSE
            rCalcTime1=rWRedSp*(grTCSPOS1_k1*(rActSpeed-grTCSPOS1_n1)/10000+grTCSPOS1_tb)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    ;
    bInitPrePosDGRot=TRUE
    ;
    CANCEL(SyncID_TC+3,SyncID_TC+7,SyncID_TC+9,SyncID_TC+10,SyncID_TC+11)
    ;
    ;-[WM286]-731.0--Vorposition DG-
    ;-------------------------------
    IF (bDGIsWM286)
      ;
      ;Laufzeiten Starten:
      SYG_RM[iSYG+4]=rCalcTime SYG_RM[iSYG+5]=rCalcTime1 rFeed=rFeedEmptyDGRot*rcRedVeloDG rPrePosTimeDGRot=grHomePosWindow*60/(rFeed*rSafeCalcDG)
      ;
      ;Laufzeiten Aktualisieren (Hier wird abgeschlossen X Achse)
      ID=SyncID_TC+7 DO SYG_RM[iSYG+4]=(MAXVAL((SYG_RM[iSYG+4]-rIPO),0)*MAXVAL(MINVAL(TRUNC((grTCPosX-$VA_IM[mcAxX])/rTCInPosFine),1),0)) SYG_RM[iSYG+5]=MAXVAL((SYG_RM[iSYG+5]-rIPO),0)
      ;
      ;DG mit verminderter Geschwindigkeit Starten, wenn alle Zeiten abgelaufen oder die zugehoerigen Bewegungen abgeschlossen sind.
      ;
      ;- X in TCPOSX  / SYG_RM[iSYG+4]
      ;- Sp Richten   / SYG_RM[iSYG+5] (Genauhalt Grob)
      ;
      IF (bTurnNeg)
        ID=SyncID_TC+3 WHEN (SYG_RM[iSYG+4]<=rPrePosTimeDGRot)AND((SYG_RM[iSYG+5]<=rPrePosTimeDGRot)OR($AA_STAT[mcAxSp1]>=3))AND(SYG_IM[iSYG+3]==1) DO FA[mcAxDGRot]=rFeed POS[mcAxDGRot]=ACN(rPrePosDGRot) SYG_IM[iSYG]=1 mcDBB_StepTC=iHomeStatus
      ELSE
        ID=SyncID_TC+3 WHEN (SYG_RM[iSYG+4]<=rPrePosTimeDGRot)AND((SYG_RM[iSYG+5]<=rPrePosTimeDGRot)OR($AA_STAT[mcAxSp1]>=3))AND(SYG_IM[iSYG+3]==1) DO FA[mcAxDGRot]=rFeed POS[mcAxDGRot]=ACP(rPrePosDGRot) SYG_IM[iSYG]=1 mcDBB_StepTC=iHomeStatus
      ENDIF
    ENDIF
    ;
    ;-[WM307]-732.0--Vorposition DG-
    ;-------------------------------
    IF (bDGIsWM307)
      ;
      ;Restlaufzeit Y
      IF (rMoveDistY>rTCInPosFine)
        rTmp4=EXP(1/3*LN(6*rMoveDistY/rActJerkY))-EXP(1/3*LN(6*rTCInPosFine/rActJerkY))
      ENDIF
      ;
      IF (NOT bAuxIsUnClmp)
        ;
        ;Kette nicht noch geloest -> auf HG warten
        rTmp3=grHGUnClmpTimeC
      ENDIF
      ;
      IF (bRelMoveUnClmp_C)AND(NOT bOldTlFast)
        ;
        ;Ohne SpWz Loesen
        SYG_RM[iSYG+4]=rCalcTime SYG_RM[iSYG+5]=0 SYG_RM[iSYG+6]=0 SYG_RM[iSYG+7]=rTmp3 SYG_RM[iSYG+8]=0 SYG_RM[iSYG+9]=rTmp4 rFeed=MINVAL(rFeedEmptyDGRot,rFeedDGRot)*rcRedVeloDG rPrePosTimeDGRot=grHomePosWindow*60/(rFeed*rSafeCalcDG)
      ELSE
        ;
        ;Sp wird noch gerichtet -> SYG_RM[iSYG+5]=SpLoeszeit
        rTmp2=grSpUnClmpTimeC SYG_RM[iSYG+4]=rCalcTime SYG_RM[iSYG+5]=MAXVAL(SYG_RM[iSYG+5],rTmp2*(1-SYG_RM[iSYG+6])) SYG_RM[iSYG+7]=rTmp3 SYG_RM[iSYG+8]=0 SYG_RM[iSYG+9]=rTmp4 rFeed=rFeedEmptyDGRot*rcRedVeloDG rPrePosTimeDGRot=grHomePosWindow*60/(rFeed*rSafeCalcDG)
      ENDIF
      ;
      ;Laufzeiten Aktualisieren:
      ;
      ;In SyncID_TC+7 wird X,Y Achse abgeschlossen, um bei SyncID_TC+3 die max. Satzlaenge einhalten zu koennen.
      ID=SyncID_TC+7 DO SYG_RM[iSYG+4]=(MAXVAL((SYG_RM[iSYG+4]-rIPO),0)*MAXVAL(MINVAL(TRUNC((grTCPosX-$VA_IM[mcAxX])/rTCInPosFine),1),0)) SYG_RM[iSYG+5]=MAXVAL((SYG_RM[iSYG+5]-SYG_RM[iSYG+6]*rIPO),0) SYG_RM[iSYG+7]=MAXVAL((SYG_RM[iSYG+7]-SYG_RM[iSYG+8]*rIPO),0) SYG_RM[iSYG+9]=(MAXVAL((SYG_RM[iSYG+9]-rIPO),0)*MINVAL(TRUNC(ABS(grTCPosY-$VA_IM[mcAxY])/rTCInPosFine),1))
      ;
      ;DG mit verminderter Geschwindigkeit Starten, wenn alle Zeiten abgelaufen oder die zugehoerigen Bewegungen abgeschlossen sind.
      ;
      ;- X in TCPOSX        / SYG_RM[iSYG+4]
      ;- Sp Loesen(Richten) / SYG_RM[iSYG+5]
      ;- Kette/HG Loesen    / SYG_RM[iSYG+7]
      ;- Y in TCPOSY        / SYG_RM[iSYG+9]
      ;
      ID=SyncID_TC+3 WHEN (SYG_RM[iSYG+4]<=rPrePosTimeDGRot)AND(SYG_RM[iSYG+5]<=rPrePosTimeDGRot)AND((SYG_RM[iSYG+7]<=rPrePosTimeDGRot)OR(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult))AND(SYG_RM[iSYG+9]<=rPrePosTimeDGRot)AND(SYG_IM[iSYG+3]==1) DO FA[mcAxDGRot]=rFeed POS[mcAxDGRot]=ACP(rPrePosDGRot) SYG_IM[iSYG]=1 mcDBB_StepTC=iHomeStatus
    ENDIF
    ;-[WM307,WM286]-
  ENDIF
ENDIF

;============
DG_NEXT_MOVE:
;============
;
;-[WM307,WM286]-740.0--DG Feed-
; Drehgeschwindigkeit fuer NCDG
;------------------------------
IF (bDGIsNCAxis)
  ;
  IF (bFxPlUnload)
    ;
    rWTl=rWOldTl rJTl=rOldTlJ bTurnDgFast=bOldTurnDgFast
  ELSE
    IF (bFxPlLoad)
      ;
      rWTl=rWNewTl rJTl=rNewTlJ bTurnDgFast=bNewTurnDgFast
    ELSE
      rWTl=MAXVAL(rWOldTl,rWNewTl) rJTl=MAXVAL(rOldTlj,rNewTlJ)
    ENDIF
  ENDIF
  ;
  IF (bTurnDgFast)
    ;
    IF (rWTl>grLightTlDg)
      ;
      IF (rWTl>grMidTlDg)
        rFeedDGRot=grMidFeedDGRot-(rWTl-grMidTlDg)*(grMidFeedDGRot-grLowFeedDGRot)/(grMaxTlDg-grMidTlDG)
      ELSE
        rFeedDGRot=grHighFeedDGRot-(rWTl-grLightTlDg)*(grHighFeedDGRot-grMidFeedDGRot)/(grMidTlDg-grLightTlDG)
      ENDIF
    ELSE
      rFeedDGRot=grHighFeedDGRot
    ENDIF
    rFeedDGRot=rFeedDGRot*(1-grTlTiltFactorDG*MAXVAL(((rJTl-grTlTiltTorqueDG)/grTlTiltTorqueDG),0))
  ELSE
    rFeedDGRot=grLowFeedDGRot
  ENDIF
ENDIF
;
;-750.0-[WM307]-TCPOS------------------
; Beim Beladen des neuen Werkzeugs
; nicht mehr Warten (Festplatzwerkzeug)
;--------------------------------------
IF (bSecLoop) GOTOF START_TC

;-[]-760.0--TCPOS------------------
; Warten bis Sp,X,Y in WzW Position
;----------------------------------
;
;==============
WAIT_FOR_TCPOS:
;==============
;
iErrCount=0
REPEAT
  ;
  bTmp1=(ABS(grTcPosX-$VA_IM[mcAxX])<=rTCInPosCoarse) bTmp2=(ABS(grTcPosY-$VA_IM[mcAxY])<=rTCInPosCoarse) bTmp3=mcbSpInTCPosFine bEnabled=(bTmp1)AND(bTmp2)AND(bTmp3)AND(SYG_BM[iSYG+7]) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=760.0
  IF (NOT bEnabled)
    G4 F=rWaitShort
    IF (iErrCount>=iErrTimeShort)
      sAlarmParam="" sTmp=""
      IF (NOT bTmp1)
        sAlarmParam=sAlarmParam<<"X" sTmp=", "
      ENDIF
      IF (NOT bTmp2)
        sAlarmParam=sAlarmParam<<sTmp<<"Y" sTmp=", "
      ENDIF
      IF (NOT bTmp3)
        sAlarmParam=sAlarmParam<<sTmp<<"S" sTmp=", "
      ENDIF
      IF (NOT SYG_BM[iSYG+7])
        sAlarmParam=sAlarmParam<<sTmp<<AXSTRING(mcAxFH)
      ENDIF
      iAlarmNo=AL_WaitFor
      GOTOF HandleAlarm
    ENDIF
  ENDIF
  ;
UNTIL (bEnabled)

;-[]-770.0--Konen Reinigen-
; Blasluft Ausschalten
;--------------------------
IF (bCleanSp)
  M=QU(MQ_CleanTlOff)
ENDIF

;-[]-800.0--Y,Sp Festhalten-------
; X > PrePos -> Y Sperren
;     (nur wenn Y Fahren soll, da
;     eventuell nur Z/X
;     interpolieren sollen
;
; X > SpPosX -> Sp Sperren
;
; Zusaetzlich bei NC Wechslern
; DG keine GndSt -> X,Y,Sp Sperren
;---------------------------------
;
CANCEL(SyncID_TC+10,SyncID_TC+11)
;
;-[WM286,WM307]-800.1--Y,SP Festhalten-
;--------------------------------------
IF (bDGIsNCAxis)
  ;
  IF (bDGIsWM286)
    ;
    ;Vorposition beim Verlassen des Magazinraums immer vor der WzWTuer
    rPrePosX=MINVAL(grTCPosX-grToMaxRad,rPrePosX)
  ENDIF
  ;
  IF (bRelExitXY)
    ;
    ;In Abhaengigkeit von der IstPosition X, des Geschwindigkeitssollwerts X wird mit dem Override Y auf einer "Kreisbahn" gehalten
    ;
    ID=SyncID_TC+10 WHENEVER ($VA_IM[mcAxX]>rPrePosX)AND((ABS($AA_DTEB[mcAxY])>0)OR(NOT OUT_DGRotInBasePos)) DO $AC_OVR=0 SYG_RM[iSYG+10]=MAXVAL((grExitStartX-$AA_IM[mcAxX])/grExitRadXY,0) $AA_OVR[mcAxY]=100*MAXVAL(rcOvrMultY*ABS($AA_VACTM[mcAxX]/rFeedX)*(1-SQRT(MAXVAL(1-SYG_RM[iSYG+10]*SYG_RM[iSYG+10],0))),0)
  ELSE
    ID=SyncID_TC+10 WHENEVER ($VA_IM[mcAxX]>rPrePosX)AND((ABS($AA_DTEB[mcAxY])>0)OR(NOT OUT_DGRotInBasePos)) DO $AC_OVR=0 $AA_OVR[mcAxY]=0
  ENDIF
  ;
  ;Spindel sichern / SpWz Klemmzeit aktivieren
  ;
  ID=SyncID_TC+11 WHENEVER ($VA_IM[mcAxX]>rSpPosX)OR(NOT OUT_DGRotInBasePos)OR(($A_DBB[0] B_AND 'B11')==0)OR(SYG_IM[iSYG]==icClmpStep) DO $AA_OVR[mcAxSp1]=0 SYG_RM[iSYG+2]=MAXVAL((SYG_RM[iSYG+2]-rIPO),0)
ENDIF
;
;-[MTC,DISK]-800.2--Y,SP Festhalten-
;-----------------------------------
IF (bDGIsMTC)OR(bMagIsPickUpDisk)
  ;
  IF (bRelExitXY)AND(NOT bCheckOldTl)
    ;
    ;Wenn Y fahren soll, wird in Abhaengigkeit von der Sollposition und des Geschwindigkeitssollwerts der X-Achse
    ;die Y-Achse mit dem Override auf einer "Kreisbahn" gehalten
    ;
    ID=SyncID_TC+10 WHENEVER ($VA_IM[mcAxX]>rPrePosX)AND(ABS($AA_DTEB[mcAxY])>0) DO $AC_OVR=0 SYG_RM[iSYG+10]=MAXVAL((grExitStartX-$AA_IM[mcAxX])/grExitRadXY,0) $AA_OVR[mcAxY]=100*MAXVAL(rcOvrMultY*ABS($AA_VACTM[mcAxX]/rFeedX)*(1-SQRT(MAXVAL(1-SYG_RM[iSYG+10]*SYG_RM[iSYG+10],0))),0)
  ELSE
    ID=SyncID_TC+10 WHENEVER ($VA_IM[mcAxX]>rPrePosX)AND(ABS($AA_DTEB[mcAxY])>0) DO $AC_OVR=0 $AA_OVR[mcAxY]=0
  ENDIF
  ;
  ;Spindel sichern / SpWz Klemmzeit aktivieren / DG Position fuer spaetere Bewegungskontrolle
  IF (bDGIsMTC)
    ID=SyncID_TC+11 WHENEVER ($VA_IM[mcAxX]>rSpPosX)OR(($A_DBB[0] B_AND 'B11')==0)OR(($A_DBB[4] B_AND 'B1')==0)OR(SYG_IM[iSYG]==icClmpStep) DO $AA_OVR[mcAxSp1]=0 SYG_RM[iSYG+2]=MAXVAL((SYG_RM[iSYG+2]-rIPO),0) SYG_RM[iSYG]=mcActPosDGRot
  ELSE
    ID=SyncID_TC+11 WHENEVER ($VA_IM[mcAxX]>rSpPosX)OR(($A_DBB[0] B_AND 'B11')==0)OR(SYG_IM[iSYG]==icClmpStep) DO $AA_OVR[mcAxSp1]=0 SYG_RM[iSYG+2]=MAXVAL((SYG_RM[iSYG+2]-rIPO),0)
  ENDIF
ENDIF

;-[DISK]-805.0--BBK_3---
; Bohrerbruchkontrolle
; Ausfuehrung im Kanal 1
;-----------------------
IF (bMagIsPickUpDisk)AND(bCheckOldTl)
  ;
  ;X,Y im Genauhalt, SpWz gespannt -> Pruefen
  iErrCount=0
  REPEAT
    bTmp1=($AA_STAT[mcAxX]==4) bTmp2=($AA_STAT[mcAxY]==4) bSpIsClmp=(mcbDBB_SpClamped) bEnabled=(bTmp1)AND(bTmp2)AND(bTmp3) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=805.0
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor
        sAlarmParam=""  sTmp=""
        IF (NOT bTmp1)
          sAlarmParam=sAlarmParam<<"X" sTmp=", "
        ENDIF
        IF (NOT bTmp2)
          sAlarmParam=sAlarmParam<<sTmp<<"Y" sTmp=", "
        ENDIF
        IF (NOT bSpIsClmp)
          FileRead("CLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
          sAlarmParam=sAlarmParam<<sTmp<<"CS "<<sAux
        ENDIF
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)
  ;
  IF (iToDo==mcTaskLoad)
    ;
    ;-806.0--BBK_3-------------
    ; Wz Beladen - SpWz Teachen
    ;--------------------------
    ;
    MsgBox("$89677 : T = "<<$TC_TP2[iOldTNo],"CLEAR")
    ;
    ToChkMSC(-1,iOldTNo,0,FALSE,bNegResultBBK,iAlarmNoBBK,sAlarmParamBBK)
    rAlarmAreaBBK=806.0
    ;
    IF (bNegResultBBK)
      ;
      ;-806.1--BBK_3-------
      ; Falsches Wz erkannt
      ;
      ; Beladen abbrechen ->
      ; Negative Quittierung
      ; an FC8
      ;----------------------
      ToAckn(FALSE,iTaskID,iTaskIDNo,0,0,0,0,0,0,3)
      ;
      ;-806.2--BBK_3-
      ; Wz Sperren
      ;--------------
      $TC_TP8[iOldTNo]=($TC_TP8[iOldTNo] B_OR 'B100') OUT_ReqLockSpTool=0 gbLastToBroken=TRUE
      ;
      ;-806.3--BBK_3------
      ; Zurueck in Belade-
      ; position Hand
      ;-------------------
      G153 G0 G90 G40 G60 G603 X=rCloseDoorX Y=grTCPosY
      M_TcDoorClose1
      G153 G601 X=grToLoadPosX Y=grToLoadPosY
      SPOS=ACP(rTcSPosRes)
      ;
      ;-806.4--BBK_3-
      ; TC Abbrechen,
      ; Alarmausgabe
      ;---------------
      GOTOF PROG_END
    ENDIF
  ELSE
    ;
    ;-807.0--BBK_3-
    ; SpWz Pruefen
    ;--------------
    ;
    ToChkMSC(-2,iOldTNo,0,FALSE,bNegResultBBK,iAlarmNoBBK,sAlarmParamBBK)
    rAlarmAreaBBK=807.0
  ENDIF
  ;
  ;-808.0--BBK_3-------
  ; Sp muss fuer die
  ; Fortsetzung des WzW
  ; geloest sein
  ;--------------------
  bCheckOldTl=FALSE
  ;
  M_SpUnClamp1
ENDIF

;-[]-810.0--WzW-
;---------------
;
;========
START_TC:
;========
;
;Synchronisieren Vorbereiten
IF (bFxPlUnLoad)
  giSyncTC=1 giTlInSp=iOldTNo giNextTlInSp=0
ELSE
  IF (bFxPlLoad)
    giSyncTC=1 giTlInSp=0 giNextTlInSp=iNewTNo
  ELSE
    giSyncTC=1 giTlInSp=iOldTNo giNextTlInSp=iNewTNo
  ENDIF
ENDIF
;
IF (gbTMIsHHD)
  giStateToMMC[0]=(giStateToMMC[0] B_OR mcState1TCActive)
ENDIF
;
;-[WM286]-810.1--WzW-------------
; X in TCPOSX -> Altes Wz greifen
;--------------------------------
IF (bDGIsWM286)
  ;
  IF (bInitPrePosDGRot)
    ;
    ;Vorstart DG wurde initialisiert
    ;
    ;Sicherstellen, das X in genauer WzWPosition
    REPEAT
      bEnabled=(ABS($VA_IM[mcAxX]-grTcPosX)<=rTCInPosFine) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=810.1
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam="X"
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
  ENDIF
  ;
  CANCEL(SyncID_TC+3,SyncID_TC+4,SyncID_TC+5,SyncID_TC+7,SyncID_TC+8)
  ;
  ;DG in UebernahmePosition SpWz
  IF (bTurnNeg)
    ID=SyncID_TC+3 WHEN (ABS($VA_IM[mcAxX]-grTcPosX)<=rTCInPosFine) DO FA[mcAxDGRot]=rFeedEmptyDGRot POS[mcAxDGRot]=ACN(rFirstPosDGRot) SYG_IM[iSYG]=2 SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot] mcDBB_StepTC=iHomeStatus
  ELSE
    ID=SyncID_TC+3 WHEN (ABS($VA_IM[mcAxX]-grTcPosX)<=rTCInPosFine) DO FA[mcAxDGRot]=rFeedEmptyDGRot POS[mcAxDGRot]=ACP(rFirstPosDGRot) SYG_IM[iSYG]=2 SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot] mcDBB_StepTC=iHomeStatus
  ENDIF
  ;
  ;Geschwindigkeitserfassung
  ID=SyncID_TC+7 WHENEVER (SYG_IM[iSYG]==2) DO SYG_RM[iSYG+1]=$VA_VACTM[mcAxDGRot]-SYG_RM[iSYG] SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot]
  ;
  ;-810.2--WzW-----------------
  ; Warten bis DG in Bremsrampe
  ; ist oder steht
  ;----------------------------
  iErrCount=0 rPosWin=rc1x0deg rPosTime=0 bEnabled=FALSE rTargetPos=rFirstPosDGRot rSpVelo=-1 rHGVelo=-1
  REPEAT
    ;
    ;Status X
    rActVelo=ABS(SYG_RM[iSYG]) rActVeloDiff=SYG_RM[iSYG+1] rActPos=mcActPosDGRot rVelo=((rActVelo+ABS(rActVeloDiff))/60) bEnabled=(SYG_IM[iSYG]==2) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=810.2
    IF (bEnabled)AND(rVelo>0)
      ;
      ;Abbremszeit DG
      IF (rVelo<2*rMaxVjDG)
        rActJerk=rMaxJerkDG*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjDG-rVelo)/(2*rMaxVjDG)))) rPosTime=2*SQRT(rVelo/rActJerk) rActTj=rPosTime*0.5
      ELSE
        rPosTime=rVelo/rMaxAccelDG+rMaxTjDG rActTj=rMaxTjDG rActJerk=rMaxJerkDG
      ENDIF
      ;
      ;Achse bremst
      rPosWin=0.5*rVelo*rPosTime+grPosWinDGRot bEnabled=(bEnabled)AND(rActVeloDiff<0)AND(ABS(rActPos-rTargetPos)<=rPosWin)
    ELSE
      bEnabled=FALSE
    ENDIF
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)OR(ABS(rActPos-rTargetPos)<=grPosWinDGRot)
  ;
  ;-810.3--WzW----
  ; Modellrechnung
  ;---------------
  ;
  CANCEL(SyncID_TC+7)
  ;
  IF (bEnabled)
    ;
    ;DG in Bremsrampe
    ;
    rTmp2=EXP(1/3*LN(6*grPosWinDGRot/rActJerk))
    ;
    IF (rSpUnClmpTime>0)
      ;
      ;Spindel
      ;
      ;Begrenzung auf Bremsrampe
      rSpUnClmpTime=MINVAL(rPosTime,rSpUnClmpTime+rTmp2)
      ;
      IF (rSpUnClmpTime<=rActTj)
        rSpVelo=0.5*rActJerk*rSpUnClmpTime*rSpUnClmpTime*60
      ELSE
        IF (rSpUnClmpTime<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
          rSpVelo=(rMaxAccelDG*(rSpUnClmpTime-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rSpUnClmpTime
          rSpVelo=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
      ;
      rTmp=rSpUnClmpTime-rSpVeloWindow
      IF (rTmp<=rActTj)
        rSpVeloMin=0.5*rActJerk*rTmp*rTmp*60
      ELSE
        IF (rTmp<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
          rSpVeloMin=(rMaxAccelDG*(rTmp-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rTmp
          rSpVeloMin=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
      ;
      IF (rActVelo<=rSpVeloMin)
        ;
        ;Achse ist schon zu langsam
        rSpVeloMin=0
      ENDIF
    ENDIF
    ;
    IF (rHGUnClmpTime>0)
      ;
      ;HG
      ;
      rHGUnClmpTime=MINVAL(rPosTime,rHGUnClmpTime+rTmp2)
      IF (rHGUnClmpTime<=rActTj)
        rHGVelo=0.5*rActJerk*rHGUnClmpTime*rHGUnClmpTime*60
      ELSE
        IF (rHGUnClmpTime<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
          rHGVelo=(rMaxAccelDG*(rHGUnClmpTime-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rHGUnClmpTime
          rHGVelo=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
      ;
      rTmp=rHGUnClmpTime-rSpVeloWindow
      IF (rTmp<=rActTj)
        rHGVeloMin=0.5*rActJerk*rTmp*rTmp*60
      ELSE
        IF (rTmp<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
          rHGVeloMin=(rMaxAccelDG*(rTmp-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rTmp
          rHGVeloMin=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
    ENDIF
    ;
    IF (rActVelo<=rHGVeloMin)
      ;
      ;Achse ist schon zu langsam
      rHGVeloMin=0
    ENDIF
  ENDIF
  ;
  ;-810.4--WzW----------------------------
  ; Voreilend Sp Loesen
  ; - Achse bremst
  ; - ist im LoesFenster
  ; - kein Einzelsatz und Override > 100%
  ; sonst, wenn DG in Position
  ;---------------------------------------
  ID=SyncID_TC+4 WHEN((ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)OR((bOldTlFast)AND(ABS($VA_VACTM[mcAxDGRot])<=rSpVelo)AND(ABS($VA_VACTM[mcAxDGRot])>=rSpVeloMin)AND(SYG_IM[iSYG+3]==1))) DO M=QU(MQ_SpUnclmpTl)
  ID=SyncID_TC+5 WHEN((ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)OR((bNewTlFast)AND(ABS($VA_VACTM[mcAxDGRot])<=rHGVelo)AND(ABS($VA_VACTM[mcAxDGRot])>=rHGVeloMin)AND(SYG_IM[iSYG+3]==1))) DO M=QU(MQ_HGUnclmpTl)
  ;
  ;-810.6--WzW-----
  ; Wechsel starten, wenn
  ; - DG in Uebernahmeposition SpWz
  ; - Sp/HG geloest
  ;----------------
  ;
  ;Sp Geloest
  IF (bRelSpSW)
    iSpMask='B100100'
  ELSE
    iSpMask='B100'
  ENDIF
  ;
  iHomeStatus=((iHomeStatus B_AND 'B11') B_OR 'B1000')
  ;
  CANCEL(SyncID_TC+3,SyncID_TC+7)
  ;
  ;DG in Uebergabeposition NeuWz
  IF (bTurnNeg)
    ID=SyncID_TC+3 WHEN (ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)AND(($A_DBB[0] B_AND iSpMask)<>0)AND(($A_DBB[1] B_AND 'B1100')=='B100') DO FA[mcAxDGRot]=rFeedDGRot POS[mcAxDGRot]=ACN(rNextPosDGRot) SYG_IM[iSYG]=3 SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot] mcDBB_StepTC=iHomeStatus
  ELSE
    ID=SyncID_TC+3 WHEN (ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)AND(($A_DBB[0] B_AND iSpMask)<>0)AND(($A_DBB[1] B_AND 'B1100')=='B100') DO FA[mcAxDGRot]=rFeedDGRot POS[mcAxDGRot]=ACP(rNextPosDGRot) SYG_IM[iSYG]=3 SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot] mcDBB_StepTC=iHomeStatus
  ENDIF
  ;
  ;Geschwindigkeitserfassung
  ID=SyncID_TC+7 WHENEVER (SYG_IM[iSYG]==3) DO SYG_RM[iSYG+1]=$VA_VACTM[mcAxDGRot]-SYG_RM[iSYG] SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot]
ENDIF

;-[WM307]-811.0--WzW-
;--------------------
;
IF (bDGIsWM307)
  ;
  ;-811.1--WzW-------------------
  ; Start DG in Uebergabeposition
  ; - Sp geloest
  ; - Kette geloest
  ; - Kette in Teilungsposition
  ;------------------------------
  ;
  ;Sp Geloest
  IF (bRelSpSw)
    iSpMask='B100100'
  ELSE
    iSpMask='B100'
  ENDIF
  ;
  ;Kette Geloest
  iAuxAdr=1 iAuxMask='B1100' iAuxResult='B100'
  ;
  ;Gleichmaessiges Schwenken -> niedrigste Geschwindigkeit
  rTmp=MINVAL(rFeedEmptyDGRot,rFeedDGRot)
  ;
  IF (bInitPrePosDGRot)
    ;
    ;Vorstart DG wurde initialisiert
    ;
    iErrCount=0
    REPEAT
      ;
      bTmp1=(mcbDBB_ChInPos) bSpIsUnClmp=((($A_DBB[0] B_AND 'B100')<>0)OR(((bRelMoveUnClmp_C)AND(NOT bOldTlFast))OR(NOT bRelMoveUnClmp))) bAuxIsUnClmp=(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) bEnabled=(bTmp1)AND(bSpIsUnClmp)AND(bAuxIsUnClmp) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=811.1
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          sAlarmParam="" sTmp=""
          IF (NOT bTmp1)
            sAlarmParam=AXSTRING(mcAxV1) sTmp=", "
          ENDIF
          IF (NOT bAuxIsUnClmp)
            sAlarmParam=AlarmParam<<sTmp<<AXSTRING(mcAxV1)<<"_UNCLAMP" sTmp=", "
          ENDIF
          IF (NOT bSpIsUnClmp)
            FileRead("UNCLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
            sAlarmParam=AlarmParam<<sTmp<<"CS "<<sAux
          ENDIF
          iAlarmNo=AL_WaitFor
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
  ENDIF
  ;
  IF (bRelMoveUnClmp_C)AND(NOT bOldTlFast)OR(NOT bRelMoveUnClmp)
    ;
    ;Das SpWz ist kein schnelles Wz und wird gespannt uebergeben
    ;
    ;-811.1--WzW-----------------------------
    ; - DG in Uebernahmeposition SpWz starten
    ; - SpWz Loesen
    ;----------------------------------------
    CANCEL(SyncID_TC+3,SyncID_TC+4,SyncID_TC+5,SyncID_TC+7)
    ;
    ID=SyncID_TC+3 WHEN (mcbDBB_ChInPos)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) DO FA[mcAxDGRot]=rFeedEmptyDGRot POS[mcAxDGRot]=ACP(rFirstPosDGRot) SYG_IM[iSYG]=2 SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot] mcDBB_StepTC=iHomeStatus
    ;
    ID=SyncID_TC+7 WHENEVER (SYG_IM[iSYG]==2) DO SYG_RM[iSYG+1]=$VA_VACTM[mcAxDGRot]-SYG_RM[iSYG] SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot]
    ;
    ;-811.2--WzW-----------------
    ; DG in Bremsrampe oder steht
    ;----------------------------
    iErrCount=0 rPosTime=0 bEnabled=FALSE rTargetPos=rFirstPosDGRot rSpVelo=-1
    REPEAT
      ;
      ;Status X
      rActVelo=ABS(SYG_RM[iSYG]) rActVeloDiff=SYG_RM[iSYG+1] rActPos=mcActPosDGRot rVelo=(rActVelo+ABS(rActVeloDiff))/60 bEnabled=(SYG_IM[iSYG]==2) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=811.2
      IF (bEnabled)AND(rVelo>0)
        ;
        ;Abbremszeit DG
        IF (rVelo<2*rMaxVjDG)
          rActJerk=rMaxJerkDG*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjDG-rVelo)/(2*rMaxVjDG)))) rPosTime=2*SQRT(rVelo/rActJerk) rActTj=rPosTime*0.5
        ELSE
          rPosTime=rVelo/rMaxAccelDG+rMaxTjDG rActTj=rMaxTjDG rActJerk=rMaxJerkDG
        ENDIF
        ;
        ;Achse bremst
        rPosWin=0.5*rVelo*rPosTime+grPosWinDGRot bEnabled=(bEnabled)AND(rActVeloDiff<0)AND(ABS(rActPos-rTargetPos)<=rPosWin)
      ELSE
        bEnabled=FALSE
      ENDIF
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)OR(ABS(rActPos-rTargetPos)<=grPosWinDGRot)
    ;
    ;-811.3--WzW---------------------
    ; Geschwindigkeit beim Loesbefehl
    ;--------------------------------
    ;
    CANCEL(SyncID_TC+7)
    ;
    IF (bRelPrep_Clmp_UnClmp)AND(bEnabled)AND(bRelPreUnClmp)
      ;
      rTmp2=EXP(1/3*LN(6*grPosWinDGRot/rActJerk))
      ;
      IF (rSpUnClmpTime>0)
        ;
        ;Spindel
        ;
        ;Begrenzung auf Bremsrampe
        rSpUnClmpTime=MINVAL(rPosTime,rSpUnClmpTime+rTmp2)
        ;
        IF (rSpUnClmpTime<=rActTj)
          rSpVelo=0.5*rActJerk*rSpUnClmpTime*rSpUnClmpTime*60
        ELSE
          IF (rSpUnClmpTime<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
            rSpVelo=(rMaxAccelDG*(rSpUnClmpTime-rMaxTjDG)+rMaxVjDG)*60
          ELSE
            rTmp1=rPosTime-rSpUnClmpTime
            rSpVelo=(rVelo-0.5*rActJerk*rTmp1*rTmp1)*60
          ENDIF
        ENDIF
        ;
        rTmp1=rSpUnClmpTime-rSpVeloWindow
        IF (rTmp1<=rActTj)
          rSpVeloMin=0.5*rActJerk*rTmp1*rTmp1*60
        ELSE
          IF (rTmp1<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
            rSpVeloMin=(rMaxAccelDG*(rTmp1-rMaxTjDG)+rMaxVjDG)*60
          ELSE
            rTmp1=rPosTime-rTmp1
            rSpVeloMin=(rVelo-0.5*rActJerk*rTmp1*rTmp1)*60
          ENDIF
        ENDIF
        ;
        IF (rActVelo<=rSpVeloMin)
          ;
          ;Achse ist schon zu langsam
          rSpVeloMin=0
        ENDIF
      ENDIF
    ENDIF
    ;
    ;-811.4--WzW------------------------------
    ; Sp Loesen
    ; Voreilend: DG bremst, ist im Loesfenster
    ; Sonst:     DG in Position
    ;-----------------------------------------
    ID=SyncID_TC+4 WHEN((ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)OR((ABS($VA_VACTM[mcAxDGRot])<=rSpVelo)AND(ABS($VA_VACTM[mcAxDGRot])>=rSpVeloMin)AND(SYG_IM[iSYG+3]==1))) DO M=QU(MQ_SpUnclmpTl)
    ;
    ;-811.5--WzW----------------------
    ; Warten bis DG mit geloestem SpWz
    ; in Uebernahmeposition SpWz steht
    ;---------------------------------
    iErrCount=0
    REPEAT
      bEnabled=(SYG_IM[iSYG]>=2)AND($AA_STAT[mcAxDGRot]>=3)AND(ABS(mcActPosDGRot-rFirstPosDGRot)<=rc2x0deg)AND(($A_DBB[0] B_AND 'B100')<>0) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=811.5
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam="CT"
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    IF (gbSpIsUnClmpFixed)AND(bTlClmp)
      ;
      ;-811.6--WzW-------------------------------
      ; SpWz ist geloest aber mechanisch geklemmt
      ; -> Lagehaltung aus -> Momentenabbau
      ;------------------------------------------
      SPCOF
    ENDIF
  ENDIF
  ;
  ;Beladen
  iHomeStatus=((iHomeStatus B_AND 'B10011') B_OR 'B1000')
  ;
  IF (NOT bRelMoveUnClmp_C)OR(bNewTlFast)
    ;
    ;Das NeuWz soll fliegend uebergeben werden
    ;
    ;Bedingung: Es ist ein schnelles Wz oder es ist
    ;keine gespannte Uebergabe gefordert
    ;
    ;-811.11--WzW---------
    ; Kette und Sp geloest
    ; -> DG in Endposition
    ;---------------------
    CANCEL(SyncID_TC+3)
    ID=SyncID_TC+3 WHEN (($A_DBB[0] B_AND iSpMask)<>0)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) DO FA[mcAxDGRot]=rFeedDGRot POS[mcAxDGRot]=ACP(rEndPosDGRot) SYG_IM[iSYG]=4
    ;
    ;-811.12--WzW---------------
    ; Freigabe SynAct Wz Spannen
    ; erst, wenn geloest ist
    ;---------------------------
    iErrCount=0
    REPEAT
      bSpIsUnClmp=(($A_DBB[0] B_AND iSpMask)<>0) bAuxIsUnClmp=(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) bEnabled=(bSpIsUnClmp)AND(bAuxIsUnClmp) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=811.12
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          sAlarmParam=""  sTmp=""
          IF (NOT bAuxIsUnClmp)
            FileRead("UNCLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
            sAlarmParam=sAlarmParam<<AXSTRING(mcAxV1)<<" "<<sAux  sTmp=", "
          ENDIF
          IF (NOT bSpIsUnClmp)
            FileRead("UNCLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
            sAlarmParam=sAlarmParam<<sTmp<<"CS "<<sAux
          ENDIF
          iAlarmNo=AL_WaitFor
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    IF (gbSpIsUnClmpFixed)AND(bTlClmp)
      ;
      ;-811.13--WzW-----------------------------
      ; SpWz ist geloest und mechanisch geklemmt
      ; -> Lagehaltung aus -> Momentenabbau
      ;-----------------------------------------
      SPCOF
    ENDIF
    ;
    ;-811.14--WzW------
    ; Wz Sp/HG Spannen
    ;-----------------
    rTmp1=0 rTmp2=0
    IF (bRelPrep_Clmp_UnClmp)
      ;
      ;Vorhaltewerte ermitteln - Begrenzt auf halben Weg und Bremsrampe
      rVelo=rFeedDGRot/60 rTmp=0.5*(rNextPosDGRot-rFirstPosDGRot)/rVelo
      IF (rVelo<2*rMaxVjDG)
        rActJerk=rMaxJerkDG*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjDG-rVelo)/(2*rMaxVjDG)))) rPosTime=2*SQRT(rVelo/rActJerk)
      ELSE
        ;mit konstanter Beschleunigung
        rPosTime=(rVelo/rMaxAccelDG+rMaxTjDG)
      ENDIF
      ;
      IF (rSpClmpTime>0)AND(bNewTlFast)AND(bRelPreClmp)
        ;
        ;Spindel
        rTmp1=MINVAL(rSpClmpTime,rPosTime) rTmp1=0.5*MINVAL(rTmp1,rTmp)/(rSafeCalcDG*60)
      ENDIF
      ;
      IF (rHGClmpTime>0)AND(bOldTlFast)AND(bRelPreClmp)
        ;
        ;HG
        rTmp2=MINVAL(rHGClmpTime,rPosTime) rTmp2=0.5*MINVAL(rTmp2,rTmp)/(rSafeCalcDG*60)
      ENDIF
    ENDIF
    ;
    ;-811.15--WzW----------
    ; Fliegendes, voreilendes Wz Spannen fuer
    ; MagWz: immer
    ; SpWz:  nur mit Wz
    ; (zusaetzlich Sp Spannzeit starten
    ;  und Anzeigen, dass gespannt wird)
    ;---------------------
    ;
    CANCEL(SyncID_TC+4,SyncID_TC+5)
    ;
    IF (bTlClmp)
      ;
      ;SpWz Spannen freigegeben
      ;
      IF (iNewTNo>0)AND(NOT bNewIsManTl)
        ;
        ;Wz aus Magazin in DG -> Sp Spannen mit Wz
        iNo=MQ_SpClmpTl
      ELSE
        ;
        ;Sonst -> Sp Spannen ohne Wz
        iNo=MQ_SpClmpNoTl
      ENDIF
      ;
      IDS=SyncID_TC+4 WHEN ((mcActPosDGRot>=rNextPosDGRot-grPosWinDGRot)OR((bRelPreClmp)AND(mcActPosDGRot>=(rNextPosDGRot-rTmp1*MINVAL(ABS($VA_VACTM[mcAxDGRot]),rFeedDGRot)))AND(bNewTlFast)AND(SYG_IM[iSYG+3]==1))) DO M=QU(iNo) SYG_RM[iSYG+2]=grSpClmpTimeC SYG_IM[iSYG]=icClmpStep
    ENDIF
    ;
    ;HG immer Spannen
    IDS=SyncID_TC+5 WHEN ((mcActPosDGRot>=rNextPosDGRot-grPosWinDGRot)OR((bRelPreClmp)AND(mcActPosDGRot>=(rNextPosDGRot-rTmp2*MINVAL(ABS($VA_VACTM[mcAxDGRot]),rFeedDGRot)))AND(bOldTlFast)AND(SYG_IM[iSYG+3]==1))) DO M=QU(MQ_HGClmpTl)
  ELSE
    ;
    ;Das NeuWz soll gespannt uebergeben werden
    ;
    ;-811.7--WzW------------------------------------------
    ; DG in Uebergabeposition -> in Position NeuWz Starten
    ;-----------------------------------------------------
    CANCEL(SyncID_TC+3)
    ID=SyncID_TC+3 WHEN (mcbDBB_ChInPos)AND(($A_DBB[0] B_AND iSpMask)<>0)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) DO FA[mcAxDGRot]=rFeedDGRot POS[mcAxDGRot]=ACP(rNextPosDGRot) SYG_IM[iSYG]=3 mcDBB_StepTC=iHomeStatus
    ;
    IF (bTlClmp)
      ;
      ;-811.8--WzW----------------
      ; Geschwindigkeitsermittlung
      ;---------------------------
      ID=SyncID_TC+7 WHENEVER (SYG_IM[iSYG]==3) DO SYG_RM[iSYG+1]=$VA_VACTM[mcAxDGRot]-SYG_RM[iSYG] SYG_RM[iSYG]=$VA_VACTM[mcAxDGRot]
    ENDIF
  ENDIF
ENDIF

;-[MTC]-812.0--WzW-
; Start DG
;------------------
IF (bDGIsMTC)
  ;
  IF (iOldTNo<=0)AND(iNewTNo>0)
    ;
    ;SpWz Einwechseln: Hg/Sp loesen -> DG Schwenken -> Hg/Sp Spannen (NeuWz in SP)
    giTCStartDBB4=$A_DBB[4]
    H80=QU(iH80) M=QU(261)
    gbDg2MagSide=FALSE
  ENDIF
  ;
  IF (iOldTNo>0)AND((iNewTNo<=0)OR((iNewTNo>0)AND(bNewIsManTl)))
    ;
    ;SpWz Auswechseln: Hg/Sp Loesen-> DG Schwenken -> Hg/Sp Spannen (AltWz im HG/DG)
    giTCStartDBB4=$A_DBB[4]
    H80=QU(iH80) M=QU(262)
    gbDg2MagSide=FALSE
  ENDIF
  ;
  IF (iOldTNo>0)AND(iNewTNo>0)
    ;
    ;WzW: Hg/Sp loesen -> DG Schwenken -> Hg/Sp Spannen(NeuWz in SP/AltWz im HG/DG)
    giTCStartDBB4=$A_DBB[4]
    H80=QU(iH80) M=QU(263)
    gbDg2MagSide=FALSE
  ENDIF
ENDIF

;-[DISK]-813.0--WzW-
; X ist in TCPosX
;-------------------
;
IF (bMagIsPickUpDisk)
  ;
  IF (bFxPlUnload)
    ;
    ;-813.1--WzW----------------------------
    ; SpWz Entladen:
    ; Wz in Sp und Sp Geloest -> Scheibe Vor
    ;---------------------------------------
    ;
    ;Sp Geloest
    IF (bRelSpSw)
      iSpMask='B100100'
    ELSE
      iSpMask='B100'
    ENDIF
    ;
    IF (iNewTNo>0)
      iResult=1 ; Freigabe VT1 Achse
    ELSE
      iResult=2 ; Freigabe NeuWz Beladen
    ENDIF
    ;
    ;Info fuer TMRESET
    grSyncPickupDrop=ITOR(iOldTNo*100000)+iSpUnLoadMag*1000+iSpUnLoadLoc
    ;
    ;Spindel geloest -> Scheibe Ausheben -> SpWz in Scheibe
    CANCEL(SyncID_TC+5)
    ID=SyncID_TC+5 WHEN (($A_DBB[0] B_AND iSpMask)<>0) DO M=QU(MQ_DiskAdv) SYG_IM[iSYG+2]=iResult mcDBB_StepTC=iHomeStatus
  ENDIF
  ;
  ;Scheibe ist ausgehoben
  ;
  IF (bRelAuxSw)
    iAuxAdr=68 iAuxMask='B1100' iAuxResult='B1000'
  ELSE
    iAuxAdr=1 iAuxMask='B11' iAuxResult='B10'
  ENDIF
  ;
  IF (iNewTNo>0)AND(NOT bNewIsManTl)
    ;
    ;Mit NeuWz
    ;
    IF (iMagPos<>iSpLoadLoc)
      ;
      ;Scheibe nicht in Position NeuWz
      ;
      ;-813.2--WzW-----------
      ; Scheibe Positionieren
      ;----------------------
      GETD(mcAxV1)
      ;
      ;Zielposition ermitteln, NeuWz Beladen gestartet
      ;
      rTargetPos=(iSpLoadLoc-1)*rMagPlDist iHomeStatus=(iHomeStatus B_AND 'B11') B_OR 'B1000'
      ;
      ;Ausheben gestartet, Ausgehoben -> Scheibe in Position NeuWz
      ;
      CANCEL(SyncID_TC+3)
      ID=SyncID_TC+3 WHEN (SYG_IM[iSYG+2]==1)AND(($A_DBB[iAuxAdr] B_AND iAuxmask)==iAuxResult) DO FA[mcAxV1]=rFeedV1 POS[mcAxV1]=DC(rTargetPos) SYG_IM[iSYG+2]=2 mcDBB_StepTC=iHomeStatus
    ELSE
      ;
      ;Scheibe in Position NeuWz
      ;
      ;-813.3--WzW-----------
      ; NeuWz Beladen starten
      ;----------------------
      SYG_IM[iSYG+2]=2 mcDBB_StepTC=iHomeStatus
    ENDIF
  ENDIF
  ;
  IF (gbSpIsUnClmpFixed)
    ;
    ;-813.4--WzW------------------------------
    ; SpWz ist geloest und mechanisch geklemmt
    ; -> Lagehaltung aus -> Momentenabbau
    ;-----------------------------------------
    SPCOF
  ENDIF
ENDIF

;-[]-850.0--WzHaushalt-
; Synchronisieren DG
;----------------------
IF (iOldTNo>0)AND(iNewTNo>0)AND(NOT bNewIsManTl)AND(NOT bFxPlUnLoad)AND(NOT bFxPlLoad)
  ;
  IF (iToDo==mcTaskPrep)
    ;
    IF (gbWithDG)
      iTmp1=iNewTNo iNewTlMag=9998 iNewTlLoc=mcLocDG1 iTmp2=iOldTNo iOldTlMag=9998 iOldTlLoc=mcLocDG2 iState=105
    ENDIF
  ELSE
    ;
    IF (bMagIsMiksch)OR(gbWithHG) GOTOF SYNC_TOOL
    ;
    ;Beladen/Entladen ueber Beladestelle_Hand, Spindel asynchron leerfahren, Wz asynchron zur Spindel bringen
    ;
    IF (iToDo==mcTaskLoad)OR(iToDo==mcTaskUnload)
      iState=105
    ELSE
      ;asynchroner Auftrag -> nur Status=1 erlaubt
      iState=1
    ENDIF
    ;
    IF (iToDo==mcTaskUnload)
      ;
      ;-850.1--DG WzHaushalt--------------------------
      ; Entladen / Wz asynchron zur Spindel bringen
      ; HG -> DG1 ( (EntladeWz / neues SpWz = iNewTNo)
      ;-----------------------------------------------
      iTmp1=iNewTNo iNewTlMag=9998 iNewTlLoc=mcLocDG1 iTmp2=0 iOldTlMag=9998 iOldTlLoc=mcLocHG
    ELSE
      ;
      ;-850.2--DG WzHaushalt------------------
      ; Beladen / Spindel asynchron Leerfahren
      ; SP -> DG2 (BeladeWz / SpWz = iOldTNo)
      ;---------------------------------------
      iTmp1=iOldTNo iNewTlMag=9998 iNewTlLoc=mcLocDG2 iTmp2=0 iOldTlMag=9998 iOldTlLoc=mcLocSP
    ENDIF
  ENDIF
  IF (bPutM206)
    M206
    bPutM206=FALSE
  ENDIF
  ;Quittierung HG/Kette->DG1 bzw. SP->DG2 umgespeichert
  ToAckn(TRUE,iTaskId,iTaskIdNo,iTmp1,iTmp2,iNewTlMag,iNewTlLoc,iOldTlMag,iOldTlLoc,iState)
  ;
  giSyncTC=2
ENDIF

;-[]-851.0--WzHaushalt-----
; Synchronisieren Sp/HG/Mag
;--------------------------
;
;=========
SYNC_TOOL:
;=========
;
IF (iToDo==mcTaskPrep)
  ;
  iTmp1=iNewTNo iNewTlMag=-1 iNewTlLoc=-1 iTmp2=iOldTNo iOldTlMag=-1 iOldTlLoc=-1 iState=1
  ;
  IF (bFxPlUnLoad)
    ;
    ;-851.0--WzHaushalt-
    ; SpWz Entladen
    ;-------------------
    IF (iNewTNo>0)
      ;
      ;Beladevorgang folgt -> Asynchron Entladen
      iTmp1=iOldTNo iOldTlMag=iSpUnLoadMag iOldTlLoc=iSpUnLoadLoc
      ToAckn(TRUE,5,iTaskIdNo,iTmp1,0,iOldTlMag,iOldTlLoc,9998,mcLocSp,1)
      ;
      GOTOF SYNC_FINISHED
    ELSE
      ;
      iOldTlMag=iSpUnLoadMag iOldTlLoc=iSpUnLoadLoc
      GOTOF M_206_TO_PLC
    ENDIF
  ENDIF
  ;
  IF (bFxPlLoad)
    ;
    ;-851.1--WzHaushalt-
    ; SpWz Beladen
    ;-------------------
    IF (NOT bNewIsManTl)
      iNewTlMag=9998 iNewTlLoc=mcLocSp
    ENDIF
    GOTOF M_206_TO_PLC
  ENDIF
  ;
  ;-851.2--SpWz Austauschen-
  ;-------------------------
  ;
  IF (iNewTNo>0)
    ;
    IF (NOT bNewIsManTl)
      ;
      ;Endgueltig in Sp umspeichern
      iNewTlMag=9998 iNewTlLoc=mcLocSP
    ELSE
      ;
      ;NeuWz ist HandWz -> Einwechseln wird erst unten ausgefuehrt (nur Vorab-Quittierung)
      iState=105
    ENDIF
  ENDIF
  ;
  IF (iOldTNo>0)
    iOldTlMag=iSpUnLoadMag iOldTlLoc=iSpUnLoadLoc
  ENDIF
ELSE
  ;
  IF (iToDo==mcTaskUnload)OR((iToDo==mcTaskLoad)AND((gbWithHG)OR(bMagIsMiksch)))
    ;
    ;nur Vorab-Quittierung
    iState=105
  ELSE
    ;
    ;Endgueltig Umspeichern
    iState=1
  ENDIF
  ;
  IF (iToDo==mcTaskUnload)
    ;
    ;-851.3--WzHaushalt---------------
    ; Entladen
    ; HG/Mag/DG2 -> Sp
    ; EntladeWz/neues SpWz = iNewTNo
    ;---------------------------------
    iTmp1=iNewTNo iNewTlMag=9998 iNewTlLoc=mcLocSP iTmp2=0 iOldTlMag=iSpLoadMag iOldTlLoc=iSpLoadLoc
  ELSE
    ;-851.4--WzHaushalt------------------------
    ; Beladen bzw. Spindel asynchron Leerfahren
    ; SP -> HG/Mag/DG1
    ; BeladeWz/SpWz = iOldTNo
    ;------------------------------------------
    iTmp1=iOldTNo iNewTlMag=iSpUnLoadMag iNewTlLoc=iSpUnLoadLoc iTmp2=0 iOldTlMag=9998 iOldTlLoc=mcLocSP
  ENDIF
ENDIF
;
;============
M_206_TO_PLC:
;============
;
;-[]-852.0--WzHaushalt-
; Umspeichern
;----------------------
IF (bPutM206)
  M206
  bPutM206=FALSE
ENDIF
ToAckn(TRUE,iTaskId,iTaskIdNo,iTmp1,iTmp2,iNewTlMag,iNewTlLoc,iOldTlMag,iOldTlLoc,iState)
;
;=============
SYNC_FINISHED:
;=============
;
giSyncTC=3
;
;-[WM286]-870.0--DG GndSt----------
; NeuWz Uebernehmen, GndSt anfahren
;----------------------------------
IF (bDGIsWM286)
  ;
  ;-870.1--WzW----------------------
  ; Geschwindigkeit beim Spannbefehl
  ;---------------------------------
  iErrCount=0 rPosWin=0 rPosTime=0 bEnabled=FALSE rTargetPos=rNextPosDGRot rSpVelo=-1 rHGVelo=-1
  REPEAT
    ;
    ;Status DG
    rActVelo=ABS(SYG_RM[iSYG]) rActVeloDiff=SYG_RM[iSYG+1] rActPos=mcActPosDGRot rVelo=(rActVelo+ABS(rActVeloDiff))/60 bEnabled=(SYG_IM[iSYG]==3) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=870.1
    IF (bEnabled)AND(rVelo>0)
      ;
      ;Abbremsen DG
      IF rVelo<2*rMaxVjDG
        rActJerk=rMaxJerkDG*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjDG-rVelo)/(2*rMaxVjDG)))) rPosTime=2*SQRT(rVelo/rActJerk) rActTj=rPosTime*0.5
      ELSE
        rPosTime=rVelo/rMaxAccelDG+rMaxTjDG rActTj=rMaxTjDG rActJerk=rMaxJerkDG
      ENDIF
      ;
      ;Achse bremst
      rPosWin=0.5*rVelo*rPosTime+grPosWinDGRot bEnabled=(rActVeloDiff<0)AND(ABS(rActPos-rTargetPos)<=rPosWin)
    ELSE
      bEnabled=FALSE
    ENDIF
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)OR(ABS(rActPos-rTargetPos)<=grPosWinDGRot)
  ;
  CANCEL(SyncID_TC+7)
  ;
  IF (bRelPrep_Clmp_UnClmp)AND(bEnabled)AND(bRelPreClmp)
    ;
    ;-870.2--WzW----
    ; Modellrechnung
    ;---------------
    rTmp2=EXP(1/3*LN(6*grPosWinDGRot/rActJerk))
    ;
    IF (rSpClmpTime>0)
      ;
      ;Spindel
      ;
      ;Begrenzung auf Bremsrampe
      rSpClmpTime=MINVAL(rPosTime,rSpClmpTime+rTmp2)
      IF (rSpClmpTime<=rActTj)
        rSpVelo=0.5*rActJerk*rSpClmpTime*rSpClmpTime*60
      ELSE
        IF (rSpClmpTime<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
          rSpVelo=(rMaxAccelDG*(rSpClmpTime-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rSpClmpTime
          rSpVelo=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
      ;
      rTmp=rSpClmpTime-rSpVeloWindow
      IF (rTmp<=rActTj)
        rSpVeloMin=0.5*rActJerk*rTmp*rTmp*60
      ELSE
        IF (rTmp<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
          rSpVeloMin=(rMaxAccelDG*(rTmp-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rTmp
          rSpVeloMin=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
      ;
      IF (rActVelo<=rSpVeloMin)
        ;
        ;Achse ist schon zu langsam
        rSpVeloMin=0
      ENDIF
    ENDIF
    ;
    ;HG
    ;
    IF (rHGClmpTime>0)
      ;
      rHGClmpTime=MINVAL(rPosTime,rHGClmpTime+rTmp2)
      IF (rHGClmpTime<=rActTj)
        rHGVelo=0.5*rActJerk*rHGClmpTime*rHGClmpTime*60
      ELSE
        IF (rHGClmpTime<rPosTime-rMaxTjDG)AND(rActTj==rMaxTjDG)
          rHGVelo=(rMaxAccelDG*(rHGClmpTime-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rHGClmpTime
          rHGVelo=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
      ;
      rTmp=rHGClmpTime-rSpVeloWindow
      IF (rTmp<=rActTj)
        rHGVeloMin=0.5*rActJerk*rTmp*rTmp*60
      ELSE
        IF (rTmp<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
          rHGVeloMin=(rMaxAccelDG*(rTmp-rMaxTjDG)+rMaxVjDG)*60
        ELSE
          rTmp=rPosTime-rTmp
          rHGVeloMin=(rVelo-0.5*rActJerk*rTmp*rTmp)*60
        ENDIF
      ENDIF
      ;
      IF (rActVelo<=rHGVeloMin)
        ;
        ;Achse ist schon zu langsam
        rHGVeloMin=0
      ENDIF
    ENDIF
  ENDIF
  ;
  ;-870.3--WzW-
  ; Sp Spannen
  ;------------
  ;
  IF (iNewTNo>0)AND(NOT bNewIsManTl)
    ;
    ;Wz aus Magazin in DG -> Sp Spannen mit Wz
    iNo=MQ_SpClmpTl
  ELSE
    ;
    ;Sonst -> Sp Spannen ohne Wz
    iNo=MQ_SpClmpNoTl
  ENDIF
  ;
  IDS=SyncID_TC+4 WHEN ((ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)OR((ABS($VA_VACTM[mcAxDGRot])<=rSpVelo)AND(ABS($VA_VACTM[mcAxDGRot])>=rSpVeloMin)AND(bNewTlFast)AND(SYG_IM[iSYG+3]==1))) DO M=QU(iNo) SYG_RM[iSYG+2]=grSpClmpTimeC SYG_IM[iSYG]=icClmpStep
  ;
  ;Wz zu Entladen -> HG Spannen
  IDS=SyncID_TC+5 WHEN ((ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)OR((ABS($VA_VACTM[mcAxDGRot])<=rHGVelo)AND(ABS($VA_VACTM[mcAxDGRot])>=rHGVeloMin)AND(bOldTlFast)AND(SYG_IM[iSYG+3]==1))) DO M=QU(MQ_HGClmpTl)
  ;
  IF (gbSpIsUnClmpFixed)
    ;
    ;-870.4--WzW------------------------------
    ; SpWz ist geloest und mechanisch geklemmt
    ; -> Lagehaltung aus -> Momentenabbau
    ;-----------------------------------------
    SPCOF
  ENDIF
  ;
  ;-870.10--GndSt DG--------
  ; DG Start in GndSt sobald
  ; Spindel mit/ohne Wz und
  ; HG gespannt kommt
  ;-------------------------
  ;
  IF (bRelSpSw)
    iSpMask='B11011'
  ELSE
    iSpMask='B11'
  ENDIF
  ;
  IF (bRelAuxSw)
    iAuxAdr=68 iAuxMask='B11' iAuxResult='B1'
  ELSE
    iAuxAdr=1 iAuxMask='B1100' iAuxResult='B100'
  ENDIF
  ;
  CANCEL(SyncID_TC+3)
  IF (bTurnNeg)
    ID=SyncID_TC+3 WHEN (($A_DBB[0] B_AND iSpMask)<>0)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) DO FA[mcAxDGRot]=rFeedEmptyDGRot POS[mcAxDGRot]=ACN(rEndPosDGRot) SYG_IM[iSYG]=4
  ELSE
    ID=SyncID_TC+3 WHEN (($A_DBB[0] B_AND iSpMask)<>0)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) DO FA[mcAxDGRot]=rFeedEmptyDGRot POS[mcAxDGRot]=ACP(rEndPosDGRot) SYG_IM[iSYG]=4
  ENDIF
  ;
  ;-870.11--GndSt DG--------------
  ; - DG grob in Position
  ; - Werkzeuge sind ausgetauscht
  ;------------------------------
  iErrCount=0
  REPEAT
    bEnabled=(ABS(mcActPosDGRot-rNextPosDGRot)<grPosWinDGRot) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=870.11
    IF (NOT bEnabled)
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
        GOTOF HandleAlarm
      ENDIF
      G4 F=rWaitShort
    ENDIF
  UNTIL (bEnabled)
  ;
ENDIF
;
;-[MTC]-871.0--GndSt DG-
;-----------------------
IF (bDGIsMTC)
  ;
  IF (gbSpIsUnClmpFixed)
    ;
    ;-871.1--GndSt DG-------------------------
    ; SpWz ist geloest und mechanisch geklemmt
    ; -> Lagehaltung aus -> Momentenabbau
    ;-----------------------------------------
    SPCOF
  ENDIF
  ;
  IF (bFast)
    ;
    ;-871.2--GndSt DG--------------------
    ; PLC setzt ELSP, bis DG zurueckzieht
    ;------------------------------------
    ;
    CANCEL(SyncID_TC+4,SyncID_TC+5)
    ;
    WHENEVER (mcActPosDGRot<190)OR(((giTCStartDBB4 B_XOR $A_DBB[4]) B_AND 'B10000')==0) DO RDISABLE
    STOPRE
    ;
    gbDg2MagSide=(bMagIsMiksch)AND(iOldTNo>0)
    ;
    IF (bRelPreClmp)
      ;
      ;SpWz und HG voreilend Spannen
      ;
      IF (iNewTNo>0)AND(NOT bNewIsManTl)
        ;
        ;Wz aus Magazin in DG -> Sp Spannen mit Wz
        iNo=MQ_SpClmpTl
      ELSE
        ;
        ;Sonst -> Sp Spannen ohne Wz
        iNo=MQ_SpClmpNoTl
      ENDIF
      ;
      IF (bNewTlFast)
        ID=SyncID_TC+4 WHEN (mcActPosDGRot>grHor2DGRot)AND((mcActPosDGRot-SYG_RM[iSYG])>=grLowFeedDGRot)AND(NOT OUT_DGRotInBasePos) DO M=QU(iNo) SYG_IM[iSYG]=icClmpStep
      ENDIF
      ;
      IF (bOldTlFast)AND(NOT bMagIsMiksch)
        ID=SyncID_TC+5 WHEN (mcActPosDGRot>grHor2DGRot)AND((mcActPosDGRot-SYG_RM[iSYG])>=grLowFeedDGRot)AND(NOT OUT_DGRotInBasePos) DO M=QU(MQ_HgClmpTl)
      ENDIF
    ENDIF
  ELSE
    ;
    ;-871.3--GndSt DG------------------------
    ; PLC setzt ELSP, bis PLC WzW beendet hat
    ; (Wz sind jetzt getauscht)
    ;----------------------------------------
    M_WaitTcFinished1
    ;
    gbDg2MagSide=(bMagIsMiksch)AND(iOldTNo>0)AND(((giTCStartDBB4 B_XOR $A_DBB[4]) B_AND 'B10000')<>0)
  ENDIF
ENDIF

;-[DISK]-872.0--NeuWz Beladen-
;-----------------------------
;
IF (bMagIsPickUpDisk)
  ;
  ;Fuer folgende Ueberwachungen
  iErrCount=0
  ;
  IF (iNewTNo>0)AND(NOT bNewIsManTl)
    ;
    ;Mit NeuWz
    ;
    IF (NOT bSecLoop)
      ;
      ;-872.1--NeuWz Beladen-------------------
      ; Warten bis Scheibe in Position und Vorn
      ;----------------------------------------
      REPEAT
        iMagPos=OUTA_ActPosV1 bEnabled=(SYG_IM[iSYG+2]==2)AND($AA_STAT[mcAxV1]==4)AND(($A_DBB[1] B_AND 'B11')=='B10')AND(iMagPos==iSpLoadLoc) iErrCount=(iErrCount+SYG_IM[iSYGInc]) mcDBW_WaitDiskRetract=1  SYG_RM[iSYGArea]=872.1
        IF (NOT bEnabled)
          G4 F=rWaitShort
          IF (iErrCount>=iErrTimeShort)
            iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxV1)
            GOTOF HandleAlarm
          ENDIF
        ENDIF
      UNTIL (bEnabled)
      ;
      ;Spindel geloest
      IF (bRelSpSw)
        iSpMask='B100100'
      ELSE
        iSpMask='B100'
      ENDIF
      ;
      ;Scheibe abgesenkt
      IF (bRelAuxSw)
        iAuxAdr=68 iAuxMask='B1100' iAuxResult='B100'
      ELSE
        iAuxAdr=1 iAuxMask='B11' iAuxResult='B1'
      ENDIF
      ;
      bRetractDisk=FALSE grSyncPickupDrop=(ITOR(iNewTNo*100000)+iSpLoadMag*1000+iSpLoadLoc)
      ;
      ;-872.2--NeuWz Beladen-------------------------------------------
      ; Scheibe ist in Position NeuWz und Sp geloest -> Scheibe Zurueck
      ;----------------------------------------------------------------
      CANCEL(SyncID_TC+4,SyncID_TC+5)
      ID=SyncID_TC+5 WHEN ($AA_STAT[mcAxV1]==4)AND(($A_DBB[0] B_AND iSpMask)<>0) DO SYG_IM[iSYG+2]=3 M=QU(MQ_DiskRet)
      ;
      ;-872.3--NeuWz Beladen-----------
      ; Scheibe Hinten -> NeuWz Klemmen
      ;--------------------------------
      IDS=SyncID_TC+4 WHEN (SYG_IM[iSYG+2]==3)AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) DO M=QU(MQ_SpClmpTl) SYG_IM[iSYG+2]=4 SYG_RM[iSYG+2]=grSpClmpTimeC SYG_IM[iSYG]=icClmpStep
      ;
      IF (bFxPlUnload)
        ;
        ;-872.4--NeuWz Beladen---------
        ; NeuWz in Sp -> WzV abgleichen
        ;------------------------------
        bFxPlUnload=FALSE bFxPlLoad=TRUE giSyncTC=1 bSecLoop=TRUE
        GOTOB SYNC_TOOL
      ENDIF
    ELSE
      ;
      ;-872.5--NeuWz Beladen-------------
      ; - Wz Daten sind umgespeichert
      ; - Warten auf Scheibe im Genauhalt
      ; - Uergeben der Scheibe an Kanal 2
      ; - Scheibe nach Hinten freigeben,
      ;   wenn sie noch nicht Hinten ist
      ;----------------------------------
      REPEAT
        bEnabled=($AA_STAT[mcAxV1]==4) bRetractDisk=(($A_DBB[1] B_AND 'B11')<>'B1') iErrCount=(iErrCount+SYG_IM[iSYGInc]) mcDBW_WaitDiskRetract=1 SYG_RM[iSYGArea]=872.5
        IF (NOT bEnabled)
          ;
          IF (iErrCount>=iWaitCha2)
            iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxV1)
            GOTOF HandleAlarm
          ENDIF
          G4 F=rWaitShort
        ENDIF
      UNTIL (bEnabled)
      ;
      ;VT1 Neutrale Achse
      RELEASE(mcAxV1)
      ;
    ENDIF
  ELSE
    ;
    ;-873.0-Ende SpWz Entladen-
    ; - Scheibe Vorn
    ; - kein NeuWz oder NeuWz
    ;   ist HandWz
    ; - Sp ist leer
    ; -> Sp Spannen ohne Wz,
    ;    Scheibe Zurueck freigeben
    ;-----------------------------
    IF (bRelAuxSw)
      iAuxAdr=68 iAuxMask='B1100' iAuxResult='B1000'
    ELSE
      iAuxAdr=1 iAuxMask='B11' iAuxResult='B10'
    ENDIF
    ;
    ;-873.1-Ende SpWz Entladen-
    ; Warten bis Scheibe Vorn
    ;--------------------------
    REPEAT
      bEnabled=(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) bRetractDisk=(($A_DBB[1] B_AND 'B11')<>'B1')AND(gbWithMagPanel) iErrCount=(iErrCount+SYG_IM[iSYGInc]) mcDBW_WaitDiskRetract=RTOI(icWaitDiskRetract/rIpo+1) SYG_RM[iSYGArea]=873.1
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxV1)<<"/Z"
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    ;-873.2-Ende SpWz Entladen-
    ; Sp Klemmen ohne Wz
    ;--------------------------
    CANCEL(SyncID_TC+4)
    ID=SyncID_TC+4 WHEN (TRUE) DO M=QU(MQ_SpClmpNoTl) mcDBB_StepTC=iHomeStatus SYG_IM[iSYG+2]=4 SYG_RM[iSYG+2]=grSpClmpTimeC SYG_IM[iSYG]=icClmpStep
    ;
  ENDIF
  ;
  IF (bRetractDisk)
    ;
    ;Beladen NeuWz und Scheibe noch nicht Hinten
    ;
    ;-874.0--GndSt Scheibe-----
    ; - X nicht mehr im Magazin
    ; - Wartezeit abgelaufen
    ; -> Scheibe Zurueck
    ;--------------------------
    CANCEL(SyncID_TC+5)
    ID=SyncID_TC+5 WHEN ((grTCPrePosX+rc0x1mm)>$VA_IM[mcAxX])AND(mcDBW_WaitDiskRetract==1) DO M=QU(MQ_DiskRet)
  ENDIF
  ;
  bFxPlUnload=FALSE bFxPlLoad=FALSE
ENDIF

;-[WM307]-880.0--WzW-
;--------------------
;
IF (bDGIsWM307)
  ;
  IF (bRelMoveUnClmp_C)AND(NOT bNewTlFast)
    ;
    ;Das NeuWz ist kein schnelles Wz und wird gespannt uebernommen
    ;
    ;-880.1--WzW------
    ; Sp/Kette Spannen
    ;-----------------
    ;
    IF (bRelSpSw)
      iSpMask='B11011'
    ELSE
      iSpMask='B11'
    ENDIF
    ;
    IF (bTlClmp)
      ;
      ;-880.2--WzW----------------------
      ; Geschwindigkeit beim Spannbefehl
      ;---------------------------------
      iErrCount=0 rPosWin=0 rPosTime=0 bEnabled=FALSE rTargetPos=rNextPosDGRot rSpVelo=-1
      REPEAT
        ;
        ;Status DG
        rActVelo=ABS(SYG_RM[iSYG]) rActVeloDiff=SYG_RM[iSYG+1] rActPos=mcActPosDGRot rVelo=(rActVelo+ABS(rActVeloDiff))/60 bEnabled=(SYG_IM[iSYG]==3) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=880.2
        IF (bEnabled)AND(rVelo>0)
          ;
          ;Abbremsen DG
          IF rVelo<2*rMaxVjDG
            rActJerk=rMaxJerkDG*(1-EXP(grTCJerkRedExp*LN((2*rMaxVjDG-rVelo)/(2*rMaxVjDG)))) rPosTime=2*SQRT(rVelo/rActJerk) rActTj=rPosTime*0.5
          ELSE
            rPosTime=rVelo/rMaxAccelDG+rMaxTjDG rActTj=rMaxTjDG rActJerk=rMaxJerkDG
          ENDIF
          ;
          ;Achse bremst
          rPosWin=0.5*rVelo*rPosTime+grPosWinDGRot bEnabled=(rActVeloDiff<0)AND(ABS(rActPos-rTargetPos)<=rPosWin)
        ELSE
          bEnabled=FALSE
        ENDIF
        IF (NOT bEnabled)
          IF (iErrCount>=iErrTimeShort)
            iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
            GOTOF HandleAlarm
          ENDIF
          G4 F=rWaitShort
        ENDIF
      UNTIL (bEnabled)OR(ABS(rActPos-rTargetPos)<=grPosWinDGRot)
      ;
      CANCEL(SyncID_TC+7)
      ;
      IF (bRelPrep_Clmp_UnClmp)AND(bEnabled)AND(bRelPreClmp)
        ;
        ;-880.3--WzW----
        ; Modellrechnung
        ;---------------
        rTmp2=EXP(1/3*LN(6*grPosWinDGRot/rActJerk))
        ;
        IF (rSpClmpTime>0)
          ;
          ;Spindel
          ;
          ;Begrenzung auf Bremsrampe
          rSpClmpTime=MINVAL(rPosTime,rSpClmpTime+rTmp2)
          IF (rSpClmpTime<=rActTj)
            rSpVelo=0.5*rActJerk*rSpClmpTime*rSpClmpTime*60
          ELSE
            IF (rSpClmpTime<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
              rSpVelo=(rMaxAccelDG*(rSpClmpTime-rMaxTjDG)+rMaxVjDG)*60
            ELSE
              rTmp1=rPosTime-rSpClmpTime
              rSpVelo=(rVelo-0.5*rActJerk*rTmp1*rTmp1)*60
            ENDIF
          ENDIF
          ;
          rTmp1=rSpClmpTime-rSpVeloWindow
          IF (rTmp1<=rActTj)
            rSpVeloMin=0.5*rActJerk*rTmp1*rTmp1*60
          ELSE
            IF (rTmp1<rPosTime-rActTj)AND(rActTj==rMaxTjDG)
              rSpVeloMin=(rMaxAccelDG*(rTmp1-rMaxTjDG)+rMaxVjDG)*60
            ELSE
              rTmp1=rPosTime-rTmp1
              rSpVeloMin=(rVelo-0.5*rActJerk*rTmp1*rTmp1)*60
            ENDIF
          ENDIF
          ;
          IF (rActVelo<=rSpVeloMin)
            ;
            ;Achse ist schon zu langsam
            rSpVeloMin=0
          ENDIF
        ENDIF
      ENDIF
      ;
      ;-880.4--WzW-
      ; Spannen
      ;------------
      ;
      ;Wz Spannen freigegeben
      ;
      IF (iNewTNo>0)AND(NOT bNewIsManTl)
        ;
        ;Wz aus Magazin in DG -> Sp Spannen mit Wz
        iNo=MQ_SpClmpTl iSpMask=(iSpMask B_AND 'B1001')
      ELSE
        ;
        ;Sonst -> Sp Spannen ohne Wz
        iNo=MQ_SpClmpNoTl
      ENDIF
      ;
      CANCEL(SyncID_TC+4)
      IDS=SyncID_TC+4 WHEN ((ABS(mcActPosDGRot-rTargetPos)<=grPosWinDGRot)OR((ABS($VA_VACTM[mcAxDGRot])<=rSpVelo)AND(ABS($VA_VACTM[mcAxDGRot])>=rSpVeloMin)AND(SYG_IM[iSYG+3]==1))) DO M=QU(iNo) SYG_RM[iSYG+2]=grSpClmpTimeC SYG_IM[iSYG]=icClmpStep
      ;
    ENDIF
    ;
    ;Kette Klemmen
    CANCEL(SyncID_TC+5)
    IDS=SyncID_TC+5 WHEN (SYG_IM[iSYG]>=3)AND(ABS(mcActPosDGRot-rNextPosDGRot)<=grPosWinDGRot) DO M=QU(MQ_HGClmpTl)
    ;
    ;-880.5--WzW------------------------------------
    ; Warten bis DG in Uebergabeposition NeuWz steht
    ;-----------------------------------------------
    iErrCount=0
    REPEAT
      bEnabled=(SYG_IM[iSYG]>=3)AND($AA_STAT[mcAxDGRot]>=3)AND((mcActPosDGRot-rNextPosDGRot)<=grPosWinDGRot) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=880.5
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    ;-880.6--WzW----------------------------
    ; Sp gespannt -> Start DG in Endposition
    ;---------------------------------------
    CANCEL(SyncID_TC+3)
    ID=SyncID_TC+3 WHEN ((($A_DBB[0] B_AND iSpMask)<>0)OR(NOT bTlClmp)) DO FA[mcAxDGRot]=rFeedEmptyDGRot POS[mcAxDGRot]=ACP(rEndPosDGRot)
    ;
  ENDIF
  ;
  ;-890.0--Kette Festplatz Wz---------------------
  ; Erst Entladen SpWZ dann neues Werkzeug Beladen
  ;-----------------------------------------------
  ;
  IF (bFxPlUnload)AND(iNewTNo>0)
    ;
    ;-890.1--Kette Festplatz Wz-------------
    ; - Warten bis DG in Freigabefenster
    ; - Abfrage ob Wz in Kette gespannt (AK)
    ;---------------------------------------
    REPEAT
      bEnabled=((mcActPosDGRot>=(360-rRelMagDGRot))OR(mcActPosDGRot<=rRelMagDGRot))AND(gbPrepActiv)AND(NOT gbPrepEnd)AND(($A_DBB[68] B_AND 'B11')=='B1') iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=890.1
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iWaitCha2)
          iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)<<",gbPrepActiv"
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    CANCEL(SyncID_TC+3,SyncID_TC+4,SyncID_TC+5,SyncID_TC+7,SyncID_TC+8)
    ;
    IF (NOT bNewIsManTl)
      ;
      ;-890.2--Kette Festplatz Wz-------
      ; - NeuWz bereitstellen -> Kanal 2
      ; - Freigabe Wz Spannen bei der
      ;   folgenden DG Drehung
      ;---------------------------------
      iErrCount=0 bSecLoop=TRUE bFxPlUnload=FALSE bFxPlLoad=TRUE giSyncTC=0 giTlInSp=-1 giNextTlInSp=-1 gbPrepEnd=TRUE bTlClmp=TRUE iHomeStatus=((iHomeStatus B_AND 'B11') B_OR 'B11000')
      ;
      ;-890.3--Kette Festplatz Wz--
      ; - Warten bis Bereitstellung
      ;   NeuWz beendet
      ; - Loeszeit Kette vorgeben
      ;----------------------------
      LOOP
        iMagPos=OUTA_ActPosV1 SYG_RM[iSYG]=0 SYG_RM[iSYG+7]=grHGUnClmpTimeC bEnabled=FALSE iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=890.3
        IF (iMagPos>0)
          ;
          ;NeuWz an Uebergabe und Mag in Position
          bEnabled=($TC_MPP6[icMagNo,iMagPos]==iNewTNo)AND(mcbDBB_ChInPos)
        ENDIF
        ;
        IF (bEnabled)AND(NOT gbPrepEnd)AND(gbPrepDone)AND(gbPrepActiv)
          ;
          ;Bereitstellung NeuWz ist zu Ende
          ;
          IF (bRelPrePosDGRot)AND(bNewTlFast)
            ;
            bInitPrePosDGRot=TRUE rFeed=MINVAL(rFeedEmptyDGRot,rFeedDGRot)*rcRedVeloDG rPrePosTimeDGRot=grHomePosWindow*60/(rFeed*rSafeCalcDG)
            ;
            ;-890.4--Kette Festplatz Wz-
            ; Loeszeit HG aktualisieren
            ;---------------------------
            ID=SyncID_TC+7 DO SYG_RM[iSYG+7]=MAXVAL((SYG_RM[iSYG+7]-rIPO),0)
            ;
            ;Loeszeit < DGLaufzeit  -> DG mit verminderter Geschwindigkeit Starten
            ID=SyncID_TC+3 WHEN (SYG_RM[iSYG]==0)AND((SYG_RM[iSYG+7]<=rPrePosTimeDGRot)OR(($A_DBB[68] B_AND 'B10')<>0))AND(SYG_IM[iSYG+3]==1) DO FA[mcAxDGRot]=rFeed POS[mcAxDGRot]=ACP(rPrePosDGRot) mcDBB_StepTC=iHomeStatus
          ENDIF
          ;
          ;-890.5--Kette Festplatz Wz-
          ; Neues Wz Einwechseln
          ;---------------------------
          GOTOB DG_NEXT_MOVE
        ENDIF
        ;
        G4 F=rWaitShort
        IF (iErrCount>=iWaitCha2)
          iAlarmNo=AL_WaitFor sAlarmParam="gbPrep../iMagPos"
          GOTOF HandleAlarm
        ENDIF
      ENDLOOP
      ;
    ENDIF
  ENDIF
  ;
  bFxPlUnload=FALSE bFxPlLoad=FALSE
ENDIF

;-[]-900.0--NeuWz ist HandWz-
;---------------------------
;
;============
GET_MAN_TOOL:
;============
;
IF (iNewTNo>0)AND(bNewIsManTl)AND(iToDo==mcTaskPrep)
  ;
  MsgBox(T_LoadTl<<": T = "<<$TC_TP2[iNewTNo]<<" - "<<T_Started,"CLEAR")
  ;
  ;Hand-Wz durch regulaeren WzW in Spindel / Hand-Wz asynchron in Spindel
  ;
  ;Zunaechst DG in GndSt
  ;
  ;-[WM286,WM307]-900.1--NeuWz ist HandWz-
  ;--------------------------------------
  IF (bDGIsNcAxis)
    iErrCount=0
    WHILE (NOT OUT_DGRotInBasePos)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=900.1
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
        GOTOF HandleAlarm
      ENDIF
      STOPRE
    ENDWHILE
  ENDIF
  ;
  ;-[MTC]-900.2--NeuWz ist HandWz-
  ; DG in GndSt
  ;------------------------------
  IF (bDGIsMTC)
    iErrCount=0
    WHILE (($A_DBB[4] B_AND 1)==0)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=900.2
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam="CT"
        GOTOF HandleAlarm
      ENDIF
      STOPRE
    ENDWHILE
  ENDIF
  ;
  ;-[]-900.3--NeuWz ist HandWz---
  ; Warten auf Genauhalt Z Achse
  ;-----------------------------
  IF (bZAxReq)
    iErrCount=0
    WHILE ($AA_STAT[mcAxZ]<4)
      G4 F=rWaitLong
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=900.3
      IF (iErrCount>=iErrTimeLong)
        iAlarmNo=AL_WaitFor sAlarmParam="Z"
        GOTOF HandleAlarm
      ENDIF
    ENDWHILE
    ;
    ;-900.4--NeuWz ist HandWz-
    ; Programmierte Position Z
    ;-------------------------
    G153 G90 G40 FA[mcAxZ]=rFeedZ POSA[mcAxZ]=rProgZPos
  ENDIF
  ;
  ;-900.5--NeuWz ist HandWz-
  ; Warten auf Genauhalt B
  ;-------------------------
  IF (bBAxReq)
    iErrCount=0
    WHILE ($AA_STAT[mcAxB]<4)
      G4 F=rWaitLong
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=900.5
      IF (iErrCount>=iErrTimeLong)
        iAlarmNo=AL_WaitFor sAlarmParam="B"
        GOTOF HandleAlarm
      ENDIF
    ENDWHILE
    ;
    ;-900.6--NeuWz ist HandWz-
    ; Programmierte Position B
    ;-------------------------
    EXECSTRING("ID=SyncID_TC+2 WHEN ($VA_IM[mcAxZ]>=(rProgZPos-rc0x5mm)) DO FA[mcAxB]=rFeedB POS[mcAxB]="<<sModeB<<"(rProgBPos)")
  ENDIF
  ;
  ;-900.7--NeuWz ist HandWz------
  ; Spindel zur Beladestelle_Hand
  ;------------------------------
  ;
  IF (($AA_IM[mcAxX]-grTCPrePosX)>rc1x0mm)
    ;
    ;X befindet sich im Magazinraum
    ;
    IF (NOT mcbDBB_TCDoorOpen)
      M_TCDoorOpen1
    ENDIF
    ;
    ;X in Vorposition Fahren
    G153 G0 G60 G90 G40 G602 POS[mcAxX]=grTCPrePosX-rc0x5mm
  ENDIF
  ;
  IF (bLubRequested)
    ;
    ;-900.8--NeuWz ist HandWz-
    ; Schmieren
    ;-------------------------
    MSG(MSG_LubCycleActive)
    ;
    ;Schmierung anstossen und warten bis abgeschlossen
    ;
    IF ((giMachType B_AND 'H1')<>0)AND(gbIsGearSpindle)
      ;
      ;Y fuer NBH500 GS
      Y=grTcPosY
    ENDIF
    ;
    M57
    ;
    MSG(T_LoadTl<<": T = "<<$TC_TP2[iNewTNo]<<" - "<<T_Started)
  ENDIF
  ;
  STOPRE
  ;
  ;-900.9--NeuWz ist HandWz--------
  ; Warteschleife in ToPrep nach
  ; Verlassen des HG/DG auf Ende setzen
  ;--------------------------------
  gbPrepEnd=TRUE
  ;
  ;-900.10--NeuWz ist HandWz---
  ; X in Beladestelle_Hand
  ; X in Position -> WzW-Tuere
  ; wieder schliessen
  ;---------------------------
  ;
  M=$MCS_M_CODE_ALL_COOLANTS_OFF
  ;
  WHEN (rCloseDoorX-$AA_IM[mcAxX]>rc0x5mm) DO M_TcDoorClose0
  G153 G0 G601 G90 G40 G60 X=grToLoadPosX Y=grToLoadPosY SPOS=ACP(rTcSPosRes)
  ;
  ;-900.11--NeuWz ist HandWz-
  ; Lageregelung aus
  ;--------------------------
  STOPRE
  SPCOF
  ;
  ;-900.12--NeuWz ist HandWz-
  ; Teststop
  ;--------------------------
  IF (IN_TeststopReq<>0)
    Teststop(1)
    STOPRE
  ENDIF
  ;
  ;-900.13--NeuWz ist HandWz---
  ; Auforderung Spindel Beladen
  ;----------------------------
  ;
  SpTlData(1)
  ;
  ;vor M_OpenDoorPutToolIntoSp
  OUT_LoadUnloadActive=TRUE OUT_TCActive=FALSE
  ;
  ;Damit PLC M286 richtig ausfuehrt
  G04 F0.5
  ;
  sAux="giNextTlInSp=iNewTNo giSyncTC="
  IF (iTaskId==2)
    sAux=sAux<<"11"
  ELSE
    sAux=sAux<<"12"
  ENDIF
  IF (bMagIsPickUpDisk)
    sAux=sAux<<" grSyncPickupDrop=0"
  ENDIF
  EXECSTRING(sAux)
  ;
  IF (gbPLCSimActive)
    ;
    ;Damit die PLC Simulation den passenden Spannstatus erzeugt
    CANCEL(SyncID_TCLoad)
    ID=SyncID_TCLoad EVERY (($A_DBB[0] B_AND 'B111')==0) DO OUT_ToolInSp=NOT OUT_ToolInSp
  ENDIF
  ;
  MsgBox(T_LoadTl<<": T = "<<$TC_TP2[iNewTNo]<<" - "<<T_PutTlIntoSp,"ID=1 M286","(($A_DBB[0] B_AND 7)==1)")
  ;
  CANCEL(SyncID_TCLoad)
  ;
  ;-900.14--NeuWz ist HandWz---
  ; - WzHaushalt richtigstellen
  ; - Beladen quittieren
  ;----------------------------
  IF (bPutM206)
    M206
    bPutM206=FALSE
  ENDIF
  ;
  IF (iTaskId==2)
    ;klassischer WzW
    iTmp1=-1 iTmp2=-1
  ELSE
    STOPRE
    iTmp1=9998 iTmp2=mcLocSP
    $TC_MPP6[9998,mcLocSP]=iNewTNo
  ENDIF
  ;
  ;WzW + Ende-Quittierung NeuWz Beladestelle_Hand->Sp
  ToAckn(TRUE,iTaskId,iTaskIdNo,iNewTNo,0,9998,mcLocSP,iTmp1,iTmp2,1)
  ;
  ;HandWz kann kein FestplatzWz sein
  $TC_TP8[iNewTNo]=($TC_TP8[iNewTNo] B_AND (B_NOT 'H40')) giSyncTC=0 giNextTlInSp=-1
  ;
  ;-900.16--NeuWz ist HandWz-
  ; Spindeldaten Aktualisieren
  ;---------------------------
  SpTlData(1,iNewTNo)
  ;
  ;bewusst hier hinter SpTlData wegen OUT_ToolInSp=..
  OUT_LoadUnloadActive=FALSE
  ;
ENDIF

;=========
FINISH_TC:
;=========

;-[]-920.0--Wz Entladen-
; Ueber Spindel
;-----------------------
;
IF (iToDo==mcTaskUnload)
  ;
  ;-[WM286,WM307]-920.1--Wz Entladen-
  ; Warten bis DG im Genauhalt
  ;----------------------------------
  IF (bDGIsNcAxis)
    iErrCount=0
    WHILE (NOT OUT_DGRotInBasePos)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=920.1
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
        GOTOF HandleAlarm
      ENDIF
    ENDWHILE
  ENDIF
  ;
  ;-[MTC]-920.2--Wz Entladen-
  ; Warten bis DG in GndSt
  ;--------------------------
  IF (bDGIsMTC)
    iErrCount=0
    WHILE (($A_DBB[4] B_AND 'B1')==0)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=920.2
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam="CT"
        GOTOF HandleAlarm
      ENDIF
    ENDWHILE
  ENDIF
  ;
  ;-[]-920.3--Wz Entladen---
  ; Warten bis SpWz gespannt
  ;-------------------------
  iErrCount=0
  WHILE (($A_DBB[0] B_AND 'B11')==0)
    G4 F=rWaitShort
    iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=920.3
    IF (iErrCount>=iErrTimeShort)
      FileRead("CLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
      iAlarmNo=AL_WaitFor sAlarmParam="CS "<<sAux
      GOTOF HandleAlarm
    ENDIF
  ENDWHILE
  ;
  IF (bTlReplace) GOTOF NOT_IN_LOADPOS
  ;
  ;-920.4--Wz Entladen-
  ; SpWz aktualisieren
  ;--------------------
  SpTlData(1,iNewTNo)
  ;
  ;-920.5--Wz Entladen-
  ; Z-Achse wegfahren
  ;--------------------
  IF ($AA_IM[mcAxZ]<grTcPosZMin)
    ;
    ;vor dem WzW erst mit Z-Achse wegfahren (sonst Kollision Y-Achse mit Palettenauflage)
    G0 G40 G60 G17 G153 G90 G94 Z=grTcPosZMin
    rActZPos=grTcPosZMin
  ENDIF
  ;
  IF (bMagIsPickUpDisk)
    ;
    ;Scheibe Hinten
    IF (bRelAuxSw)
      iAuxAdr=68 iAuxMask='B1100' iAuxResult='B100'
    ELSE
      iAuxAdr=1 iAuxMask='B11' iAuxResult='B1'
    ENDIF
  ELSE
    iAuxAdr=1 iAuxMask=0 iAuxResult=0
  ENDIF
  ;
  IF (($AA_IM[mcAxX]-grTCPrePosX)>rc1x0mm)
    ;
    ;-920.6--Wz Entladen-
    ; WzWTuer Oeffnen
    ;--------------------
    IF (NOT mcbDBB_TCDoorOpen)
      M_TcDoorOpen1
    ENDIF
    ;
    ;-920.7--Wz Entladen---------------
    ; Scheibe nicht Hinten -> X Sperren
    ;----------------------------------
    WHENEVER (($A_DBB[iAuxAdr] B_AND iAuxMask)<>iAuxResult) DO $AC_OVR=0 $AA_OVR[mcAxX]=0
    ;
    ;-920.8--Wz Entladen----
    ; X-Achse in Vorposition
    ;-----------------------
    G153 G0 G90 G40 G602 POS[mcAxX]=grTCPrePosX
  ENDIF
  ;
  ;-920.9--Wz Entladen--------------
  ; X,Y-Achse in Beladeposition Hand
  ;---------------------------------
  ;
  ;WzW-Tuere schliessen/Freigabe Sp
  WHEN ((rCloseDoorX+rc0x1mm)>$VA_IM[mcAxX]) DO M_TcDoorClose0 M5 OUT_TcActive=FALSE M=QU(MQ_ResetTCCount) mcDBB_StepTC=0 SYG_IM[iSYG]=icClmpStep+1
  WHEN ((grTCPrePosX+rc0x1mm)>$VA_IM[mcAxX]) DO SPOS=ACP(rTcSPosRes)
  ;
  IF ($AA_IM[mcAxZ]<grTcPosZ)
    G153 G0 G90 G40 G60 G603 X=grToLoadPosX Y=grToLoadPosY Z=grTcPosZ
    rActZPos=grTcPosZ
  ELSE
    G153 G0 G90 G40 G60 G603 X=grToLoadPosX Y=grToLoadPosY
  ENDIF
  rActXPos=grToLoadPosX rActYPos=grToLoadPosY
  ;
  ;-920.11--Wz Entladen---------
  ; Warten bis Spindel gerichtet
  ;-----------------------------
  iErrCount=0
  WHILE (NOT mcbSpInTCPosFine)
    G4 F=rWaitShort
    iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=920.11
    IF (iErrCount>=iErrTimeShort)
      iAlarmNo=AL_WaitFor sAlarmParam="CS"
      GOTOF HandleAlarm
    ENDIF
  ENDWHILE
  ;
  ;-920.12--Wz Entladen-------
  ; Spindeldaten Aktualisieren
  ;---------------------------
  GOTOF ACTIVATE_TOOL
  ;
  ;==============
  NOT_IN_LOADPOS:
  ;==============
  ;
ENDIF

;-[DISK]-930.0--BBK_4-
;---------------------
IF (bMagIsPickUpDisk)
  ;
  IF (bNewTlNotMeasured)AND(NOT bPosAfterTC)AND(NOT bNoRealTC)AND(iToDo==mcTaskPrep)
    ;
    ;-930.1--BBK_4----
    ; In Pruefposition
    ;-----------------
    iErrCount=0
    REPEAT
      bTmp1=(($A_DBB[0] B_AND 'B11')=='B1') bTmp2=(($A_DBB[1] B_AND 'B11')=='B1') bTmp3=(ABS(grTcPosX-$VA_IM[mcAxX])<=rTCInPosFine) bEnabled=(bTmp1)AND(bTmp2)AND(bTmp3) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=930.1
      IF (NOT bEnabled)
        G4 F=rWaitShort
        IF (iErrCount>=iErrTimeShort)
          sAlarmParam="" sTmp=""
          IF (NOT bTmp1)
            FileRead("CLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
            sAlarmParam="CS "<<sAux sTmp=", "
          ENDIF
          IF (NOT bTmp2)
            sAlarmParam=sAlarmParam<<sTmp<<AXSTRING(mcAxV1)<<"/Z" sTmp=", "
          ENDIF
          IF (NOT bTmp3)
            sAlarmParam=sAlarmParam<<sTmp<<"X"
          ENDIF
          iAlarmNo=AL_WaitFor
          GOTOF HandleAlarm
        ENDIF
      ENDIF
    UNTIL (bEnabled)
    ;
    ;-930.2--BBK_4-
    ; Wz Messen
    ;--------------
    ToChkMSC(-1,iNewTNo,0,FALSE,bNegResultBBK,iAlarmNoBBK,sAlarmParamBBK)
    rAlarmAreaBBK=930.2
    ;
    IF (bNegResultBBK)
      ;
      ;-930.3--BBK_4-----------
      ; - NeuWz Sperren
      ; - Spaetere Alarmausgabe
      ;------------------------
      $TC_TP8[iNewTNo]=($TC_TP8[iNewTNo] B_OR 'B100') bNegResultBBK=FALSE
    ENDIF
  ENDIF
ENDIF
;
IF (iAlarmNoBBK>=67000)AND((iProgConfig B_AND 'B10')<>0)AND(NOT gbErrMsgOnToCheck)
  ;
  ;-930.3--BBK_4-------
  ; keine Fehlerausgabe
  ;--------------------
  iAlarmNoBBK=0
ENDIF
;
;-[]-940.0--Abfragemasken-
; Sp Gespannt mit/ohne Wz
;--------------------------
;
IF (bRelSpSw)
  iSpMask='B11011'
ELSE
  iSpMask='B11'
ENDIF
;
IF (iNewTNo>0)
  ;
  ;Gespannt mit Wz
  iSpMask=(iSpMask B_AND 'B1001')
ENDIF
;
;-[DISK]-940.1--Abfragemasken-
; Scheibenhub
;------------------------------
IF (bMagIsPickUpDisk)
  ;
  ;zusaetzlich
  ;
  IF (iNewTNo>0)
    ;
    ;SpWz -> Scheibe Hinten
    ;
    IF (bRelAuxSw)
      iAuxAdr=68 iAuxMask='B1100' iAuxResult='B100'
    ELSE
      iAuxAdr=1 iAuxMask='B11' iAuxResult='B1'
    ENDIF
    ;
  ELSE
    ;
    ;kein SpWz -> Scheibe Vorn
    ;
    IF (bRelAuxSw)
      iAuxAdr=68 iAuxMask='B1100' iAuxResult='B1000'
    ELSE
      iAuxAdr=1 iAuxMask='B11' iAuxResult='B10'
    ENDIF
  ENDIF
ENDIF
;
;-[MTC]-940.2--Abfragemasken-
; DG in GndSt
;----------------------------
IF (bDGIsMTC)
  ;
  ;zusaetzlich DG in GndSt
  iAuxAdr=4 iAuxMask='B1' iAuxResult='B1'
ENDIF

;-[]-960.0--Sp aus Magazin---------
; Kein vorzeitiges Verlassen des TC
; -> X in Vorposition bringen
;----------------------------------
;
IF (NOT bPosAfterTC)AND(NOT bNoRealTC)
  ;
  IF ($VA_IM[mcAxX]>grTCPrePosX)
    ;
    CANCEL(SyncID_TC+0)
    ;
    ;-[WM286,WM307]-960.1--Sp aus Magazin-
    ;-------------------------------------
    IF (bDGIsNcAxis)
      ;
      ;DG in GndSt und Sp Gespannt oder Fahren bei geloester Sp, "schnelles Wz" -> Fahren in TCPREPOS
      ID=SyncID_TC+0 WHEN (((bRelMoveUnClmp)AND(bNewTlFast))OR(($A_DBB[0] B_AND iSpMask)<>0))AND(OUT_DGRotInHomeArea) DO ACC[mcAxX]=rNewTlACC FA[mcAxX]=rFeedX POS[mcAxX]=grTCPrePosX
      ;
    ENDIF
    ;
    ;-[MTC,DISK]-960.2--Sp aus Magazin-
    ;----------------------------------
    IF (bDGIsMTC)OR(bMagIsPickUpDisk)
      ;
      ;Sp Gespannt oder Fahren bei geloester Sp und "schnelles Wz" und Scheibe Hinten/Vorne oder DG in GndSt -> Fahren in TCPREPOS
      ID=SyncID_TC+0 WHEN (((bRelMoveUnClmp)AND(bNewTlFast))OR(($A_DBB[0] B_AND iSpMask)<>0))AND(($A_DBB[iAuxAdr] B_AND iAuxMask)==iAuxResult) DO ACC[mcAxX]=rNewTlACC FA[mcAxX]=rFeedX POS[mcAxX]=grTCPrePosX
    ENDIF
    ;-[]-
  ENDIF
ENDIF

;-[]-970.0--X Sichern-
;---------------------
;
;-[WM286,WM307]-971.0--X Sichern-
;--------------------------------
IF (bDGIsNCAxis)
  ;
  ;X im Magazin und DG nicht im Freigabebereich -> X Sperren
  ;
  IF (NOT bNewTlFast)OR(NOT bRelMoveUnClmp)OR(bDGIsWM286)
    ;
    ;-971.1--X Sichern---------
    ; - keine Sonderspannzange
    ;   und SpWz nicht gespannt
    ;   oder
    ; - kein "schnelles Wz"
    ;   oder
    ; - DG ist WM286
    ; -> X Sperren
    ;--------------------------
    ID=SyncID_TC+9 WHENEVER (($A_DBB[0] B_AND iSpMask)==0)OR((NOT OUT_DGRotInHomeArea)AND($VA_IM[mcAxX]>grTCPrePosX)) DO $AC_OVR=0 $AA_OVR[mcAxX]=0
  ELSE
    ;
    ;-971.2--X Sichern-
    ;------------------
    ID=SyncID_TC+9 WHENEVER (NOT OUT_DGRotInHomeArea)AND($VA_IM[mcAxX]>grTCPrePosX) DO $AC_OVR=0 $AA_OVR[mcAxX]=0
  ENDIF
ENDIF
;
;-[MTC,DISK]-972.0--X Sichern-
;-----------------------------
IF (bDGIsMTC)OR(bMagIsPickUpDisk)
  ;
  ;X im Magazin und ScheibenHub nicht Vorn/Hinten oder DG nicht in GndSt -> X Sperren
  ;
  IF (NOT bNewTlFast)OR(NOT bRelMoveUnClmp)
    ;
    ;-972.1--X Sichern--------
    ; - SpWz nicht gespannt
    ; - keine Sonderspannzange
    ;   oder
    ; - kein "schnelles Wz"
    ; -> X Sperren
    ;-------------------------
    ID=SyncID_TC+9 WHENEVER (($A_DBB[0] B_AND iSpMask)==0)OR((($A_DBB[iAuxAdr] B_AND iAuxMask)==0)AND($VA_IM[mcAxX]>grTCPrePosX)) DO $AC_OVR=0 $AA_OVR[mcAxX]=0
  ELSE
    ;
    ;-972.2--X Sichern-
    ;------------------
    ID=SyncID_TC+9 WHENEVER (($A_DBB[iAuxAdr] B_AND iAuxMask)==0)AND($VA_IM[mcAxX]>grTCPrePosX) DO $AC_OVR=0 $AA_OVR[mcAxX]=0
  ENDIF
ENDIF
;
;-[]-980.0--TC Beenden-
; WzW Tuer Schliessen
;----------------------
;
IF (bNoRealTC)
  ;
  ;-981.0--TC Beenden-----------
  ; Es war kein WzW erforderlich
  ;-----------------------------
  IF (($AA_IM[mcAxX]-rCloseDoorX)<rc0x5mm)AND(OUT_DGRotInBasePos)
    ;
    M=QU(MQ_TCDoorClose)
  ENDIF
  ;
  OUT_TcActive=FALSE
  ;
ELSE
  ;
  CANCEL(SyncID_TC+6,SyncID_TC+7,SyncID_TC+8)
  ;
  ;-[WM286,WM307]-982.0--TC Beenden-
  ;---------------------------------
  IF (bDGIsNcAxis)
    ;
    ;X vor WzW Tuer und DG in GndSt -> WzW Tuer Schliessen
    ;
    ID=SyncID_TC+6 WHEN (($VA_IM[mcAxX]-rCloseDoorX)<rc0x5mm)AND(OUT_DGRotInBasePos) DO M=QU(MQ_TCDoorClose) SYG_BM[iSYG+3]=FALSE SYG_BM[iSYG+4]=FALSE
    ;
    IF (bPosAfterTC)
      ;
      ;X ausserhalb Magazin und DG in GndSt-> Ende WzW
      ;
      IF (bRelMoveUnClmp)
        ;
        ;-982.1--TC Beenden----
        ; - Sp gespannt
        ;   oder
        ; - Spannzeit abgelaufen
        ;-----------------------
        ID=SyncID_TC+7 WHEN (($VA_IM[mcAxX]-grTCPrePosX)<rc0x1mm)AND(OUT_DGRotInBasePos)AND((($A_DBB[0] B_AND 'B11')<>0)OR(SYG_RM[iSYG+2]==0)) DO M=QU(MQ_ResetTCCount) mcDBB_StepTC=0 OUT_TcActive=FALSE SYG_IM[iSYG]=icLastStep
      ELSE
        ;
        ;-982.2--TC Beenden-
        ;-------------------
        ID=SyncID_TC+7 WHEN (($VA_IM[mcAxX]-grTCPrePosX)<rc0x1mm)AND(OUT_DGRotInBasePos) DO M=QU(MQ_ResetTCCount) mcDBB_StepTC=0 OUT_TcActive=FALSE SYG_IM[iSYG]=icLastStep
      ENDIF
    ENDIF
  ENDIF
  ;
  ;-[MTC,DISK]-983.0--TC Beenden-
  ;------------------------------
  IF (bDGIsMTC)OR(bMagIsPickUpDisk)
    ;
    ;X vor WzW Tuer -> WzW Tuer Schliessen
    ;
    ID=SyncID_TC+6 WHEN (($VA_IM[mcAxX]-rCloseDoorX)<=rc0x5mm) DO M=QU(MQ_TCDoorClose) SYG_BM[iSYG+3]=FALSE SYG_BM[iSYG+4]=FALSE
    ;
    IF (bPosAfterTC)
      ;
      ;X ausserhalb Magazin -> Ende WzW
      ;
      IF (bRelMoveUnClmp)
        ;
        ;-983.1--TC Beenden-----
        ; zusaetzlich
        ; - Sp gespannt
        ;   oder
        ; - Spannzeit abgelaufen
        ;-----------------------
        ID=SyncID_TC+7 WHEN (($VA_IM[mcAxX]-grTCPrePosX)<=rc0x1mm)AND((($A_DBB[0] B_AND 'B11')<>0)OR(SYG_RM[iSYG+2]==0)) DO M=QU(MQ_ResetTCCount) mcDBB_StepTC=0 OUT_TcActive=FALSE SYG_IM[iSYG]=icLastStep
      ELSE
        ;
        ;-983.2--TC Beenden-
        ;-------------------
        ID=SyncID_TC+7 WHEN (($VA_IM[mcAxX]-grTCPrePosX)<=rc0x1mm) DO M=QU(MQ_ResetTCCount) mcDBB_StepTC=0 OUT_TcActive=FALSE SYG_IM[iSYG]=icLastStep
      ENDIF
    ENDIF
  ENDIF
  ;
  ;-[]-984.0--TC Beenden-
  ;----------------------
  IF (gbSpIsUnClmpFixed)
    ;
    ;SpWz war geloest und dabei mechanisch geklemmtwird jetzt gespannt ->
    ;Lagehaltung aktivieren, damit Sp beim Rausfahren aus der Klammer in Position gehalten wird
    ;
    ID=SyncID_TC+8 WHEN ($AA_AX_DISABLE[mcAxSp1]==0)AND(SYG_IM[iSYG]==icClmpStep)AND(($A_DBB[0] B_AND 'B100')==0) DO M70
  ENDIF
ENDIF
;
;-[MW286,WM307]-985.0--TC Beenden-
; Warten auf DG in Freigabefenster
;---------------------------------
IF (bDGIsNcAxis)AND(NOT bPosAfterTC)
  ;
  iErrCount=0
  REPEAT
    bEnabled=(OUT_DGRotInHomeArea) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=985.0
    IF (NOT bEnabled)
      G4 F=rWaitShort
      IF (iErrCount>=iErrTimeShort)
        iAlarmNo=AL_WaitFor sAlarmParam=AXSTRING(mcAxDGRot)
        GOTOF HandleAlarm
      ENDIF
    ENDIF
  UNTIL (bEnabled)
ENDIF

;-[]-1000.0--SpWzDaten-
;----------------------
;
;=============
ACTIVATE_TOOL:
;=============
;
IF (gbSpecTlInSp)
  ;
  IF (iNewTlSpecType==mcSpecTypeBENZMillHead)OR(iNewTlSpecType==mcSpecTypeMillHead)
    ;
    ;Fraeskopf ist/wird SpWz
    ;
    iErrCount=0
    REPEAT
      bEnabled=(mcbDBB_SpClamped) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=1000.0
      ;
      ;Warten bis Sp Geklemmt ist, damit im SpTlData auch der Fraeskopf geklemmt wird
      ;
      IF (NOT bEnabled)
        IF (iErrCount>iErrTimeShort)
          FileRead("CLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
          iAlarmNo=AL_WaitFor sAlarmParam="CS "<<sAux
          GOTOF HandleAlarm
        ENDIF
        G04 F=rWaitShort
      ENDIF
    UNTIL (bEnabled)
  ENDIF
ENDIF
;
SpTlData(1,iNewTNo)

IF (iOldTNo>0)
  ;
  IF (bReqLockSpTool)OR(bNegResultBBK)
    ;
    ;-1010.0--WzKennungen----------
    ; Wz Sperren von Extern oder
    ; wenn Wz gebrochen oder falsch
    ;------------------------------
    $TC_TP8[iOldTNo]=ITOR(RTOI($TC_TP8[iOldTNo]) B_OR 'B100') OUT_ReqLockSpTool=FALSE
  ENDIF
  ;
  IF ($TC_TP3[iOldTNo]>1)OR($TC_TP4[iOldTNo]>1)OR($TC_TP5[iOldTNo]>1)OR($TC_TP6[iOldTNo]>1)OR($TC_TP7[iOldTNo]>1)OR(NOT bMagIsWM307)
    ;
    ;-1010.1--WzKennungen-----
    ; - Groesse    > Standard
    ; - WzPlatzTyp > Standard
    ; - nicht direkt in Kette
    ; -> Wz <festplatzcodiert>
    ;-------------------------
    $TC_TP8[iOldTNo]=ITOR(RTOI($TC_TP8[iOldTNo]) B_OR 'H40')
  ENDIF
  ;
  IF (bNegResultBBK)
    ;
    ;-1020.0--BBK_5---------------
    ; Gebrochenes oder falsches Wz
    ;-----------------------------
    ;
    gbLastToBroken=TRUE
    ;
    IF ((iProgConfig B_AND 'B10')==0)OR(gbErrMsgOnToCheck)
      ;
      IF (bPosAfterTC)AND(NOT bWaitZB)
        ;
        ;-1020.1--BBK_5-----
        ; Auswertung in TCWP
        ;-------------------
        giToNoProb=iOldTNo
      ELSE
        ;
        ;-1020.2--BBK_5--------
        ; Spaetere Alarmausgabe
        ;----------------------
        gbToCheckAtTC=FALSE
      ENDIF
    ELSE
      ;
      ;-1020.3--BBK_5-----
      ; keine Alarmausgabe
      ;-------------------
      gbToCheckAtTC=FALSE bNegResultBBK=FALSE
    ENDIF
  ENDIF
ENDIF

;-[]-1030.0--DG Status-
;----------------------
IF (gbWithDG)
  ;
  giTNoDG1=$TC_MPP6[9998,mcLocDG1] giTNoDG2=$TC_MPP6[9998,mcLocDG2]
  ;
  IF ((giTNoDG1<>0)OR(giTNoDG2<>0))AND(NOT bMagIsMiksch)
    ;DG1 und DG2 muessen leer sein (nicht Miksch)
    iAlarmNo=AL_DGNotEmpty sAlarmParam="" SYG_RM[iSYGArea]=1030.0
    GOTOF HandleAlarm
  ENDIF
ENDIF
;
;-[]-1040.0--Kanal 2----
;Aufhebung Warteschleife
;-----------------------
IF (gbTMIsHHD)
  giStateToMMC[0]=(giStateToMMC[0] B_AND (B_NOT mcState1TCActive)) gbTcActive=FALSE gbPrepEnd=TRUE
ELSE
  gbTcActive=FALSE gbPrepEnd=TRUE
ENDIF

;-1200.0--Workstep-
;------------------
IF (iWorkStep<>-1)
  ;
  IF (BufNo>0)AND(BufNo<18)AND(bProgCall)
    ;
    iTmp2=BufNo
  ELSE
    ;
    IF (NOT bAPCInPos)
      M91
    ENDIF
    bAPCInPos=(IN_APCInPos) iTmp1=(INA_APCPos)
    ;
    IF (NOT bAPCInPos)OR(iTmp1==0)
      iAlarmNo=AL_APCNotInBasePos sAlarmParam="" SYG_RM[iSYGArea]=1200.0
      GOTOF HandleAlarm
    ELSE
      iTmp2=giPal_BufNo[iTmp1]
    ENDIF
  ENDIF
  ;
  CFG_MAN("MPS_HOST",sTmp)
  IF (sTmp<>"")
    ;
    ;mit Leitrechner
    giMPSWorkStep[giMPSActivProg]=iWorkStep Working_Step=iWorkStep
  ELSE
    giMMC_Pal[2,iTmp2]=iWorkStep Working_Step=iWorkStep
  ENDIF
ENDIF

;-[]-1500.0--Ende_WzWKurz-
;-------------------------
IF (bPosAfterTC)
  ;
  ;X bleibt noch im Magazin
  ;
  IF (bWaitZB)
    ;
    ;"WP" -> d.h. verkuerzter WzW, kein Aufruf von TCWP
    ;
    IF (iOldTNo<>iNewTNo)
      ;
      ;-1500.1--Ende_WzWKurz-----
      ; Sonst Sp Anlauf bei M3/M4
      ; ohne Drehzahlangabe S
      ;--------------------------
      S0 M=QU(5)
    ENDIF
    ;
    ;-1500.2--Ende_WzWKurz-------
    ; Z,B nicht im Genauhalt ->
    ; WAITP(..) -> Neutralstatus
    ; der Achsen
    ;---------------------------
    bTmp1=($AA_STAT[mcAxZ]<4)AND(bMoveZ) bTmp2=($AA_STAT[mcAxB]<4)AND(bBAxis) sTmp="WAITP(" sTmp1=""
    IF (bTmp1)
      sTmp=sTmp<<"mcAxZ" sTmp1=","
    ENDIF
    IF (bTmp2)
      sTmp=sTmp<<sTmp1<<"mcAxB"
    ENDIF
    IF (sTmp<>"WAITP(")
      EXECSTRING(sTmp<<")")
    ENDIF
  ENDIF
  ;
  ;-1500.3--Ende_WzWKurz-
  ;----------------------
  CANCEL(SyncID_TC+0,SyncID_TC+1,SyncID_TC+2)
  ;
  RET
ENDIF

;-[]-1600.0--Ende_WzWStnd-
; - X im Genauhalt Grob
; - NC DG in Position
; - X in Position
;-------------------------
IF (iNewTNo>0)AND(iToDo==mcTaskPrep)
  ;
  IF (gbTMIsHHD)
    iTmp1=(RTOI($TC_TPC1[iNewTNo]) B_AND 'H3030') bM3=((iTmp1 B_AND 'H1000')<>0)AND(bRelSpDir) bM4=((iTmp1 B_AND 'H2000')<>0)AND(bRelSpDir) bCoolM1=((iTmp1 B_AND 'H10')<>0)AND(bRelCool) bCoolM2=((iTmp1 B_AND 'H20')<>0)AND(bRelCool)
  ELSE
    iTmp1=(RTOI($TC_DP25[iNewTNo,1]) B_AND 'HF00') bM3=((iTmp1 B_AND 'H100')<>0)AND(bRelSpDir) bM4=((iTmp1 B_AND 'H200')<>0)AND(bRelSpDir) bCoolM1=((iTmp1 B_AND 'H400')<>0)AND(bRelCool) bCoolM2=((iTmp1 B_AND 'H800')<>0)AND(bRelCool)
  ENDIF
ELSE
  bM3=FALSE bM4=FALSE bCoolM1=FALSE bCoolM2=FALSE iTmp2=0
ENDIF
;
;Keine Drehzahl, Kuehlmittel bei spaeterer Alarmausgabe
iErrCount=0 bError=((iAlarmNoBBK>0)OR(bNewTlNotMeasured)) bSwitchedSp=((bError)OR(bInPrSearch)OR(gbSpecTlInSp)OR(iToDo<>mcTaskPrep)) bSwitched=(((NOT bCoolM1)AND(NOT bCoolM2))OR(gbTCSlowMode)OR(bError)OR(bInPrSearch)) bSelected=TRUE
;
REPEAT
  ;
  rActXPos=$VA_IM[mcAxX] bTmp1=(($AA_STAT[mcAxZ]<4)AND(bMoveZ)) bTmp2=(($AA_STAT[mcAxB]<4)AND(bBAxis)) bTmp3=($AA_STAT[mcAxX]>=3) iClampStatus=($A_DBB[0]) bDgInBasePos=((OUT_DGRotInBasePos)OR(NOT bDGIsNCAxis)) bEnabled=((bNoRealTC)OR(rActXPos<=rPrePosX+rc0x2mm)) iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=1600.0
  ;
  IF (bTmp1)
    ;
    ;SynAct jetzt fertig -> neue Nutzung moeglich
    CANCEL(SyncID_TC+1)
    ;
    IF (NOT bSwitched)
      ;
      IF (bCoolM1)AND(bCoolM2)
        iTmp2=$MCS_M_CODE_COOLANT_1_AND_2_ON
      ELSE
        IF (bCoolM1)
          iTmp2=$MCS_M_CODE_COOLANT_1_ON
        ELSE
          IF (bCoolM2)
            iTmp2=$MCS_M_CODE_COOLANT_2_ON
          ENDIF
        ENDIF
      ENDIF
      ;
      ;Kuehlmittel einschalten
      ID=SyncID_TC+1 WHEN (($A_DBB[0] B_AND 'B11')<>0)AND((mcbDBB_TCDoorClosed)OR((SYG_IM[iSYG+3]==1)AND($AA_STAT[X]<3)AND($VA_IM[mcAxX]<rTcRelCoolX))) DO M=QU(iTmp2)
      ;
      bSwitched=TRUE
    ENDIF
  ENDIF
  ;
  IF (NOT bSwitchedSp)AND((iClampStatus B_AND 'B11')<>0)AND((bEnabled)OR(rActXPos<=rRelSpExitX))
    ;
    ;Sp Freigabe
    IF (bM3)
      S=rSpeed M=QU(3)
    ELSE
      IF (bM4)
        S=rSpeed M=QU(4)
      ELSE
        S0 M=QU(5)
      ENDIF
    ENDIF
    ;
    bSwitchedSp=TRUE SYG_IM[iSYG]=icLastStep
  ENDIF
  ;
  IF (bDGIsMTC)AND(bSelected)AND(bEnabled)
    ;
    ;TC Zaehler zuruecksetzen
    M=QU(MQ_ResetTCCount)
    ;
    bSelected=FALSE
  ENDIF
  ;
  bEnabled=(bEnabled)AND((iClampStatus B_AND 'B11')<>0)AND(bTmp3)AND(bDGInBasePos) bActMsg=FALSE
  IF (NOT bEnabled)
    G4 F=rWaitShort
    IF (iErrCount>=iErrTimeShort)
      ;
      M5 M=QU($MCS_M_CODE_ALL_COOLANTS_OFF)
      ;
      sAlarmParam="" sTmp=""
      IF (NOT bTmp3)
        sAlarmParam="X" sTmp=", "
      ENDIF
      ;
      IF ((iClampStatus B_AND 'B11')==0)
        FileRead("CLAMP_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
        sAlarmParam=sAlarmParam<<sTmp<<"CS "<<sAux sTmp=", "
      ENDIF
      ;
      IF (NOT bDGInBasePos)
        ;
        IF (bDGIsNCAxis)
          sAlarmParam=sAlarmParam<<sTmp<<AXSTRING(mcAxDGRot)
        ELSE
          FileRead("DG_"<<$AN_LANGUAGE_ON_HMI,mcSysText,sAux,,,";")
          sAlarmParam=sAlarmParam<<sTmp<<sAux
        ENDIF
      ENDIF
      ;
      iErrCount=0
      ;
      IF (NOT bActMsg)
        ;
        bActMsg=TRUE
        ;
        MSG("$89713"<<"("<<sAlarmParam<<")")
        ;
      ENDIF
    ENDIF
  ENDIF
UNTIL (bEnabled)
;
IF (bActMsg)
  MSG("")
ENDIF
;
IF (iNewTNo>0)AND((iClampStatus B_AND 'B10')<>0)
  ;
  ;-1600.3--Ende_WzWStnd------------
  ; lt. WzV Wz in Spindel, aber
  ; <Spindel gespannt ohne Werkzeug>
  ;---------------------------------
  iAlarmNo=AL_TInSpButSpClampedNoTool sAlarmParam="" SYG_RM[iSYGArea]=1600.3
  GOTOF HandleAlarm
ENDIF

;-[]-1610.0--Ende_WzWStnd----
; X,Z,B nicht im Genauhalt ->
; WAITP(..) -> Neutralstatus
; der Achsen
;----------------------------
sTmp="WAITP(mcAxX"
IF (bTmp1)
  sTmp=sTmp<<",mcAxZ"
ENDIF
IF (bTmp2)
  sTmp=sTmp<<",mcAxB"
ENDIF
EXECSTRING(sTmp<<")")
;
;-1610.1--Ende_WzW_Stnd-
; Korrektur Vorwaehlen
;-----------------------
IF (iNewTNo>0)AND(iDNo>-1)
  ;
  D=iDNo
ENDIF

;-[]-1620.0--Ende_WzWStnd-
;-------------------------
;
;========
PROG_END:
;========
;
;TC endgueltig abschliessen, ohne SyncID_TC+1 und ...
IF (bRetractDisk)
  ;... SyncID_TC+5
  CANCEL(SyncID_TC+0,SyncID_TC+2,SyncID_TC+3,SyncID_TC+4,SyncID_TC+6)
ELSE
  CANCEL(SyncID_TC+0,SyncID_TC+2,SyncID_TC+3,SyncID_TC+4,SyncID_TC+5,SyncID_TC+6)
ENDIF
CANCEL(SyncID_TC+7,SyncID_TC+8,SyncID_TC+9,SyncID_TC+10,SyncID_TC+11,SyncID_TC+12)
;
SYG_IM[iSYG]=icLastStep mcDBB_StepTC=0 OUT_TcActive=FALSE giSyncTc=0 bTeststopReq=(IN_TeststopReq)

;-1621.0--SonderWz_4-
;--------------------
IF (gbSpecTlInSp)
  ;
  ;Einstechkopf Kalibrieren / Plandrehkopf Referenzieren
  SpecTlMan(4,rProgZPos)
  ;
  IF (giResult<>0)
    iAlarmNo=giResult sAlarmParam=gsResult SYG_RM[iSYGArea]=1621.0
    GOTOF HandleAlarm
  ENDIF
  ;
  ;Sp Freigabe
  IF (bM3)
    S=rSpeed M=QU(3)
  ELSE
    IF (bM4)
      S=rSpeed M=QU(4)
    ELSE
      S0 M=QU(5)
    ENDIF
  ENDIF
ENDIF

;-[]-1630.0--WZ_Alarm-
; Altes Wz gebrochen
; oder nicht vermessen
;---------------------
IF (iAlarmNoBBK>0)
  ;BBK Alarme Ausgeben
  iAlarmNo=iAlarmNoBBK sAlarmParam=sAlarmParamBBK SYG_RM[iSYGArea]=rAlarmAreaBBK
  GOTOF ShowAlarm
ENDIF
;
;-[]-1630.1--WZ_Alarm--
; Neues Wz konnte nicht
; vermessen werden
;----------------------
IF (bNewTlNotMeasured)
  iAlarmNo=AL_TlNotMeasured SYG_RM[iSYGArea]=1630.1
  GOTOF ShowAlarm
ENDIF
;
;-[]-1630.2--WZ_Alarm----
; Neues Wz nicht gefunden
;------------------------
IF (sMissingTl<>"")
  iAlarmNo=AL_TlNotFound sAlarmParam=sMissingTl SYG_RM[iSYGArea]=1630.2
  GOTOF ShowAlarm
ENDIF

;-[]-1640.0--BBK_6---------------------------
; Ehemaliges SpWz sollte vermessen werden ->
; Warten bis Kanal 2 die Pruefung beendet hat
;--------------------------------------------
IF (bCheckOldTl)AND(iToDo==mcTaskPrep)AND(iOldTNo>0)AND(iNewTNo>0)
  ;
  ;-1640.1--BBK_6--------------------
  ; Warten bis BBK in Kanal 2 beendet
  ;----------------------------------
  IF (giToBreakCtrlState<>0)
    ;
    ;-1640.2--BBK_6-------------
    ; ToPrep arbeitet nur,
    ; wenn WzW nicht mehr laeuft
    ;---------------------------
    iErrCount=0 bEnabled=TRUE
    WHILE (giToBreakCtrlState<>0)
      G4 F=rWaitShort
      iErrCount=(iErrCount+SYG_IM[iSYGInc]) SYG_RM[iSYGArea]=1640.2
      IF (iErrCount>iErrTimeShort)AND(bEnabled)
        ;Meldung erst nach Wartezeit ausgeben
        MSG(MSG_ToBreakCtrlRunning)
        bEnabled=FALSE
      ENDIF
    ENDWHILE
    ;
    IF (NOT bEnabled)
      MSG("")
    ENDIF
  ENDIF
  ;
  ;-1640.3--BBK_6--------------------------
  ; Abloeschen, (ausser gbLastToBroken) da
  ; eventuell Abfrage im Bearbeitungsprogr.
  ;----------------------------------------
  ;
  giToBreakCtrlState=0 giToNoProb=0 gbToCheckAtTC=FALSE
  ;
  IF (($TC_TP8[iOldTNo] B_AND 'B100')<>0)
    ;
    ;Wz bei BBK gesperrt
    ;
    IF (gbLastToBroken)AND(((iProgConfig B_AND 'B10')==0)OR(gbErrMsgOnToCheck))
      ;
      ;-1640.4--BBK_6--------
      ; - Wz bei BBK gesperrt
      ; - Wz gebrochen
      ; - Reaktion gefordert
      ; -> Meldung und Stopp
      ; Weiter nach NCStart + 1s
      ;-------------------------
      MsgBox(<<AL_LastTlBrokenAsk67,"M0 DELAY=1.0",,"T="<<$TC_TP2[iOldTNo]<<"/"<<$TC_TP1[iOldTNo])
      ;
      gbLastToBroken=FALSE
    ENDIF
  ELSE
    gbLastToBroken=FALSE
  ENDIF
ENDIF

;-[]-1645.0--BBK_7-
;------------------
;
IF (NOT gbLastToBroken)AND(NOT gbPrevToBroken)
  ;
  ;kein BBK Fehler aufgetreten
  ;
  TOOL_BREAK_REACTION=0
ENDIF

;-[]-1650.0--ErstEinsatz-
;------------------------
IF (gbTlFirstMach)AND(iToDo==mcTaskPrep)
  ;
  IF ((iProgConfig B_AND 'B1')==0)
    ;
    ;Bedienerruf ist nicht abgewaehlt -> Meldung und Stopp -> Weiter nach NCStart + 1s
    MsgBox(<<AL_ConfirmNewSpTl67,"M0 DELAY=1.0",,"T="<<$TC_TP2[iNewTNo]<<"/"<<$TC_TP1[iNewTNo])
  ENDIF
  ;
  ;<Wz ist getestet> und <War im Einsatz> Setzen
  IF (gbTMIsHHD)
    ;
    iMeasCutNo=RTOI($TC_TPC2[iNewTNo]) $TC_TPC8[iNewTNo]=ITOR(RTOI($TC_TPC8[iNewTNo]) B_OR 'B1') $TC_TP8[iNewTNo]=ITOR(RTOI($TC_TP8[iNewTNo]) B_OR 'H80')
    ;
    IF (iMeasCutNo>0)AND($P_TOOLND[iNewTNo]>=iMeasCutNo)
      ;
      iMeasState=RTOI($TC_DPC2[iNewTNo,iMeasCutNo]) $TC_DPC2[iNewTNo,iMeasCutNo]=ITOR(iMeasState B_OR 'H100') 
    ENDIF
  ELSE
    iMeasState=RTOI($TC_TPC1[iNewTNo]) $TC_TPC1[iNewTNo]=ITOR(iMeasState B_OR 'H200') $TC_TP8[iNewTNo]=ITOR(RTOI($TC_TP8[iNewTNo]) B_OR 'H80')
  ENDIF
ENDIF

;-[]-1660.0--Wz Daten Pruefen-
;-----------------------------
IF (bNoRealTC)
  ;
  ;Es fand kein WzW statt
  ;
  ;Ueberpruefung der Offsetdaten des aktuellen SpindelWz's
  CheckTlData(gsReqTlData,0,iNewTNo)
  bOffsNotValid=(giResult>0) gsReqTlData=""
ENDIF
;
IF (bOffsNotValid)
  ;Wz Daten unzulaessig
  iAlarmNo=AL_WaitFor sAlarmParam=" <NCRESET>"
  MsgBox(<<iAlarmNo,"CLEAR RESET","FALSE",sAlarmParam)
ENDIF

;-[]-1670.0--Schmierung-
;-----------------------
IF (bLubActive)
  ;
  MSG(MSG_LubCycleActive)
  ;
  ;Warten bis Schmieren beendet
  M57
  ;
  MSG("")
ENDIF

;-[]-1680.0-APC Wait-
;--------------------
IF (bWaitAPC)
  ;Auf Ende Palettenwechsel warten
  M91
ENDIF

;-[]-1690.0-TestStop-
;--------------------
IF (iToDo==mcTaskPrep)AND(NOT bNoRealTC)AND(bTeststopReq)AND(giStepTestStop==0)
  ;Teststopp angefordert und noch nicht erfolgt
  Teststop(1)
ENDIF
;
RET

;-[]-9999.0--Alarme-
;-------------------
;
;===========
HandleAlarm:
;===========
;
;-9999.1--Alarme-
;----------------
gbTcActive=FALSE
;
IF (iTaskId==1)
  ;
  ;Abbruch beim Be-/Entladen -> negative Quittierung an FC8
  ToAckn(FALSE,iTaskId,iTaskIdNo,0,0,0,0,0,0,3)
ENDIF
;
;-9999.2--Alarme------------
; Warten auf laufende Achsen
;---------------------------
iErrCount=0 iErrTimeShort=RTOI(2/rWaitShort)
WHILE (iErrCount<iErrTimeShort)AND(($AA_STAT[mcAxX]<4)OR($AA_STAT[mcAxY]<4)OR(($AA_STAT[mcAxZ]<4)AND(bMoveZ))OR(($AA_STAT[mcAxB]<4))AND(bBAxis))
  G4 F=rWaitShort
  iErrCount=iErrCount+1
ENDWHILE
;
;-9999.3--Alarme--
; Warten auf NC DG
;-----------------
IF (bDGIsNCAxis)
  iErrCount=0
  WHILE (iErrCount<iErrTimeShort)AND($AA_STAT[mcAxDGRot]<4)
    G4 F=rWaitShort
    iErrCount=iErrCount+1
  ENDWHILE
ENDIF
;
;-9999.4--Alarme----
; Warten auf Scheibe
;-------------------
IF (bMagIsPickUpDisk)
  iErrCount=0
  WHILE (iErrCount<iErrTimeShort)AND($AA_STAT[mcAxV1]<4)
    G4 F=rWaitShort
    iErrCount=iErrCount+1
  ENDWHILE
ENDIF
;
;=========
ShowAlarm:
;=========
;
;-9999.5--Alarme-
; SynAct GndSt
;----------------
CANCEL(SyncID_TC+0,SyncID_TC+1,SyncID_TC+2,SyncID_TC+3,SyncID_TC+4,SyncID_TC+5,SyncID_TC+6,SyncID_TC+7,SyncID_TC+8)
;SyncID_TC+9..12 werden erst durch Reset gecancelt, damit die Ueberwachungen erhalten bleiben
;
;-[]-9999.6--Alarme-----
; Fehlermeldung Ausgeben
;-----------------------
;
IF (SYG_RM[iSYGArea]>0)
  MakeAlarmParam(sAlarmParam,sAlarmParam," {"<<SYG_RM[iSYGArea]<<"}")
ENDIF
;
MSG("")
;
SETAL(iAlarmNo,sAlarmParam)
;
LOOP
  M0
ENDLOOP
;
RET
